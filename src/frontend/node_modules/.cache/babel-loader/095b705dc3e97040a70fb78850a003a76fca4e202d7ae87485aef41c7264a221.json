{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar graphic = require(\"../../util/graphic\");\nvar SymbolClz = require(\"./Symbol\");\nvar _util = require(\"zrender/lib/core/util\");\nvar isObject = _util.isObject;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\nvar symbolDrawProto = SymbolDraw.prototype;\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of\n  // the symbol element shape. We use the same clip shape here as\n  // the line clip.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n  return opt || {};\n}\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\nvar _default = SymbolDraw;\nmodule.exports = _default;","map":{"version":3,"names":["graphic","require","SymbolClz","_util","isObject","SymbolDraw","symbolCtor","group","Group","_symbolCtor","symbolDrawProto","prototype","symbolNeedsDraw","data","point","idx","opt","isNaN","isIgnore","clipShape","contain","getItemVisual","updateData","normalizeUpdateOpt","seriesModel","hostModel","oldData","_data","SymbolCtor","seriesScope","makeSeriesScope","removeAll","diff","add","newIdx","getItemLayout","symbolEl","attr","setItemGraphicEl","update","oldIdx","getItemGraphicEl","remove","updateProps","position","el","fadeOut","execute","isPersistent","updateLayout","eachItemGraphicEl","incrementalPrepareUpdate","_seriesScope","incrementalUpdate","taskParams","updateIncrementalAndHover","isGroup","incremental","useHoverLayer","start","end","traverse","enableAnimation","itemStyle","getModel","getItemStyle","hoverItemStyle","symbolRotate","get","symbolOffset","hoverAnimation","labelModel","hoverLabelModel","cursorStyle","_default","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc/COMP90024-23S1-A2-Australia-Social-Media-Analytics/src/frontend/node_modules/echarts/lib/chart/helper/SymbolDraw.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"./Symbol\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of\n  // the symbol element shape. We use the same clip shape here as\n  // the line clip.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}