{"ast":null,"code":"require(\"core-js/modules/es.array.index-of.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.object.to-string.js\");\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\nrequire(\"core-js/modules/es.array.map.js\");\nrequire(\"core-js/modules/es.array.reverse.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\nvar __DEV__ = _config.__DEV__;\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar graphic = require(\"../../util/graphic\");\nvar modelUtil = require(\"../../util/model\");\nvar brushHelper = require(\"./brushHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar indexOf = zrUtil.indexOf;\nvar curry = zrUtil.curry;\nvar COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n/**\n * [option in constructor]:\n * {\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n * }\n *\n *\n * [targetInfo]:\n *\n * There can be multiple axes in a single targetInfo. Consider the case\n * of `grid` component, a targetInfo represents a grid which contains one or more\n * cartesian and one or more axes. And consider the case of parallel system,\n * which has multiple axes in a coordinate system.\n * Can be {\n *     panelId: ...,\n *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n *     coordSyses: all cartesians.\n *     gridModel: <grid component>\n *     xAxes: correspond to coordSyses on index\n *     yAxes: correspond to coordSyses on index\n * }\n * or {\n *     panelId: ...,\n *     coordSys: <geo coord sys>\n *     coordSyses: [<geo coord sys>]\n *     geoModel: <geo component>\n * }\n *\n *\n * [panelOpt]:\n *\n * Make from targetInfo. Input to BrushController.\n * {\n *     panelId: ...,\n *     rect: ...\n * }\n *\n *\n * [area]:\n *\n * Generated by BrushController or user input.\n * {\n *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n *     range: pixel range.\n *     coordRange: representitive coord range (the first one of coordRanges).\n *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n * }\n */\n\n/**\n * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} [opt]\n * @param {Array.<string>} [opt.include] include coordinate system types.\n */\n\nfunction BrushTargetManager(option, ecModel, opt) {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  var targetInfoList = this._targetInfoList = [];\n  var info = {};\n  var foundCpts = parseFinder(ecModel, option);\n  each(targetInfoBuilders, function (builder, type) {\n    if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n      builder(foundCpts, targetInfoList, info);\n    }\n  });\n}\nvar proto = BrushTargetManager.prototype;\nproto.setOutputRanges = function (areas, ecModel) {\n  this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n    if (!area.coordRange) {\n      area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n      // rebuild range by coordRange accrately, which may bring trouble when\n      // brushing only one item. So we use __rangeOffset to rebuilding range\n      // by coordRange. And this it only used in brush component so it is no\n      // need to be adapted to coordRanges.\n\n      var result = coordConvert[area.brushType](0, coordSys, coordRange);\n      area.__rangeOffset = {\n        offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n        xyMinMax: result.xyMinMax\n      };\n    }\n  });\n};\nproto.matchOutputRanges = function (areas, ecModel, cb) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    if (targetInfo && targetInfo !== true) {\n      zrUtil.each(targetInfo.coordSyses, function (coordSys) {\n        var result = coordConvert[area.brushType](1, coordSys, area.range);\n        cb(area, result.values, coordSys, ecModel);\n      });\n    }\n  }, this);\n};\nproto.setInputRanges = function (areas, ecModel) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n    if (targetInfo && targetInfo !== true) {\n      area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n      // not keep its original value, for the sake of the dataZoom scenario,\n      // where area.coordRange remains unchanged but area.range may be changed.\n      // (2) Only support converting one coordRange to pixel range in brush\n      // component. So do not consider `coordRanges`.\n      // (3) About __rangeOffset, see comment above.\n\n      var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n      var rangeOffset = area.__rangeOffset;\n      area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n    }\n  }, this);\n};\nproto.makePanelOpts = function (api, getDefaultBrushType) {\n  return zrUtil.map(this._targetInfoList, function (targetInfo) {\n    var rect = targetInfo.getPanelRect();\n    return {\n      panelId: targetInfo.panelId,\n      defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n      clipPath: brushHelper.makeRectPanelClipPath(rect),\n      isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n      getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n    };\n  });\n};\nproto.controlSeries = function (area, seriesModel, ecModel) {\n  // Check whether area is bound in coord, and series do not belong to that coord.\n  // If do not do this check, some brush (like lineX) will controll all axes.\n  var targetInfo = this.findTargetInfo(area, ecModel);\n  return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n};\n/**\n * If return Object, a coord found.\n * If reutrn true, global found.\n * Otherwise nothing found.\n *\n * @param {Object} area\n * @param {Array} targetInfoList\n * @return {Object|boolean}\n */\n\nproto.findTargetInfo = function (area, ecModel) {\n  var targetInfoList = this._targetInfoList;\n  var foundCpts = parseFinder(ecModel, area);\n  for (var i = 0; i < targetInfoList.length; i++) {\n    var targetInfo = targetInfoList[i];\n    var areaPanelId = area.panelId;\n    if (areaPanelId) {\n      if (targetInfo.panelId === areaPanelId) {\n        return targetInfo;\n      }\n    } else {\n      for (var i = 0; i < targetInfoMatchers.length; i++) {\n        if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n          return targetInfo;\n        }\n      }\n    }\n  }\n  return true;\n};\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\nfunction parseFinder(ecModel, option) {\n  return modelUtil.parseFinder(ecModel, option, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\nvar targetInfoBuilders = {\n  grid: function grid(foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = zrUtil.createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilder.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function geo(foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilder.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [\n// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n},\n// geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilder = {\n  grid: function grid() {\n    // grid is not Transformable.\n    return this.coordSys.grid.getRect().clone();\n  },\n  geo: function geo() {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function rect(to, coordSys, rangeOrCoordRange) {\n    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function polygon(to, coordSys, rangeOrCoordRange) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = zrUtil.map(rangeOrCoordRange, function (item) {\n      var p = coordSys[COORD_CONVERTS[to]](item);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function rect(values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function polygon(values, refer, scales) {\n    return zrUtil.map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\nvar _default = BrushTargetManager;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","__DEV__","zrUtil","graphic","modelUtil","brushHelper","each","indexOf","curry","COORD_CONVERTS","INCLUDE_FINDER_MAIN_TYPES","BrushTargetManager","option","ecModel","opt","targetInfoList","_targetInfoList","info","foundCpts","parseFinder","targetInfoBuilders","builder","type","include","proto","prototype","setOutputRanges","areas","matchOutputRanges","area","coordRange","coordSys","coordRanges","push","result","coordConvert","brushType","__rangeOffset","offset","diffProcessor","values","range","xyMinMax","cb","targetInfo","findTargetInfo","coordSyses","setInputRanges","panelId","rangeOffset","getScales","makePanelOpts","api","getDefaultBrushType","map","rect","getPanelRect","defaultBrushType","clipPath","makeRectPanelClipPath","isTargetByCursor","makeRectIsTargetByCursor","coordSysModel","getLinearBrushOtherExtent","makeLinearBrushOtherExtent","controlSeries","seriesModel","coordinateSystem","i","length","areaPanelId","targetInfoMatchers","formatMinMax","minMax","reverse","includeMainTypes","grid","xAxisModels","yAxisModels","gridModels","gridModelMap","createHashMap","xAxesHas","yAxesHas","axisModel","gridModel","axis","model","set","id","cartesians","getCartesians","cartesian","index","getAxis","panelRectBuilder","xAxisDeclared","yAxisDeclared","geo","geoModels","geoModel","xAxisModel","yAxisModel","getRect","clone","getBoundingRect","applyTransform","getTransform","lineX","axisConvert","lineY","to","rangeOrCoordRange","xminymin","xmaxymax","polygon","Infinity","item","p","Math","min","max","axisNameIndex","coordToData","toLocalCoord","toGlobalCoord","dataToCoord","NaN","axisDiffProcessor","refer","scales","idx","xyMinMaxCurr","xyMinMaxOrigin","sizeCurr","getSize","sizeOrigin","isNaN","_default","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc/COMP90024-23S1-A2-Australia-Social-Media-Analytics/src/frontend/node_modules/echarts/lib/component/helper/BrushTargetManager.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar brushHelper = require(\"./brushHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar indexOf = zrUtil.indexOf;\nvar curry = zrUtil.curry;\nvar COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n/**\n * [option in constructor]:\n * {\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n * }\n *\n *\n * [targetInfo]:\n *\n * There can be multiple axes in a single targetInfo. Consider the case\n * of `grid` component, a targetInfo represents a grid which contains one or more\n * cartesian and one or more axes. And consider the case of parallel system,\n * which has multiple axes in a coordinate system.\n * Can be {\n *     panelId: ...,\n *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n *     coordSyses: all cartesians.\n *     gridModel: <grid component>\n *     xAxes: correspond to coordSyses on index\n *     yAxes: correspond to coordSyses on index\n * }\n * or {\n *     panelId: ...,\n *     coordSys: <geo coord sys>\n *     coordSyses: [<geo coord sys>]\n *     geoModel: <geo component>\n * }\n *\n *\n * [panelOpt]:\n *\n * Make from targetInfo. Input to BrushController.\n * {\n *     panelId: ...,\n *     rect: ...\n * }\n *\n *\n * [area]:\n *\n * Generated by BrushController or user input.\n * {\n *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n *     range: pixel range.\n *     coordRange: representitive coord range (the first one of coordRanges).\n *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n * }\n */\n\n/**\n * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} [opt]\n * @param {Array.<string>} [opt.include] include coordinate system types.\n */\n\nfunction BrushTargetManager(option, ecModel, opt) {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  var targetInfoList = this._targetInfoList = [];\n  var info = {};\n  var foundCpts = parseFinder(ecModel, option);\n  each(targetInfoBuilders, function (builder, type) {\n    if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n      builder(foundCpts, targetInfoList, info);\n    }\n  });\n}\n\nvar proto = BrushTargetManager.prototype;\n\nproto.setOutputRanges = function (areas, ecModel) {\n  this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n    if (!area.coordRange) {\n      area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n      // rebuild range by coordRange accrately, which may bring trouble when\n      // brushing only one item. So we use __rangeOffset to rebuilding range\n      // by coordRange. And this it only used in brush component so it is no\n      // need to be adapted to coordRanges.\n\n      var result = coordConvert[area.brushType](0, coordSys, coordRange);\n      area.__rangeOffset = {\n        offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n        xyMinMax: result.xyMinMax\n      };\n    }\n  });\n};\n\nproto.matchOutputRanges = function (areas, ecModel, cb) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n\n    if (targetInfo && targetInfo !== true) {\n      zrUtil.each(targetInfo.coordSyses, function (coordSys) {\n        var result = coordConvert[area.brushType](1, coordSys, area.range);\n        cb(area, result.values, coordSys, ecModel);\n      });\n    }\n  }, this);\n};\n\nproto.setInputRanges = function (areas, ecModel) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n    if (targetInfo && targetInfo !== true) {\n      area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n      // not keep its original value, for the sake of the dataZoom scenario,\n      // where area.coordRange remains unchanged but area.range may be changed.\n      // (2) Only support converting one coordRange to pixel range in brush\n      // component. So do not consider `coordRanges`.\n      // (3) About __rangeOffset, see comment above.\n\n      var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n      var rangeOffset = area.__rangeOffset;\n      area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n    }\n  }, this);\n};\n\nproto.makePanelOpts = function (api, getDefaultBrushType) {\n  return zrUtil.map(this._targetInfoList, function (targetInfo) {\n    var rect = targetInfo.getPanelRect();\n    return {\n      panelId: targetInfo.panelId,\n      defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n      clipPath: brushHelper.makeRectPanelClipPath(rect),\n      isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n      getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n    };\n  });\n};\n\nproto.controlSeries = function (area, seriesModel, ecModel) {\n  // Check whether area is bound in coord, and series do not belong to that coord.\n  // If do not do this check, some brush (like lineX) will controll all axes.\n  var targetInfo = this.findTargetInfo(area, ecModel);\n  return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n};\n/**\n * If return Object, a coord found.\n * If reutrn true, global found.\n * Otherwise nothing found.\n *\n * @param {Object} area\n * @param {Array} targetInfoList\n * @return {Object|boolean}\n */\n\n\nproto.findTargetInfo = function (area, ecModel) {\n  var targetInfoList = this._targetInfoList;\n  var foundCpts = parseFinder(ecModel, area);\n\n  for (var i = 0; i < targetInfoList.length; i++) {\n    var targetInfo = targetInfoList[i];\n    var areaPanelId = area.panelId;\n\n    if (areaPanelId) {\n      if (targetInfo.panelId === areaPanelId) {\n        return targetInfo;\n      }\n    } else {\n      for (var i = 0; i < targetInfoMatchers.length; i++) {\n        if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n          return targetInfo;\n        }\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, option) {\n  return modelUtil.parseFinder(ecModel, option, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = zrUtil.createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilder.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilder.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilder = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.grid.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange) {\n    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = zrUtil.map(rangeOrCoordRange, function (item) {\n      var p = coordSys[COORD_CONVERTS[to]](item);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return zrUtil.map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nvar _default = BrushTargetManager;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}