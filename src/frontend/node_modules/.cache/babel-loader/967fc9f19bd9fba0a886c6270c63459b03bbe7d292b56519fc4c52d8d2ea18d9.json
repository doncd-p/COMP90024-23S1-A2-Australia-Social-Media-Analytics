{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar numberUtil = require(\"../../util/number\");\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar indexOf = zrUtil.indexOf;\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n} // Make it simple, do not visit all stacked value to count precision.\n// function getPrecision(data, valueAxisDim, dataIndex) {\n//     var precision = -1;\n//     var stackedDim = data.mapDimension(valueAxisDim);\n//     do {\n//         precision = Math.max(\n//             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),\n//             precision\n//         );\n//         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n//         if (stackedOnSeries) {\n//             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);\n//             data = stackedOnSeries.getData();\n//             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);\n//             stackedDim = data.getCalculationInfo('stackedDimension');\n//         }\n//         else {\n//             data = null;\n//         }\n//     } while (data);\n//     return precision;\n// }\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var stacked = isDimensionStacked(data, targetDataDim\n  /*, otherDataDim*/);\n\n  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\n  var value = numCalculate(data, calcDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\n  coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);\n  var coordArrValue = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.\n\n  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));\n  precision = Math.min(precision, 20);\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n  return [coordArr, coordArrValue];\n}\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);\n      item.coord = coordInfo[0]; // Force to use the value of calculated value.\n      // let item use the value without stack.\n\n      item.value = coordInfo[1];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\n        }\n      }\n      item.coord = coord;\n    }\n  }\n  return item;\n}\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\n  }\n  return ret;\n}\nfunction dataDimToCoordDim(seriesModel, dataDim) {\n  var data = seriesModel.getData();\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n  return item.value;\n}\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    });\n    return sum / count;\n  } else if (type === 'median') {\n    return data.getMedian(valueDataDim);\n  } else {\n    // max & min\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;","map":{"version":3,"names":["zrUtil","require","numberUtil","_dataStackHelper","isDimensionStacked","indexOf","hasXOrY","item","isNaN","parseFloat","x","y","hasXAndY","markerTypeCalculatorWithExtent","mlType","data","otherDataDim","targetDataDim","otherCoordIndex","targetCoordIndex","coordArr","stacked","calcDataDim","getCalculationInfo","value","numCalculate","dataIndex","indicesOfNearest","get","coordArrValue","precision","getPrecision","Math","min","toFixed","curry","markerTypeCalculator","max","average","dataTransform","seriesModel","getData","coordSys","coordinateSystem","isArray","coord","dims","dimensions","axisInfo","getAxisInfo","clone","type","baseAxis","valueAxis","dim","coordInfo","baseDataDim","valueDataDim","xAxis","radiusAxis","yAxis","angleAxis","i","mapDimension","ret","valueIndex","valueDim","getDimension","getAxis","dataDimToCoordDim","getOtherAxis","getBaseAxis","dataDim","length","dimItem","getDimensionInfo","name","coordDim","dataFilter","containData","dimValueGetter","dimName","dimIndex","sum","count","each","val","idx","getMedian","getDataExtent","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/echarts/lib/component/marker/markerHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n} // Make it simple, do not visit all stacked value to count precision.\n// function getPrecision(data, valueAxisDim, dataIndex) {\n//     var precision = -1;\n//     var stackedDim = data.mapDimension(valueAxisDim);\n//     do {\n//         precision = Math.max(\n//             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),\n//             precision\n//         );\n//         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n//         if (stackedOnSeries) {\n//             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);\n//             data = stackedOnSeries.getData();\n//             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);\n//             stackedDim = data.getCalculationInfo('stackedDimension');\n//         }\n//         else {\n//             data = null;\n//         }\n//     } while (data);\n//     return precision;\n// }\n\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var stacked = isDimensionStacked(data, targetDataDim\n  /*, otherDataDim*/\n  );\n  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\n  var value = numCalculate(data, calcDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\n  coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);\n  var coordArrValue = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.\n\n  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return [coordArr, coordArrValue];\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);\n      item.coord = coordInfo[0]; // Force to use the value of calculated value.\n      // let item use the value without stack.\n\n      item.value = coordInfo[1];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\n  }\n\n  return ret;\n}\n\nfunction dataDimToCoordDim(seriesModel, dataDim) {\n  var data = seriesModel.getData();\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    });\n    return sum / count;\n  } else if (type === 'median') {\n    return data.getMedian(valueDataDim);\n  } else {\n    // max & min\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}