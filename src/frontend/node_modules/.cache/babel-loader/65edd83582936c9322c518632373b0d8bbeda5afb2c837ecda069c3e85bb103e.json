{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar Scale = require(\"./Scale\");\nvar OrdinalMeta = require(\"../data/OrdinalMeta\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n// FIXME only one data\nvar scaleProto = Scale.prototype;\nvar OrdinalScale = Scale.extend({\n  type: 'ordinal',\n  /**\n   * @param {module:echarts/data/OrdianlMeta|Array.<string>} ordinalMeta\n   */\n  init: function (ordinalMeta, extent) {\n    // Caution: Should not use instanceof, consider ec-extensions using\n    // import approach to get OrdinalMeta class.\n    if (!ordinalMeta || zrUtil.isArray(ordinalMeta)) {\n      ordinalMeta = new OrdinalMeta({\n        categories: ordinalMeta\n      });\n    }\n    this._ordinalMeta = ordinalMeta;\n    this._extent = extent || [0, ordinalMeta.categories.length - 1];\n  },\n  parse: function (val) {\n    return typeof val === 'string' ? this._ordinalMeta.getOrdinal(val) // val might be float.\n    : Math.round(val);\n  },\n  contain: function (rank) {\n    rank = this.parse(rank);\n    return scaleProto.contain.call(this, rank) && this._ordinalMeta.categories[rank] != null;\n  },\n  /**\n   * Normalize given rank or name to linear [0, 1]\n   * @param {number|string} [val]\n   * @return {number}\n   */\n  normalize: function (val) {\n    return scaleProto.normalize.call(this, this.parse(val));\n  },\n  scale: function (val) {\n    return Math.round(scaleProto.scale.call(this, val));\n  },\n  /**\n   * @return {Array}\n   */\n  getTicks: function () {\n    var ticks = [];\n    var extent = this._extent;\n    var rank = extent[0];\n    while (rank <= extent[1]) {\n      ticks.push(rank);\n      rank++;\n    }\n    return ticks;\n  },\n  /**\n   * Get item on rank n\n   * @param {number} n\n   * @return {string}\n   */\n  getLabel: function (n) {\n    if (!this.isBlank()) {\n      // Note that if no data, ordinalMeta.categories is an empty array.\n      return this._ordinalMeta.categories[n];\n    }\n  },\n  /**\n   * @return {number}\n   */\n  count: function () {\n    return this._extent[1] - this._extent[0] + 1;\n  },\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    this.unionExtent(data.getApproximateExtent(dim));\n  },\n  getOrdinalMeta: function () {\n    return this._ordinalMeta;\n  },\n  niceTicks: zrUtil.noop,\n  niceExtent: zrUtil.noop\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nOrdinalScale.create = function () {\n  return new OrdinalScale();\n};\nvar _default = OrdinalScale;\nmodule.exports = _default;","map":{"version":3,"names":["zrUtil","require","Scale","OrdinalMeta","scaleProto","prototype","OrdinalScale","extend","type","init","ordinalMeta","extent","isArray","categories","_ordinalMeta","_extent","length","parse","val","getOrdinal","Math","round","contain","rank","call","normalize","scale","getTicks","ticks","push","getLabel","n","isBlank","count","unionExtentFromData","data","dim","unionExtent","getApproximateExtent","getOrdinalMeta","niceTicks","noop","niceExtent","create","_default","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/echarts/lib/scale/Ordinal.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Scale = require(\"./Scale\");\n\nvar OrdinalMeta = require(\"../data/OrdinalMeta\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n// FIXME only one data\nvar scaleProto = Scale.prototype;\nvar OrdinalScale = Scale.extend({\n  type: 'ordinal',\n\n  /**\n   * @param {module:echarts/data/OrdianlMeta|Array.<string>} ordinalMeta\n   */\n  init: function (ordinalMeta, extent) {\n    // Caution: Should not use instanceof, consider ec-extensions using\n    // import approach to get OrdinalMeta class.\n    if (!ordinalMeta || zrUtil.isArray(ordinalMeta)) {\n      ordinalMeta = new OrdinalMeta({\n        categories: ordinalMeta\n      });\n    }\n\n    this._ordinalMeta = ordinalMeta;\n    this._extent = extent || [0, ordinalMeta.categories.length - 1];\n  },\n  parse: function (val) {\n    return typeof val === 'string' ? this._ordinalMeta.getOrdinal(val) // val might be float.\n    : Math.round(val);\n  },\n  contain: function (rank) {\n    rank = this.parse(rank);\n    return scaleProto.contain.call(this, rank) && this._ordinalMeta.categories[rank] != null;\n  },\n\n  /**\n   * Normalize given rank or name to linear [0, 1]\n   * @param {number|string} [val]\n   * @return {number}\n   */\n  normalize: function (val) {\n    return scaleProto.normalize.call(this, this.parse(val));\n  },\n  scale: function (val) {\n    return Math.round(scaleProto.scale.call(this, val));\n  },\n\n  /**\n   * @return {Array}\n   */\n  getTicks: function () {\n    var ticks = [];\n    var extent = this._extent;\n    var rank = extent[0];\n\n    while (rank <= extent[1]) {\n      ticks.push(rank);\n      rank++;\n    }\n\n    return ticks;\n  },\n\n  /**\n   * Get item on rank n\n   * @param {number} n\n   * @return {string}\n   */\n  getLabel: function (n) {\n    if (!this.isBlank()) {\n      // Note that if no data, ordinalMeta.categories is an empty array.\n      return this._ordinalMeta.categories[n];\n    }\n  },\n\n  /**\n   * @return {number}\n   */\n  count: function () {\n    return this._extent[1] - this._extent[0] + 1;\n  },\n\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    this.unionExtent(data.getApproximateExtent(dim));\n  },\n  getOrdinalMeta: function () {\n    return this._ordinalMeta;\n  },\n  niceTicks: zrUtil.noop,\n  niceExtent: zrUtil.noop\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nOrdinalScale.create = function () {\n  return new OrdinalScale();\n};\n\nvar _default = OrdinalScale;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}