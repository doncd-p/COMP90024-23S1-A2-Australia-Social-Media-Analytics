{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.unshift.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\nvar __DEV__ = _config.__DEV__;\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar VisualMapModel = require(\"./VisualMapModel\");\nvar VisualMapping = require(\"../../visual/VisualMapping\");\nvar visualDefault = require(\"../../visual/visualDefault\");\nvar _number = require(\"../../util/number\");\nvar reformIntervals = _number.reformIntervals;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PiecewiseModel = VisualMapModel.extend({\n  type: 'visualMap.piecewise',\n  /**\n   * Order Rule:\n   *\n   * option.categories / option.pieces / option.text / option.selected:\n   *     If !option.inverse,\n   *     Order when vertical: ['top', ..., 'bottom'].\n   *     Order when horizontal: ['left', ..., 'right'].\n   *     If option.inverse, the meaning of\n   *     the order should be reversed.\n   *\n   * this._pieceList:\n   *     The order is always [low, ..., high].\n   *\n   * Mapping from location to low-high:\n   *     If !option.inverse\n   *     When vertical, top is high.\n   *     When horizontal, right is high.\n   *     If option.inverse, reverse.\n   */\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    selected: null,\n    // Object. If not specified, means selected.\n    // When pieces and splitNumber: {'0': true, '5': true}\n    // When categories: {'cate1': false, 'cate3': true}\n    // When selected === false, means all unselected.\n    minOpen: false,\n    // Whether include values that smaller than `min`.\n    maxOpen: false,\n    // Whether include values that bigger than `max`.\n    align: 'auto',\n    // 'auto', 'left', 'right'\n    itemWidth: 20,\n    // When put the controller vertically, it is the length of\n    // horizontal side of each item. Otherwise, vertical side.\n    itemHeight: 14,\n    // When put the controller vertically, it is the length of\n    // vertical side of each item. Otherwise, horizontal side.\n    itemSymbol: 'roundRect',\n    pieceList: null,\n    // Each item is Object, with some of those attrs:\n    // {min, max, lt, gt, lte, gte, value,\n    // color, colorSaturation, colorAlpha, opacity,\n    // symbol, symbolSize}, which customize the range or visual\n    // coding of the certain piece. Besides, see \"Order Rule\".\n    categories: null,\n    // category names, like: ['some1', 'some2', 'some3'].\n    // Attr min/max are ignored when categories set. See \"Order Rule\"\n    splitNumber: 5,\n    // If set to 5, auto split five pieces equally.\n    // If set to 0 and component type not set, component type will be\n    // determined as \"continuous\". (It is less reasonable but for ec2\n    // compatibility, see echarts/component/visualMap/typeDefaulter)\n    selectedMode: 'multiple',\n    // Can be 'multiple' or 'single'.\n    itemGap: 10,\n    // The gap between two items, in px.\n    hoverLink: true,\n    // Enable hover highlight.\n    showLabel: null // By default, when text is used, label will hide (the logic\n    // is remained for compatibility reason)\n  },\n\n  /**\n   * @override\n   */\n  optionUpdated: function (newOption, isInit) {\n    PiecewiseModel.superApply(this, 'optionUpdated', arguments);\n    /**\n     * The order is always [low, ..., high].\n     * [{text: string, interval: Array.<number>}, ...]\n     * @private\n     * @type {Array.<Object>}\n     */\n\n    this._pieceList = [];\n    this.resetExtent();\n    /**\n     * 'pieces', 'categories', 'splitNumber'\n     * @type {string}\n     */\n\n    var mode = this._mode = this._determineMode();\n    resetMethods[this._mode].call(this);\n    this._resetSelected(newOption, isInit);\n    var categories = this.option.categories;\n    this.resetVisual(function (mappingOption, state) {\n      if (mode === 'categories') {\n        mappingOption.mappingMethod = 'category';\n        mappingOption.categories = zrUtil.clone(categories);\n      } else {\n        mappingOption.dataExtent = this.getExtent();\n        mappingOption.mappingMethod = 'piecewise';\n        mappingOption.pieceList = zrUtil.map(this._pieceList, function (piece) {\n          var piece = zrUtil.clone(piece);\n          if (state !== 'inRange') {\n            // FIXME\n            // outOfRange do not support special visual in pieces.\n            piece.visual = null;\n          }\n          return piece;\n        });\n      }\n    });\n  },\n  /**\n   * @protected\n   * @override\n   */\n  completeVisualOption: function () {\n    // Consider this case:\n    // visualMap: {\n    //      pieces: [{symbol: 'circle', lt: 0}, {symbol: 'rect', gte: 0}]\n    // }\n    // where no inRange/outOfRange set but only pieces. So we should make\n    // default inRange/outOfRange for this case, otherwise visuals that only\n    // appear in `pieces` will not be taken into account in visual encoding.\n    var option = this.option;\n    var visualTypesInPieces = {};\n    var visualTypes = VisualMapping.listVisualTypes();\n    var isCategory = this.isCategory();\n    zrUtil.each(option.pieces, function (piece) {\n      zrUtil.each(visualTypes, function (visualType) {\n        if (piece.hasOwnProperty(visualType)) {\n          visualTypesInPieces[visualType] = 1;\n        }\n      });\n    });\n    zrUtil.each(visualTypesInPieces, function (v, visualType) {\n      var exists = 0;\n      zrUtil.each(this.stateList, function (state) {\n        exists |= has(option, state, visualType) || has(option.target, state, visualType);\n      }, this);\n      !exists && zrUtil.each(this.stateList, function (state) {\n        (option[state] || (option[state] = {}))[visualType] = visualDefault.get(visualType, state === 'inRange' ? 'active' : 'inactive', isCategory);\n      });\n    }, this);\n    function has(obj, state, visualType) {\n      return obj && obj[state] && (zrUtil.isObject(obj[state]) ? obj[state].hasOwnProperty(visualType) : obj[state] === visualType // e.g., inRange: 'symbol'\n      );\n    }\n\n    VisualMapModel.prototype.completeVisualOption.apply(this, arguments);\n  },\n  _resetSelected: function (newOption, isInit) {\n    var thisOption = this.option;\n    var pieceList = this._pieceList; // Selected do not merge but all override.\n\n    var selected = (isInit ? thisOption : newOption).selected || {};\n    thisOption.selected = selected; // Consider 'not specified' means true.\n\n    zrUtil.each(pieceList, function (piece, index) {\n      var key = this.getSelectedMapKey(piece);\n      if (!selected.hasOwnProperty(key)) {\n        selected[key] = true;\n      }\n    }, this);\n    if (thisOption.selectedMode === 'single') {\n      // Ensure there is only one selected.\n      var hasSel = false;\n      zrUtil.each(pieceList, function (piece, index) {\n        var key = this.getSelectedMapKey(piece);\n        if (selected[key]) {\n          hasSel ? selected[key] = false : hasSel = true;\n        }\n      }, this);\n    } // thisOption.selectedMode === 'multiple', default: all selected.\n  },\n\n  /**\n   * @public\n   */\n  getSelectedMapKey: function (piece) {\n    return this._mode === 'categories' ? piece.value + '' : piece.index + '';\n  },\n  /**\n   * @public\n   */\n  getPieceList: function () {\n    return this._pieceList;\n  },\n  /**\n   * @private\n   * @return {string}\n   */\n  _determineMode: function () {\n    var option = this.option;\n    return option.pieces && option.pieces.length > 0 ? 'pieces' : this.option.categories ? 'categories' : 'splitNumber';\n  },\n  /**\n   * @public\n   * @override\n   */\n  setSelected: function (selected) {\n    this.option.selected = zrUtil.clone(selected);\n  },\n  /**\n   * @public\n   * @override\n   */\n  getValueState: function (value) {\n    var index = VisualMapping.findPieceIndex(value, this._pieceList);\n    return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? 'inRange' : 'outOfRange' : 'outOfRange';\n  },\n  /**\n   * @public\n   * @params {number} pieceIndex piece index in visualMapModel.getPieceList()\n   * @return {Array.<Object>} [{seriesId, dataIndex: <Array.<number>>}, ...]\n   */\n  findTargetDataIndices: function (pieceIndex) {\n    var result = [];\n    this.eachTargetSeries(function (seriesModel) {\n      var dataIndices = [];\n      var data = seriesModel.getData();\n      data.each(this.getDataDimension(data), function (value, dataIndex) {\n        // Should always base on model pieceList, because it is order sensitive.\n        var pIdx = VisualMapping.findPieceIndex(value, this._pieceList);\n        pIdx === pieceIndex && dataIndices.push(dataIndex);\n      }, this);\n      result.push({\n        seriesId: seriesModel.id,\n        dataIndex: dataIndices\n      });\n    }, this);\n    return result;\n  },\n  /**\n   * @private\n   * @param {Object} piece piece.value or piece.interval is required.\n   * @return {number} Can be Infinity or -Infinity\n   */\n  getRepresentValue: function (piece) {\n    var representValue;\n    if (this.isCategory()) {\n      representValue = piece.value;\n    } else {\n      if (piece.value != null) {\n        representValue = piece.value;\n      } else {\n        var pieceInterval = piece.interval || [];\n        representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;\n      }\n    }\n    return representValue;\n  },\n  getVisualMeta: function (getColorVisual) {\n    // Do not support category. (category axis is ordinal, numerical)\n    if (this.isCategory()) {\n      return;\n    }\n    var stops = [];\n    var outerColors = [];\n    var visualMapModel = this;\n    function setStop(interval, valueState) {\n      var representValue = visualMapModel.getRepresentValue({\n        interval: interval\n      });\n      if (!valueState) {\n        valueState = visualMapModel.getValueState(representValue);\n      }\n      var color = getColorVisual(representValue, valueState);\n      if (interval[0] === -Infinity) {\n        outerColors[0] = color;\n      } else if (interval[1] === Infinity) {\n        outerColors[1] = color;\n      } else {\n        stops.push({\n          value: interval[0],\n          color: color\n        }, {\n          value: interval[1],\n          color: color\n        });\n      }\n    } // Suplement\n\n    var pieceList = this._pieceList.slice();\n    if (!pieceList.length) {\n      pieceList.push({\n        interval: [-Infinity, Infinity]\n      });\n    } else {\n      var edge = pieceList[0].interval[0];\n      edge !== -Infinity && pieceList.unshift({\n        interval: [-Infinity, edge]\n      });\n      edge = pieceList[pieceList.length - 1].interval[1];\n      edge !== Infinity && pieceList.push({\n        interval: [edge, Infinity]\n      });\n    }\n    var curr = -Infinity;\n    zrUtil.each(pieceList, function (piece) {\n      var interval = piece.interval;\n      if (interval) {\n        // Fulfill gap.\n        interval[0] > curr && setStop([curr, interval[0]], 'outOfRange');\n        setStop(interval.slice());\n        curr = interval[1];\n      }\n    }, this);\n    return {\n      stops: stops,\n      outerColors: outerColors\n    };\n  }\n});\n/**\n * Key is this._mode\n * @type {Object}\n * @this {module:echarts/component/viusalMap/PiecewiseMode}\n */\n\nvar resetMethods = {\n  splitNumber: function () {\n    var thisOption = this.option;\n    var pieceList = this._pieceList;\n    var precision = Math.min(thisOption.precision, 20);\n    var dataExtent = this.getExtent();\n    var splitNumber = thisOption.splitNumber;\n    splitNumber = Math.max(parseInt(splitNumber, 10), 1);\n    thisOption.splitNumber = splitNumber;\n    var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber; // Precision auto-adaption\n\n    while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {\n      precision++;\n    }\n    thisOption.precision = precision;\n    splitStep = +splitStep.toFixed(precision);\n    if (thisOption.minOpen) {\n      pieceList.push({\n        interval: [-Infinity, dataExtent[0]],\n        close: [0, 0]\n      });\n    }\n    for (var index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {\n      var max = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;\n      pieceList.push({\n        interval: [curr, max],\n        close: [1, 1]\n      });\n    }\n    if (thisOption.maxOpen) {\n      pieceList.push({\n        interval: [dataExtent[1], Infinity],\n        close: [0, 0]\n      });\n    }\n    reformIntervals(pieceList);\n    zrUtil.each(pieceList, function (piece, index) {\n      piece.index = index;\n      piece.text = this.formatValueText(piece.interval);\n    }, this);\n  },\n  categories: function () {\n    var thisOption = this.option;\n    zrUtil.each(thisOption.categories, function (cate) {\n      // FIXME category模式也使用pieceList，但在visualMapping中不是使用pieceList。\n      // 是否改一致。\n      this._pieceList.push({\n        text: this.formatValueText(cate, true),\n        value: cate\n      });\n    }, this); // See \"Order Rule\".\n\n    normalizeReverse(thisOption, this._pieceList);\n  },\n  pieces: function () {\n    var thisOption = this.option;\n    var pieceList = this._pieceList;\n    zrUtil.each(thisOption.pieces, function (pieceListItem, index) {\n      if (!zrUtil.isObject(pieceListItem)) {\n        pieceListItem = {\n          value: pieceListItem\n        };\n      }\n      var item = {\n        text: '',\n        index: index\n      };\n      if (pieceListItem.label != null) {\n        item.text = pieceListItem.label;\n      }\n      if (pieceListItem.hasOwnProperty('value')) {\n        var value = item.value = pieceListItem.value;\n        item.interval = [value, value];\n        item.close = [1, 1];\n      } else {\n        // `min` `max` is legacy option.\n        // `lt` `gt` `lte` `gte` is recommanded.\n        var interval = item.interval = [];\n        var close = item.close = [0, 0];\n        var closeList = [1, 0, 1];\n        var infinityList = [-Infinity, Infinity];\n        var useMinMax = [];\n        for (var lg = 0; lg < 2; lg++) {\n          var names = [['gte', 'gt', 'min'], ['lte', 'lt', 'max']][lg];\n          for (var i = 0; i < 3 && interval[lg] == null; i++) {\n            interval[lg] = pieceListItem[names[i]];\n            close[lg] = closeList[i];\n            useMinMax[lg] = i === 2;\n          }\n          interval[lg] == null && (interval[lg] = infinityList[lg]);\n        }\n        useMinMax[0] && interval[1] === Infinity && (close[0] = 0);\n        useMinMax[1] && interval[0] === -Infinity && (close[1] = 0);\n        if (interval[0] === interval[1] && close[0] && close[1]) {\n          // Consider: [{min: 5, max: 5, visual: {...}}, {min: 0, max: 5}],\n          // we use value to lift the priority when min === max\n          item.value = interval[0];\n        }\n      }\n      item.visual = VisualMapping.retrieveVisuals(pieceListItem);\n      pieceList.push(item);\n    }, this); // See \"Order Rule\".\n\n    normalizeReverse(thisOption, pieceList); // Only pieces\n\n    reformIntervals(pieceList);\n    zrUtil.each(pieceList, function (piece) {\n      var close = piece.close;\n      var edgeSymbols = [['<', '≤'][close[1]], ['>', '≥'][close[0]]];\n      piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);\n    }, this);\n  }\n};\nfunction normalizeReverse(thisOption, pieceList) {\n  var inverse = thisOption.inverse;\n  if (thisOption.orient === 'vertical' ? !inverse : inverse) {\n    pieceList.reverse();\n  }\n}\nvar _default = PiecewiseModel;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","__DEV__","zrUtil","VisualMapModel","VisualMapping","visualDefault","_number","reformIntervals","PiecewiseModel","extend","type","defaultOption","selected","minOpen","maxOpen","align","itemWidth","itemHeight","itemSymbol","pieceList","categories","splitNumber","selectedMode","itemGap","hoverLink","showLabel","optionUpdated","newOption","isInit","superApply","arguments","_pieceList","resetExtent","mode","_mode","_determineMode","resetMethods","call","_resetSelected","option","resetVisual","mappingOption","state","mappingMethod","clone","dataExtent","getExtent","map","piece","visual","completeVisualOption","visualTypesInPieces","visualTypes","listVisualTypes","isCategory","each","pieces","visualType","hasOwnProperty","v","exists","stateList","has","target","get","obj","isObject","prototype","apply","thisOption","index","key","getSelectedMapKey","hasSel","value","getPieceList","length","setSelected","getValueState","findPieceIndex","findTargetDataIndices","pieceIndex","result","eachTargetSeries","seriesModel","dataIndices","data","getData","getDataDimension","dataIndex","pIdx","push","seriesId","id","getRepresentValue","representValue","pieceInterval","interval","Infinity","getVisualMeta","getColorVisual","stops","outerColors","visualMapModel","setStop","valueState","color","slice","edge","unshift","curr","precision","Math","min","max","parseInt","splitStep","toFixed","close","text","formatValueText","cate","normalizeReverse","pieceListItem","item","label","closeList","infinityList","useMinMax","lg","names","i","retrieveVisuals","edgeSymbols","inverse","orient","reverse","_default","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/echarts/lib/component/visualMap/PiecewiseModel.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar VisualMapModel = require(\"./VisualMapModel\");\n\nvar VisualMapping = require(\"../../visual/VisualMapping\");\n\nvar visualDefault = require(\"../../visual/visualDefault\");\n\nvar _number = require(\"../../util/number\");\n\nvar reformIntervals = _number.reformIntervals;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PiecewiseModel = VisualMapModel.extend({\n  type: 'visualMap.piecewise',\n\n  /**\n   * Order Rule:\n   *\n   * option.categories / option.pieces / option.text / option.selected:\n   *     If !option.inverse,\n   *     Order when vertical: ['top', ..., 'bottom'].\n   *     Order when horizontal: ['left', ..., 'right'].\n   *     If option.inverse, the meaning of\n   *     the order should be reversed.\n   *\n   * this._pieceList:\n   *     The order is always [low, ..., high].\n   *\n   * Mapping from location to low-high:\n   *     If !option.inverse\n   *     When vertical, top is high.\n   *     When horizontal, right is high.\n   *     If option.inverse, reverse.\n   */\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    selected: null,\n    // Object. If not specified, means selected.\n    // When pieces and splitNumber: {'0': true, '5': true}\n    // When categories: {'cate1': false, 'cate3': true}\n    // When selected === false, means all unselected.\n    minOpen: false,\n    // Whether include values that smaller than `min`.\n    maxOpen: false,\n    // Whether include values that bigger than `max`.\n    align: 'auto',\n    // 'auto', 'left', 'right'\n    itemWidth: 20,\n    // When put the controller vertically, it is the length of\n    // horizontal side of each item. Otherwise, vertical side.\n    itemHeight: 14,\n    // When put the controller vertically, it is the length of\n    // vertical side of each item. Otherwise, horizontal side.\n    itemSymbol: 'roundRect',\n    pieceList: null,\n    // Each item is Object, with some of those attrs:\n    // {min, max, lt, gt, lte, gte, value,\n    // color, colorSaturation, colorAlpha, opacity,\n    // symbol, symbolSize}, which customize the range or visual\n    // coding of the certain piece. Besides, see \"Order Rule\".\n    categories: null,\n    // category names, like: ['some1', 'some2', 'some3'].\n    // Attr min/max are ignored when categories set. See \"Order Rule\"\n    splitNumber: 5,\n    // If set to 5, auto split five pieces equally.\n    // If set to 0 and component type not set, component type will be\n    // determined as \"continuous\". (It is less reasonable but for ec2\n    // compatibility, see echarts/component/visualMap/typeDefaulter)\n    selectedMode: 'multiple',\n    // Can be 'multiple' or 'single'.\n    itemGap: 10,\n    // The gap between two items, in px.\n    hoverLink: true,\n    // Enable hover highlight.\n    showLabel: null // By default, when text is used, label will hide (the logic\n    // is remained for compatibility reason)\n\n  },\n\n  /**\n   * @override\n   */\n  optionUpdated: function (newOption, isInit) {\n    PiecewiseModel.superApply(this, 'optionUpdated', arguments);\n    /**\n     * The order is always [low, ..., high].\n     * [{text: string, interval: Array.<number>}, ...]\n     * @private\n     * @type {Array.<Object>}\n     */\n\n    this._pieceList = [];\n    this.resetExtent();\n    /**\n     * 'pieces', 'categories', 'splitNumber'\n     * @type {string}\n     */\n\n    var mode = this._mode = this._determineMode();\n\n    resetMethods[this._mode].call(this);\n\n    this._resetSelected(newOption, isInit);\n\n    var categories = this.option.categories;\n    this.resetVisual(function (mappingOption, state) {\n      if (mode === 'categories') {\n        mappingOption.mappingMethod = 'category';\n        mappingOption.categories = zrUtil.clone(categories);\n      } else {\n        mappingOption.dataExtent = this.getExtent();\n        mappingOption.mappingMethod = 'piecewise';\n        mappingOption.pieceList = zrUtil.map(this._pieceList, function (piece) {\n          var piece = zrUtil.clone(piece);\n\n          if (state !== 'inRange') {\n            // FIXME\n            // outOfRange do not support special visual in pieces.\n            piece.visual = null;\n          }\n\n          return piece;\n        });\n      }\n    });\n  },\n\n  /**\n   * @protected\n   * @override\n   */\n  completeVisualOption: function () {\n    // Consider this case:\n    // visualMap: {\n    //      pieces: [{symbol: 'circle', lt: 0}, {symbol: 'rect', gte: 0}]\n    // }\n    // where no inRange/outOfRange set but only pieces. So we should make\n    // default inRange/outOfRange for this case, otherwise visuals that only\n    // appear in `pieces` will not be taken into account in visual encoding.\n    var option = this.option;\n    var visualTypesInPieces = {};\n    var visualTypes = VisualMapping.listVisualTypes();\n    var isCategory = this.isCategory();\n    zrUtil.each(option.pieces, function (piece) {\n      zrUtil.each(visualTypes, function (visualType) {\n        if (piece.hasOwnProperty(visualType)) {\n          visualTypesInPieces[visualType] = 1;\n        }\n      });\n    });\n    zrUtil.each(visualTypesInPieces, function (v, visualType) {\n      var exists = 0;\n      zrUtil.each(this.stateList, function (state) {\n        exists |= has(option, state, visualType) || has(option.target, state, visualType);\n      }, this);\n      !exists && zrUtil.each(this.stateList, function (state) {\n        (option[state] || (option[state] = {}))[visualType] = visualDefault.get(visualType, state === 'inRange' ? 'active' : 'inactive', isCategory);\n      });\n    }, this);\n\n    function has(obj, state, visualType) {\n      return obj && obj[state] && (zrUtil.isObject(obj[state]) ? obj[state].hasOwnProperty(visualType) : obj[state] === visualType // e.g., inRange: 'symbol'\n      );\n    }\n\n    VisualMapModel.prototype.completeVisualOption.apply(this, arguments);\n  },\n  _resetSelected: function (newOption, isInit) {\n    var thisOption = this.option;\n    var pieceList = this._pieceList; // Selected do not merge but all override.\n\n    var selected = (isInit ? thisOption : newOption).selected || {};\n    thisOption.selected = selected; // Consider 'not specified' means true.\n\n    zrUtil.each(pieceList, function (piece, index) {\n      var key = this.getSelectedMapKey(piece);\n\n      if (!selected.hasOwnProperty(key)) {\n        selected[key] = true;\n      }\n    }, this);\n\n    if (thisOption.selectedMode === 'single') {\n      // Ensure there is only one selected.\n      var hasSel = false;\n      zrUtil.each(pieceList, function (piece, index) {\n        var key = this.getSelectedMapKey(piece);\n\n        if (selected[key]) {\n          hasSel ? selected[key] = false : hasSel = true;\n        }\n      }, this);\n    } // thisOption.selectedMode === 'multiple', default: all selected.\n\n  },\n\n  /**\n   * @public\n   */\n  getSelectedMapKey: function (piece) {\n    return this._mode === 'categories' ? piece.value + '' : piece.index + '';\n  },\n\n  /**\n   * @public\n   */\n  getPieceList: function () {\n    return this._pieceList;\n  },\n\n  /**\n   * @private\n   * @return {string}\n   */\n  _determineMode: function () {\n    var option = this.option;\n    return option.pieces && option.pieces.length > 0 ? 'pieces' : this.option.categories ? 'categories' : 'splitNumber';\n  },\n\n  /**\n   * @public\n   * @override\n   */\n  setSelected: function (selected) {\n    this.option.selected = zrUtil.clone(selected);\n  },\n\n  /**\n   * @public\n   * @override\n   */\n  getValueState: function (value) {\n    var index = VisualMapping.findPieceIndex(value, this._pieceList);\n    return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? 'inRange' : 'outOfRange' : 'outOfRange';\n  },\n\n  /**\n   * @public\n   * @params {number} pieceIndex piece index in visualMapModel.getPieceList()\n   * @return {Array.<Object>} [{seriesId, dataIndex: <Array.<number>>}, ...]\n   */\n  findTargetDataIndices: function (pieceIndex) {\n    var result = [];\n    this.eachTargetSeries(function (seriesModel) {\n      var dataIndices = [];\n      var data = seriesModel.getData();\n      data.each(this.getDataDimension(data), function (value, dataIndex) {\n        // Should always base on model pieceList, because it is order sensitive.\n        var pIdx = VisualMapping.findPieceIndex(value, this._pieceList);\n        pIdx === pieceIndex && dataIndices.push(dataIndex);\n      }, this);\n      result.push({\n        seriesId: seriesModel.id,\n        dataIndex: dataIndices\n      });\n    }, this);\n    return result;\n  },\n\n  /**\n   * @private\n   * @param {Object} piece piece.value or piece.interval is required.\n   * @return {number} Can be Infinity or -Infinity\n   */\n  getRepresentValue: function (piece) {\n    var representValue;\n\n    if (this.isCategory()) {\n      representValue = piece.value;\n    } else {\n      if (piece.value != null) {\n        representValue = piece.value;\n      } else {\n        var pieceInterval = piece.interval || [];\n        representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;\n      }\n    }\n\n    return representValue;\n  },\n  getVisualMeta: function (getColorVisual) {\n    // Do not support category. (category axis is ordinal, numerical)\n    if (this.isCategory()) {\n      return;\n    }\n\n    var stops = [];\n    var outerColors = [];\n    var visualMapModel = this;\n\n    function setStop(interval, valueState) {\n      var representValue = visualMapModel.getRepresentValue({\n        interval: interval\n      });\n\n      if (!valueState) {\n        valueState = visualMapModel.getValueState(representValue);\n      }\n\n      var color = getColorVisual(representValue, valueState);\n\n      if (interval[0] === -Infinity) {\n        outerColors[0] = color;\n      } else if (interval[1] === Infinity) {\n        outerColors[1] = color;\n      } else {\n        stops.push({\n          value: interval[0],\n          color: color\n        }, {\n          value: interval[1],\n          color: color\n        });\n      }\n    } // Suplement\n\n\n    var pieceList = this._pieceList.slice();\n\n    if (!pieceList.length) {\n      pieceList.push({\n        interval: [-Infinity, Infinity]\n      });\n    } else {\n      var edge = pieceList[0].interval[0];\n      edge !== -Infinity && pieceList.unshift({\n        interval: [-Infinity, edge]\n      });\n      edge = pieceList[pieceList.length - 1].interval[1];\n      edge !== Infinity && pieceList.push({\n        interval: [edge, Infinity]\n      });\n    }\n\n    var curr = -Infinity;\n    zrUtil.each(pieceList, function (piece) {\n      var interval = piece.interval;\n\n      if (interval) {\n        // Fulfill gap.\n        interval[0] > curr && setStop([curr, interval[0]], 'outOfRange');\n        setStop(interval.slice());\n        curr = interval[1];\n      }\n    }, this);\n    return {\n      stops: stops,\n      outerColors: outerColors\n    };\n  }\n});\n/**\n * Key is this._mode\n * @type {Object}\n * @this {module:echarts/component/viusalMap/PiecewiseMode}\n */\n\nvar resetMethods = {\n  splitNumber: function () {\n    var thisOption = this.option;\n    var pieceList = this._pieceList;\n    var precision = Math.min(thisOption.precision, 20);\n    var dataExtent = this.getExtent();\n    var splitNumber = thisOption.splitNumber;\n    splitNumber = Math.max(parseInt(splitNumber, 10), 1);\n    thisOption.splitNumber = splitNumber;\n    var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber; // Precision auto-adaption\n\n    while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {\n      precision++;\n    }\n\n    thisOption.precision = precision;\n    splitStep = +splitStep.toFixed(precision);\n\n    if (thisOption.minOpen) {\n      pieceList.push({\n        interval: [-Infinity, dataExtent[0]],\n        close: [0, 0]\n      });\n    }\n\n    for (var index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {\n      var max = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;\n      pieceList.push({\n        interval: [curr, max],\n        close: [1, 1]\n      });\n    }\n\n    if (thisOption.maxOpen) {\n      pieceList.push({\n        interval: [dataExtent[1], Infinity],\n        close: [0, 0]\n      });\n    }\n\n    reformIntervals(pieceList);\n    zrUtil.each(pieceList, function (piece, index) {\n      piece.index = index;\n      piece.text = this.formatValueText(piece.interval);\n    }, this);\n  },\n  categories: function () {\n    var thisOption = this.option;\n    zrUtil.each(thisOption.categories, function (cate) {\n      // FIXME category模式也使用pieceList，但在visualMapping中不是使用pieceList。\n      // 是否改一致。\n      this._pieceList.push({\n        text: this.formatValueText(cate, true),\n        value: cate\n      });\n    }, this); // See \"Order Rule\".\n\n    normalizeReverse(thisOption, this._pieceList);\n  },\n  pieces: function () {\n    var thisOption = this.option;\n    var pieceList = this._pieceList;\n    zrUtil.each(thisOption.pieces, function (pieceListItem, index) {\n      if (!zrUtil.isObject(pieceListItem)) {\n        pieceListItem = {\n          value: pieceListItem\n        };\n      }\n\n      var item = {\n        text: '',\n        index: index\n      };\n\n      if (pieceListItem.label != null) {\n        item.text = pieceListItem.label;\n      }\n\n      if (pieceListItem.hasOwnProperty('value')) {\n        var value = item.value = pieceListItem.value;\n        item.interval = [value, value];\n        item.close = [1, 1];\n      } else {\n        // `min` `max` is legacy option.\n        // `lt` `gt` `lte` `gte` is recommanded.\n        var interval = item.interval = [];\n        var close = item.close = [0, 0];\n        var closeList = [1, 0, 1];\n        var infinityList = [-Infinity, Infinity];\n        var useMinMax = [];\n\n        for (var lg = 0; lg < 2; lg++) {\n          var names = [['gte', 'gt', 'min'], ['lte', 'lt', 'max']][lg];\n\n          for (var i = 0; i < 3 && interval[lg] == null; i++) {\n            interval[lg] = pieceListItem[names[i]];\n            close[lg] = closeList[i];\n            useMinMax[lg] = i === 2;\n          }\n\n          interval[lg] == null && (interval[lg] = infinityList[lg]);\n        }\n\n        useMinMax[0] && interval[1] === Infinity && (close[0] = 0);\n        useMinMax[1] && interval[0] === -Infinity && (close[1] = 0);\n\n        if (interval[0] === interval[1] && close[0] && close[1]) {\n          // Consider: [{min: 5, max: 5, visual: {...}}, {min: 0, max: 5}],\n          // we use value to lift the priority when min === max\n          item.value = interval[0];\n        }\n      }\n\n      item.visual = VisualMapping.retrieveVisuals(pieceListItem);\n      pieceList.push(item);\n    }, this); // See \"Order Rule\".\n\n    normalizeReverse(thisOption, pieceList); // Only pieces\n\n    reformIntervals(pieceList);\n    zrUtil.each(pieceList, function (piece) {\n      var close = piece.close;\n      var edgeSymbols = [['<', '≤'][close[1]], ['>', '≥'][close[0]]];\n      piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);\n    }, this);\n  }\n};\n\nfunction normalizeReverse(thisOption, pieceList) {\n  var inverse = thisOption.inverse;\n\n  if (thisOption.orient === 'vertical' ? !inverse : inverse) {\n    pieceList.reverse();\n  }\n}\n\nvar _default = PiecewiseModel;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}