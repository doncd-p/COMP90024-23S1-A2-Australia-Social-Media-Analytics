{"ast":null,"code":"require(\"core-js/modules/es.array.reverse.js\");\nrequire(\"core-js/modules/es.array.slice.js\");\nrequire(\"core-js/modules/es.array.last-index-of.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.join.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar echarts = require(\"../../echarts\");\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar graphic = require(\"../../util/graphic\");\nvar _symbol = require(\"../../util/symbol\");\nvar createSymbol = _symbol.createSymbol;\nvar _number = require(\"../../util/number\");\nvar parsePercent = _number.parsePercent;\nvar isNumeric = _number.isNumeric;\nvar _helper = require(\"./helper\");\nvar setLabel = _helper.setLabel;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'borderWidth']; // index: +isHorizontal\n\nvar LAYOUT_ATTRS = [{\n  xy: 'x',\n  wh: 'width',\n  index: 0,\n  posDesc: ['left', 'right']\n}, {\n  xy: 'y',\n  wh: 'height',\n  index: 1,\n  posDesc: ['top', 'bottom']\n}];\nvar pathForLineWidth = new graphic.Circle();\nvar BarView = echarts.extendChartView({\n  type: 'pictorialBar',\n  render: function render(seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var isHorizontal = !!baseAxis.isHorizontal();\n    var coordSysRect = cartesian.grid.getRect();\n    var opt = {\n      ecSize: {\n        width: api.getWidth(),\n        height: api.getHeight()\n      },\n      seriesModel: seriesModel,\n      coordSys: cartesian,\n      coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],\n      isHorizontal: isHorizontal,\n      valueDim: LAYOUT_ATTRS[+isHorizontal],\n      categoryDim: LAYOUT_ATTRS[1 - isHorizontal]\n    };\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n      var itemModel = getItemModel(data, dataIndex);\n      var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);\n      var bar = createBar(data, opt, symbolMeta);\n      data.setItemGraphicEl(dataIndex, bar);\n      group.add(bar);\n      updateCommon(bar, opt, symbolMeta);\n    }).update(function (newIndex, oldIndex) {\n      var bar = oldData.getItemGraphicEl(oldIndex);\n      if (!data.hasValue(newIndex)) {\n        group.remove(bar);\n        return;\n      }\n      var itemModel = getItemModel(data, newIndex);\n      var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);\n      var pictorialShapeStr = getShapeStr(data, symbolMeta);\n      if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {\n        group.remove(bar);\n        data.setItemGraphicEl(newIndex, null);\n        bar = null;\n      }\n      if (bar) {\n        updateBar(bar, opt, symbolMeta);\n      } else {\n        bar = createBar(data, opt, symbolMeta, true);\n      }\n      data.setItemGraphicEl(newIndex, bar);\n      bar.__pictorialSymbolMeta = symbolMeta; // Add back\n\n      group.add(bar);\n      updateCommon(bar, opt, symbolMeta);\n    }).remove(function (dataIndex) {\n      var bar = oldData.getItemGraphicEl(dataIndex);\n      bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);\n    }).execute();\n    this._data = data;\n    return this.group;\n  },\n  dispose: zrUtil.noop,\n  remove: function remove(ecModel, api) {\n    var group = this.group;\n    var data = this._data;\n    if (ecModel.get('animation')) {\n      if (data) {\n        data.eachItemGraphicEl(function (bar) {\n          removeBar(data, bar.dataIndex, ecModel, bar);\n        });\n      }\n    } else {\n      group.removeAll();\n    }\n  }\n}); // Set or calculate default value about symbol, and calculate layout info.\n\nfunction getSymbolMeta(data, dataIndex, itemModel, opt) {\n  var layout = data.getItemLayout(dataIndex);\n  var symbolRepeat = itemModel.get('symbolRepeat');\n  var symbolClip = itemModel.get('symbolClip');\n  var symbolPosition = itemModel.get('symbolPosition') || 'start';\n  var symbolRotate = itemModel.get('symbolRotate');\n  var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n  var symbolPatternSize = itemModel.get('symbolPatternSize') || 2;\n  var isAnimationEnabled = itemModel.isAnimationEnabled();\n  var symbolMeta = {\n    dataIndex: dataIndex,\n    layout: layout,\n    itemModel: itemModel,\n    symbolType: data.getItemVisual(dataIndex, 'symbol') || 'circle',\n    color: data.getItemVisual(dataIndex, 'color'),\n    symbolClip: symbolClip,\n    symbolRepeat: symbolRepeat,\n    symbolRepeatDirection: itemModel.get('symbolRepeatDirection'),\n    symbolPatternSize: symbolPatternSize,\n    rotation: rotation,\n    animationModel: isAnimationEnabled ? itemModel : null,\n    hoverAnimation: isAnimationEnabled && itemModel.get('hoverAnimation'),\n    z2: itemModel.getShallow('z', true) || 0\n  };\n  prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta);\n  prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);\n  prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);\n  var symbolSize = symbolMeta.symbolSize;\n  var symbolOffset = itemModel.get('symbolOffset');\n  if (zrUtil.isArray(symbolOffset)) {\n    symbolOffset = [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])];\n  }\n  prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);\n  return symbolMeta;\n} // bar length can be negative.\n\nfunction prepareBarLength(itemModel, symbolRepeat, layout, opt, output) {\n  var valueDim = opt.valueDim;\n  var symbolBoundingData = itemModel.get('symbolBoundingData');\n  var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());\n  var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));\n  var pxSignIdx = 1 - +(layout[valueDim.wh] <= 0);\n  var boundingLength;\n  if (zrUtil.isArray(symbolBoundingData)) {\n    var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx];\n    symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();\n    boundingLength = symbolBoundingExtent[pxSignIdx];\n  } else if (symbolBoundingData != null) {\n    boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx;\n  } else if (symbolRepeat) {\n    boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;\n  } else {\n    boundingLength = layout[valueDim.wh];\n  }\n  output.boundingLength = boundingLength;\n  if (symbolRepeat) {\n    output.repeatCutLength = layout[valueDim.wh];\n  }\n  output.pxSign = boundingLength > 0 ? 1 : boundingLength < 0 ? -1 : 0;\n}\nfunction convertToCoordOnAxis(axis, value) {\n  return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));\n} // Support ['100%', '100%']\n\nfunction prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, output) {\n  var valueDim = opt.valueDim;\n  var categoryDim = opt.categoryDim;\n  var categorySize = Math.abs(layout[categoryDim.wh]);\n  var symbolSize = data.getItemVisual(dataIndex, 'symbolSize');\n  if (zrUtil.isArray(symbolSize)) {\n    symbolSize = symbolSize.slice();\n  } else {\n    if (symbolSize == null) {\n      symbolSize = '100%';\n    }\n    symbolSize = [symbolSize, symbolSize];\n  } // Note: percentage symbolSize (like '100%') do not consider lineWidth, because it is\n  // to complicated to calculate real percent value if considering scaled lineWidth.\n  // So the actual size will bigger than layout size if lineWidth is bigger than zero,\n  // which can be tolerated in pictorial chart.\n\n  symbolSize[categoryDim.index] = parsePercent(symbolSize[categoryDim.index], categorySize);\n  symbolSize[valueDim.index] = parsePercent(symbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));\n  output.symbolSize = symbolSize; // If x or y is less than zero, show reversed shape.\n\n  var symbolScale = output.symbolScale = [symbolSize[0] / symbolPatternSize, symbolSize[1] / symbolPatternSize]; // Follow convention, 'right' and 'top' is the normal scale.\n\n  symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;\n}\nfunction prepareLineWidth(itemModel, symbolScale, rotation, opt, output) {\n  // In symbols are drawn with scale, so do not need to care about the case that width\n  // or height are too small. But symbol use strokeNoScale, where acture lineWidth should\n  // be calculated.\n  var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n  if (valueLineWidth) {\n    pathForLineWidth.attr({\n      scale: symbolScale.slice(),\n      rotation: rotation\n    });\n    pathForLineWidth.updateTransform();\n    valueLineWidth /= pathForLineWidth.getLineScale();\n    valueLineWidth *= symbolScale[opt.valueDim.index];\n  }\n  output.valueLineWidth = valueLineWidth;\n}\nfunction prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, output) {\n  var categoryDim = opt.categoryDim;\n  var valueDim = opt.valueDim;\n  var pxSign = output.pxSign;\n  var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);\n  var pathLen = unitLength; // Note: rotation will not effect the layout of symbols, because user may\n  // want symbols to rotate on its center, which should not be translated\n  // when rotating.\n\n  if (symbolRepeat) {\n    var absBoundingLength = Math.abs(boundingLength);\n    var symbolMargin = zrUtil.retrieve(itemModel.get('symbolMargin'), '15%') + '';\n    var hasEndGap = false;\n    if (symbolMargin.lastIndexOf('!') === symbolMargin.length - 1) {\n      hasEndGap = true;\n      symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);\n    }\n    symbolMargin = parsePercent(symbolMargin, symbolSize[valueDim.index]);\n    var uLenWithMargin = Math.max(unitLength + symbolMargin * 2, 0); // When symbol margin is less than 0, margin at both ends will be subtracted\n    // to ensure that all of the symbols will not be overflow the given area.\n\n    var endFix = hasEndGap ? 0 : symbolMargin * 2; // Both final repeatTimes and final symbolMargin area calculated based on\n    // boundingLength.\n\n    var repeatSpecified = isNumeric(symbolRepeat);\n    var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin); // Adjust calculate margin, to ensure each symbol is displayed\n    // entirely in the given layout area.\n\n    var mDiff = absBoundingLength - repeatTimes * unitLength;\n    symbolMargin = mDiff / 2 / (hasEndGap ? repeatTimes : repeatTimes - 1);\n    uLenWithMargin = unitLength + symbolMargin * 2;\n    endFix = hasEndGap ? 0 : symbolMargin * 2; // Update repeatTimes when not all symbol will be shown.\n\n    if (!repeatSpecified && symbolRepeat !== 'fixed') {\n      repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;\n    }\n    pathLen = repeatTimes * uLenWithMargin - endFix;\n    output.repeatTimes = repeatTimes;\n    output.symbolMargin = symbolMargin;\n  }\n  var sizeFix = pxSign * (pathLen / 2);\n  var pathPosition = output.pathPosition = [];\n  pathPosition[categoryDim.index] = layout[categoryDim.wh] / 2;\n  pathPosition[valueDim.index] = symbolPosition === 'start' ? sizeFix : symbolPosition === 'end' ? boundingLength - sizeFix : boundingLength / 2; // 'center'\n\n  if (symbolOffset) {\n    pathPosition[0] += symbolOffset[0];\n    pathPosition[1] += symbolOffset[1];\n  }\n  var bundlePosition = output.bundlePosition = [];\n  bundlePosition[categoryDim.index] = layout[categoryDim.xy];\n  bundlePosition[valueDim.index] = layout[valueDim.xy];\n  var barRectShape = output.barRectShape = zrUtil.extend({}, layout);\n  barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));\n  barRectShape[categoryDim.wh] = layout[categoryDim.wh];\n  var clipShape = output.clipShape = {}; // Consider that symbol may be overflow layout rect.\n\n  clipShape[categoryDim.xy] = -layout[categoryDim.xy];\n  clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];\n  clipShape[valueDim.xy] = 0;\n  clipShape[valueDim.wh] = layout[valueDim.wh];\n}\nfunction createPath(symbolMeta) {\n  var symbolPatternSize = symbolMeta.symbolPatternSize;\n  var path = createSymbol(\n  // Consider texture img, make a big size.\n  symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize, symbolMeta.color);\n  path.attr({\n    culling: true\n  });\n  path.type !== 'image' && path.setStyle({\n    strokeNoScale: true\n  });\n  return path;\n}\nfunction createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {\n  var bundle = bar.__pictorialBundle;\n  var symbolSize = symbolMeta.symbolSize;\n  var valueLineWidth = symbolMeta.valueLineWidth;\n  var pathPosition = symbolMeta.pathPosition;\n  var valueDim = opt.valueDim;\n  var repeatTimes = symbolMeta.repeatTimes || 0;\n  var index = 0;\n  var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;\n  eachPath(bar, function (path) {\n    path.__pictorialAnimationIndex = index;\n    path.__pictorialRepeatTimes = repeatTimes;\n    if (index < repeatTimes) {\n      updateAttr(path, null, makeTarget(index), symbolMeta, isUpdate);\n    } else {\n      updateAttr(path, null, {\n        scale: [0, 0]\n      }, symbolMeta, isUpdate, function () {\n        bundle.remove(path);\n      });\n    }\n    updateHoverAnimation(path, symbolMeta);\n    index++;\n  });\n  for (; index < repeatTimes; index++) {\n    var path = createPath(symbolMeta);\n    path.__pictorialAnimationIndex = index;\n    path.__pictorialRepeatTimes = repeatTimes;\n    bundle.add(path);\n    var target = makeTarget(index);\n    updateAttr(path, {\n      position: target.position,\n      scale: [0, 0]\n    }, {\n      scale: target.scale,\n      rotation: target.rotation\n    }, symbolMeta, isUpdate); // FIXME\n    // If all emphasis/normal through action.\n\n    path.on('mouseover', onMouseOver).on('mouseout', onMouseOut);\n    updateHoverAnimation(path, symbolMeta);\n  }\n  function makeTarget(index) {\n    var position = pathPosition.slice(); // (start && pxSign > 0) || (end && pxSign < 0): i = repeatTimes - index\n    // Otherwise: i = index;\n\n    var pxSign = symbolMeta.pxSign;\n    var i = index;\n    if (symbolMeta.symbolRepeatDirection === 'start' ? pxSign > 0 : pxSign < 0) {\n      i = repeatTimes - 1 - index;\n    }\n    position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];\n    return {\n      position: position,\n      scale: symbolMeta.symbolScale.slice(),\n      rotation: symbolMeta.rotation\n    };\n  }\n  function onMouseOver() {\n    eachPath(bar, function (path) {\n      path.trigger('emphasis');\n    });\n  }\n  function onMouseOut() {\n    eachPath(bar, function (path) {\n      path.trigger('normal');\n    });\n  }\n}\nfunction createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {\n  var bundle = bar.__pictorialBundle;\n  var mainPath = bar.__pictorialMainPath;\n  if (!mainPath) {\n    mainPath = bar.__pictorialMainPath = createPath(symbolMeta);\n    bundle.add(mainPath);\n    updateAttr(mainPath, {\n      position: symbolMeta.pathPosition.slice(),\n      scale: [0, 0],\n      rotation: symbolMeta.rotation\n    }, {\n      scale: symbolMeta.symbolScale.slice()\n    }, symbolMeta, isUpdate);\n    mainPath.on('mouseover', onMouseOver).on('mouseout', onMouseOut);\n  } else {\n    updateAttr(mainPath, null, {\n      position: symbolMeta.pathPosition.slice(),\n      scale: symbolMeta.symbolScale.slice(),\n      rotation: symbolMeta.rotation\n    }, symbolMeta, isUpdate);\n  }\n  updateHoverAnimation(mainPath, symbolMeta);\n  function onMouseOver() {\n    this.trigger('emphasis');\n  }\n  function onMouseOut() {\n    this.trigger('normal');\n  }\n} // bar rect is used for label.\n\nfunction createOrUpdateBarRect(bar, symbolMeta, isUpdate) {\n  var rectShape = zrUtil.extend({}, symbolMeta.barRectShape);\n  var barRect = bar.__pictorialBarRect;\n  if (!barRect) {\n    barRect = bar.__pictorialBarRect = new graphic.Rect({\n      z2: 2,\n      shape: rectShape,\n      silent: true,\n      style: {\n        stroke: 'transparent',\n        fill: 'transparent',\n        lineWidth: 0\n      }\n    });\n    bar.add(barRect);\n  } else {\n    updateAttr(barRect, null, {\n      shape: rectShape\n    }, symbolMeta, isUpdate);\n  }\n}\nfunction createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {\n  // If not clip, symbol will be remove and rebuilt.\n  if (symbolMeta.symbolClip) {\n    var clipPath = bar.__pictorialClipPath;\n    var clipShape = zrUtil.extend({}, symbolMeta.clipShape);\n    var valueDim = opt.valueDim;\n    var animationModel = symbolMeta.animationModel;\n    var dataIndex = symbolMeta.dataIndex;\n    if (clipPath) {\n      graphic.updateProps(clipPath, {\n        shape: clipShape\n      }, animationModel, dataIndex);\n    } else {\n      clipShape[valueDim.wh] = 0;\n      clipPath = new graphic.Rect({\n        shape: clipShape\n      });\n      bar.__pictorialBundle.setClipPath(clipPath);\n      bar.__pictorialClipPath = clipPath;\n      var target = {};\n      target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](clipPath, {\n        shape: target\n      }, animationModel, dataIndex);\n    }\n  }\n}\nfunction getItemModel(data, dataIndex) {\n  var itemModel = data.getItemModel(dataIndex);\n  itemModel.getAnimationDelayParams = getAnimationDelayParams;\n  itemModel.isAnimationEnabled = isAnimationEnabled;\n  return itemModel;\n}\nfunction getAnimationDelayParams(path) {\n  // The order is the same as the z-order, see `symbolRepeatDiretion`.\n  return {\n    index: path.__pictorialAnimationIndex,\n    count: path.__pictorialRepeatTimes\n  };\n}\nfunction isAnimationEnabled() {\n  // `animation` prop can be set on itemModel in pictorial bar chart.\n  return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation');\n}\nfunction updateHoverAnimation(path, symbolMeta) {\n  path.off('emphasis').off('normal');\n  var scale = symbolMeta.symbolScale.slice();\n  symbolMeta.hoverAnimation && path.on('emphasis', function () {\n    this.animateTo({\n      scale: [scale[0] * 1.1, scale[1] * 1.1]\n    }, 400, 'elasticOut');\n  }).on('normal', function () {\n    this.animateTo({\n      scale: scale.slice()\n    }, 400, 'elasticOut');\n  });\n}\nfunction createBar(data, opt, symbolMeta, isUpdate) {\n  // bar is the main element for each data.\n  var bar = new graphic.Group(); // bundle is used for location and clip.\n\n  var bundle = new graphic.Group();\n  bar.add(bundle);\n  bar.__pictorialBundle = bundle;\n  bundle.attr('position', symbolMeta.bundlePosition.slice());\n  if (symbolMeta.symbolRepeat) {\n    createOrUpdateRepeatSymbols(bar, opt, symbolMeta);\n  } else {\n    createOrUpdateSingleSymbol(bar, opt, symbolMeta);\n  }\n  createOrUpdateBarRect(bar, symbolMeta, isUpdate);\n  createOrUpdateClip(bar, opt, symbolMeta, isUpdate);\n  bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);\n  bar.__pictorialSymbolMeta = symbolMeta;\n  return bar;\n}\nfunction updateBar(bar, opt, symbolMeta) {\n  var animationModel = symbolMeta.animationModel;\n  var dataIndex = symbolMeta.dataIndex;\n  var bundle = bar.__pictorialBundle;\n  graphic.updateProps(bundle, {\n    position: symbolMeta.bundlePosition.slice()\n  }, animationModel, dataIndex);\n  if (symbolMeta.symbolRepeat) {\n    createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);\n  } else {\n    createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);\n  }\n  createOrUpdateBarRect(bar, symbolMeta, true);\n  createOrUpdateClip(bar, opt, symbolMeta, true);\n}\nfunction removeBar(data, dataIndex, animationModel, bar) {\n  // Not show text when animating\n  var labelRect = bar.__pictorialBarRect;\n  labelRect && (labelRect.style.text = null);\n  var pathes = [];\n  eachPath(bar, function (path) {\n    pathes.push(path);\n  });\n  bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath); // I do not find proper remove animation for clip yet.\n\n  bar.__pictorialClipPath && (animationModel = null);\n  zrUtil.each(pathes, function (path) {\n    graphic.updateProps(path, {\n      scale: [0, 0]\n    }, animationModel, dataIndex, function () {\n      bar.parent && bar.parent.remove(bar);\n    });\n  });\n  data.setItemGraphicEl(dataIndex, null);\n}\nfunction getShapeStr(data, symbolMeta) {\n  return [data.getItemVisual(symbolMeta.dataIndex, 'symbol') || 'none', !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(':');\n}\nfunction eachPath(bar, cb, context) {\n  // Do not use Group#eachChild, because it do not support remove.\n  zrUtil.each(bar.__pictorialBundle.children(), function (el) {\n    el !== bar.__pictorialBarRect && cb.call(context, el);\n  });\n}\nfunction updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {\n  immediateAttrs && el.attr(immediateAttrs); // when symbolCip used, only clip path has init animation, otherwise it would be weird effect.\n\n  if (symbolMeta.symbolClip && !isUpdate) {\n    animationAttrs && el.attr(animationAttrs);\n  } else {\n    animationAttrs && graphic[isUpdate ? 'updateProps' : 'initProps'](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);\n  }\n}\nfunction updateCommon(bar, opt, symbolMeta) {\n  var color = symbolMeta.color;\n  var dataIndex = symbolMeta.dataIndex;\n  var itemModel = symbolMeta.itemModel; // Color must be excluded.\n  // Because symbol provide setColor individually to set fill and stroke\n\n  var normalStyle = itemModel.getModel('itemStyle').getItemStyle(['color']);\n  var hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  eachPath(bar, function (path) {\n    // PENDING setColor should be before setStyle!!!\n    path.setColor(color);\n    path.setStyle(zrUtil.defaults({\n      fill: color,\n      opacity: symbolMeta.opacity\n    }, normalStyle));\n    graphic.setHoverStyle(path, hoverStyle);\n    cursorStyle && (path.cursor = cursorStyle);\n    path.z2 = symbolMeta.z2;\n  });\n  var barRectHoverStyle = {};\n  var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];\n  var barRect = bar.__pictorialBarRect;\n  setLabel(barRect.style, barRectHoverStyle, itemModel, color, opt.seriesModel, dataIndex, barPositionOutside);\n  graphic.setHoverStyle(barRect, barRectHoverStyle);\n}\nfunction toIntTimes(times) {\n  var roundedTimes = Math.round(times); // Escapse accurate error\n\n  return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);\n}\nvar _default = BarView;\nmodule.exports = _default;","map":{"version":3,"names":["echarts","require","zrUtil","graphic","_symbol","createSymbol","_number","parsePercent","isNumeric","_helper","setLabel","BAR_BORDER_WIDTH_QUERY","LAYOUT_ATTRS","xy","wh","index","posDesc","pathForLineWidth","Circle","BarView","extendChartView","type","render","seriesModel","ecModel","api","group","data","getData","oldData","_data","cartesian","coordinateSystem","baseAxis","getBaseAxis","isHorizontal","coordSysRect","grid","getRect","opt","ecSize","width","getWidth","height","getHeight","coordSys","coordSysExtent","x","y","valueDim","categoryDim","diff","add","dataIndex","hasValue","itemModel","getItemModel","symbolMeta","getSymbolMeta","bar","createBar","setItemGraphicEl","updateCommon","update","newIndex","oldIndex","getItemGraphicEl","remove","pictorialShapeStr","getShapeStr","__pictorialShapeStr","updateBar","__pictorialSymbolMeta","removeBar","animationModel","execute","dispose","noop","get","eachItemGraphicEl","removeAll","layout","getItemLayout","symbolRepeat","symbolClip","symbolPosition","symbolRotate","rotation","Math","PI","symbolPatternSize","isAnimationEnabled","symbolType","getItemVisual","color","symbolRepeatDirection","hoverAnimation","z2","getShallow","prepareBarLength","prepareSymbolSize","boundingLength","pxSign","prepareLineWidth","symbolScale","symbolSize","symbolOffset","isArray","prepareLayoutInfo","valueLineWidth","repeatCutLength","output","symbolBoundingData","valueAxis","getOtherAxis","zeroPx","toGlobalCoord","dataToCoord","pxSignIdx","symbolBoundingExtent","convertToCoordOnAxis","reverse","axis","value","scale","parse","categorySize","abs","slice","attr","updateTransform","getLineScale","unitLength","max","pathLen","absBoundingLength","symbolMargin","retrieve","hasEndGap","lastIndexOf","length","uLenWithMargin","endFix","repeatSpecified","repeatTimes","toIntTimes","mDiff","sizeFix","pathPosition","bundlePosition","barRectShape","extend","clipShape","createPath","path","culling","setStyle","strokeNoScale","createOrUpdateRepeatSymbols","isUpdate","bundle","__pictorialBundle","unit","eachPath","__pictorialAnimationIndex","__pictorialRepeatTimes","updateAttr","makeTarget","updateHoverAnimation","target","position","on","onMouseOver","onMouseOut","i","trigger","createOrUpdateSingleSymbol","mainPath","__pictorialMainPath","createOrUpdateBarRect","rectShape","barRect","__pictorialBarRect","Rect","shape","silent","style","stroke","fill","lineWidth","createOrUpdateClip","clipPath","__pictorialClipPath","updateProps","setClipPath","getAnimationDelayParams","count","parentModel","off","animateTo","Group","labelRect","text","pathes","push","each","parent","join","cb","context","children","el","call","immediateAttrs","animationAttrs","normalStyle","getModel","getItemStyle","hoverStyle","cursorStyle","setColor","defaults","opacity","setHoverStyle","cursor","barRectHoverStyle","barPositionOutside","times","roundedTimes","round","ceil","_default","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc/COMP90024-23S1-A2-Australia-Social-Media-Analytics/src/frontend/node_modules/echarts/lib/chart/bar/PictorialBarView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar isNumeric = _number.isNumeric;\n\nvar _helper = require(\"./helper\");\n\nvar setLabel = _helper.setLabel;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'borderWidth']; // index: +isHorizontal\n\nvar LAYOUT_ATTRS = [{\n  xy: 'x',\n  wh: 'width',\n  index: 0,\n  posDesc: ['left', 'right']\n}, {\n  xy: 'y',\n  wh: 'height',\n  index: 1,\n  posDesc: ['top', 'bottom']\n}];\nvar pathForLineWidth = new graphic.Circle();\nvar BarView = echarts.extendChartView({\n  type: 'pictorialBar',\n  render: function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var isHorizontal = !!baseAxis.isHorizontal();\n    var coordSysRect = cartesian.grid.getRect();\n    var opt = {\n      ecSize: {\n        width: api.getWidth(),\n        height: api.getHeight()\n      },\n      seriesModel: seriesModel,\n      coordSys: cartesian,\n      coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],\n      isHorizontal: isHorizontal,\n      valueDim: LAYOUT_ATTRS[+isHorizontal],\n      categoryDim: LAYOUT_ATTRS[1 - isHorizontal]\n    };\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var itemModel = getItemModel(data, dataIndex);\n      var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);\n      var bar = createBar(data, opt, symbolMeta);\n      data.setItemGraphicEl(dataIndex, bar);\n      group.add(bar);\n      updateCommon(bar, opt, symbolMeta);\n    }).update(function (newIndex, oldIndex) {\n      var bar = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(bar);\n        return;\n      }\n\n      var itemModel = getItemModel(data, newIndex);\n      var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);\n      var pictorialShapeStr = getShapeStr(data, symbolMeta);\n\n      if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {\n        group.remove(bar);\n        data.setItemGraphicEl(newIndex, null);\n        bar = null;\n      }\n\n      if (bar) {\n        updateBar(bar, opt, symbolMeta);\n      } else {\n        bar = createBar(data, opt, symbolMeta, true);\n      }\n\n      data.setItemGraphicEl(newIndex, bar);\n      bar.__pictorialSymbolMeta = symbolMeta; // Add back\n\n      group.add(bar);\n      updateCommon(bar, opt, symbolMeta);\n    }).remove(function (dataIndex) {\n      var bar = oldData.getItemGraphicEl(dataIndex);\n      bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);\n    }).execute();\n    this._data = data;\n    return this.group;\n  },\n  dispose: zrUtil.noop,\n  remove: function (ecModel, api) {\n    var group = this.group;\n    var data = this._data;\n\n    if (ecModel.get('animation')) {\n      if (data) {\n        data.eachItemGraphicEl(function (bar) {\n          removeBar(data, bar.dataIndex, ecModel, bar);\n        });\n      }\n    } else {\n      group.removeAll();\n    }\n  }\n}); // Set or calculate default value about symbol, and calculate layout info.\n\nfunction getSymbolMeta(data, dataIndex, itemModel, opt) {\n  var layout = data.getItemLayout(dataIndex);\n  var symbolRepeat = itemModel.get('symbolRepeat');\n  var symbolClip = itemModel.get('symbolClip');\n  var symbolPosition = itemModel.get('symbolPosition') || 'start';\n  var symbolRotate = itemModel.get('symbolRotate');\n  var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n  var symbolPatternSize = itemModel.get('symbolPatternSize') || 2;\n  var isAnimationEnabled = itemModel.isAnimationEnabled();\n  var symbolMeta = {\n    dataIndex: dataIndex,\n    layout: layout,\n    itemModel: itemModel,\n    symbolType: data.getItemVisual(dataIndex, 'symbol') || 'circle',\n    color: data.getItemVisual(dataIndex, 'color'),\n    symbolClip: symbolClip,\n    symbolRepeat: symbolRepeat,\n    symbolRepeatDirection: itemModel.get('symbolRepeatDirection'),\n    symbolPatternSize: symbolPatternSize,\n    rotation: rotation,\n    animationModel: isAnimationEnabled ? itemModel : null,\n    hoverAnimation: isAnimationEnabled && itemModel.get('hoverAnimation'),\n    z2: itemModel.getShallow('z', true) || 0\n  };\n  prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta);\n  prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);\n  prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);\n  var symbolSize = symbolMeta.symbolSize;\n  var symbolOffset = itemModel.get('symbolOffset');\n\n  if (zrUtil.isArray(symbolOffset)) {\n    symbolOffset = [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])];\n  }\n\n  prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);\n  return symbolMeta;\n} // bar length can be negative.\n\n\nfunction prepareBarLength(itemModel, symbolRepeat, layout, opt, output) {\n  var valueDim = opt.valueDim;\n  var symbolBoundingData = itemModel.get('symbolBoundingData');\n  var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());\n  var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));\n  var pxSignIdx = 1 - +(layout[valueDim.wh] <= 0);\n  var boundingLength;\n\n  if (zrUtil.isArray(symbolBoundingData)) {\n    var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx];\n    symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();\n    boundingLength = symbolBoundingExtent[pxSignIdx];\n  } else if (symbolBoundingData != null) {\n    boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx;\n  } else if (symbolRepeat) {\n    boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;\n  } else {\n    boundingLength = layout[valueDim.wh];\n  }\n\n  output.boundingLength = boundingLength;\n\n  if (symbolRepeat) {\n    output.repeatCutLength = layout[valueDim.wh];\n  }\n\n  output.pxSign = boundingLength > 0 ? 1 : boundingLength < 0 ? -1 : 0;\n}\n\nfunction convertToCoordOnAxis(axis, value) {\n  return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));\n} // Support ['100%', '100%']\n\n\nfunction prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, output) {\n  var valueDim = opt.valueDim;\n  var categoryDim = opt.categoryDim;\n  var categorySize = Math.abs(layout[categoryDim.wh]);\n  var symbolSize = data.getItemVisual(dataIndex, 'symbolSize');\n\n  if (zrUtil.isArray(symbolSize)) {\n    symbolSize = symbolSize.slice();\n  } else {\n    if (symbolSize == null) {\n      symbolSize = '100%';\n    }\n\n    symbolSize = [symbolSize, symbolSize];\n  } // Note: percentage symbolSize (like '100%') do not consider lineWidth, because it is\n  // to complicated to calculate real percent value if considering scaled lineWidth.\n  // So the actual size will bigger than layout size if lineWidth is bigger than zero,\n  // which can be tolerated in pictorial chart.\n\n\n  symbolSize[categoryDim.index] = parsePercent(symbolSize[categoryDim.index], categorySize);\n  symbolSize[valueDim.index] = parsePercent(symbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));\n  output.symbolSize = symbolSize; // If x or y is less than zero, show reversed shape.\n\n  var symbolScale = output.symbolScale = [symbolSize[0] / symbolPatternSize, symbolSize[1] / symbolPatternSize]; // Follow convention, 'right' and 'top' is the normal scale.\n\n  symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;\n}\n\nfunction prepareLineWidth(itemModel, symbolScale, rotation, opt, output) {\n  // In symbols are drawn with scale, so do not need to care about the case that width\n  // or height are too small. But symbol use strokeNoScale, where acture lineWidth should\n  // be calculated.\n  var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n\n  if (valueLineWidth) {\n    pathForLineWidth.attr({\n      scale: symbolScale.slice(),\n      rotation: rotation\n    });\n    pathForLineWidth.updateTransform();\n    valueLineWidth /= pathForLineWidth.getLineScale();\n    valueLineWidth *= symbolScale[opt.valueDim.index];\n  }\n\n  output.valueLineWidth = valueLineWidth;\n}\n\nfunction prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, output) {\n  var categoryDim = opt.categoryDim;\n  var valueDim = opt.valueDim;\n  var pxSign = output.pxSign;\n  var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);\n  var pathLen = unitLength; // Note: rotation will not effect the layout of symbols, because user may\n  // want symbols to rotate on its center, which should not be translated\n  // when rotating.\n\n  if (symbolRepeat) {\n    var absBoundingLength = Math.abs(boundingLength);\n    var symbolMargin = zrUtil.retrieve(itemModel.get('symbolMargin'), '15%') + '';\n    var hasEndGap = false;\n\n    if (symbolMargin.lastIndexOf('!') === symbolMargin.length - 1) {\n      hasEndGap = true;\n      symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);\n    }\n\n    symbolMargin = parsePercent(symbolMargin, symbolSize[valueDim.index]);\n    var uLenWithMargin = Math.max(unitLength + symbolMargin * 2, 0); // When symbol margin is less than 0, margin at both ends will be subtracted\n    // to ensure that all of the symbols will not be overflow the given area.\n\n    var endFix = hasEndGap ? 0 : symbolMargin * 2; // Both final repeatTimes and final symbolMargin area calculated based on\n    // boundingLength.\n\n    var repeatSpecified = isNumeric(symbolRepeat);\n    var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin); // Adjust calculate margin, to ensure each symbol is displayed\n    // entirely in the given layout area.\n\n    var mDiff = absBoundingLength - repeatTimes * unitLength;\n    symbolMargin = mDiff / 2 / (hasEndGap ? repeatTimes : repeatTimes - 1);\n    uLenWithMargin = unitLength + symbolMargin * 2;\n    endFix = hasEndGap ? 0 : symbolMargin * 2; // Update repeatTimes when not all symbol will be shown.\n\n    if (!repeatSpecified && symbolRepeat !== 'fixed') {\n      repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;\n    }\n\n    pathLen = repeatTimes * uLenWithMargin - endFix;\n    output.repeatTimes = repeatTimes;\n    output.symbolMargin = symbolMargin;\n  }\n\n  var sizeFix = pxSign * (pathLen / 2);\n  var pathPosition = output.pathPosition = [];\n  pathPosition[categoryDim.index] = layout[categoryDim.wh] / 2;\n  pathPosition[valueDim.index] = symbolPosition === 'start' ? sizeFix : symbolPosition === 'end' ? boundingLength - sizeFix : boundingLength / 2; // 'center'\n\n  if (symbolOffset) {\n    pathPosition[0] += symbolOffset[0];\n    pathPosition[1] += symbolOffset[1];\n  }\n\n  var bundlePosition = output.bundlePosition = [];\n  bundlePosition[categoryDim.index] = layout[categoryDim.xy];\n  bundlePosition[valueDim.index] = layout[valueDim.xy];\n  var barRectShape = output.barRectShape = zrUtil.extend({}, layout);\n  barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));\n  barRectShape[categoryDim.wh] = layout[categoryDim.wh];\n  var clipShape = output.clipShape = {}; // Consider that symbol may be overflow layout rect.\n\n  clipShape[categoryDim.xy] = -layout[categoryDim.xy];\n  clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];\n  clipShape[valueDim.xy] = 0;\n  clipShape[valueDim.wh] = layout[valueDim.wh];\n}\n\nfunction createPath(symbolMeta) {\n  var symbolPatternSize = symbolMeta.symbolPatternSize;\n  var path = createSymbol( // Consider texture img, make a big size.\n  symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize, symbolMeta.color);\n  path.attr({\n    culling: true\n  });\n  path.type !== 'image' && path.setStyle({\n    strokeNoScale: true\n  });\n  return path;\n}\n\nfunction createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {\n  var bundle = bar.__pictorialBundle;\n  var symbolSize = symbolMeta.symbolSize;\n  var valueLineWidth = symbolMeta.valueLineWidth;\n  var pathPosition = symbolMeta.pathPosition;\n  var valueDim = opt.valueDim;\n  var repeatTimes = symbolMeta.repeatTimes || 0;\n  var index = 0;\n  var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;\n  eachPath(bar, function (path) {\n    path.__pictorialAnimationIndex = index;\n    path.__pictorialRepeatTimes = repeatTimes;\n\n    if (index < repeatTimes) {\n      updateAttr(path, null, makeTarget(index), symbolMeta, isUpdate);\n    } else {\n      updateAttr(path, null, {\n        scale: [0, 0]\n      }, symbolMeta, isUpdate, function () {\n        bundle.remove(path);\n      });\n    }\n\n    updateHoverAnimation(path, symbolMeta);\n    index++;\n  });\n\n  for (; index < repeatTimes; index++) {\n    var path = createPath(symbolMeta);\n    path.__pictorialAnimationIndex = index;\n    path.__pictorialRepeatTimes = repeatTimes;\n    bundle.add(path);\n    var target = makeTarget(index);\n    updateAttr(path, {\n      position: target.position,\n      scale: [0, 0]\n    }, {\n      scale: target.scale,\n      rotation: target.rotation\n    }, symbolMeta, isUpdate); // FIXME\n    // If all emphasis/normal through action.\n\n    path.on('mouseover', onMouseOver).on('mouseout', onMouseOut);\n    updateHoverAnimation(path, symbolMeta);\n  }\n\n  function makeTarget(index) {\n    var position = pathPosition.slice(); // (start && pxSign > 0) || (end && pxSign < 0): i = repeatTimes - index\n    // Otherwise: i = index;\n\n    var pxSign = symbolMeta.pxSign;\n    var i = index;\n\n    if (symbolMeta.symbolRepeatDirection === 'start' ? pxSign > 0 : pxSign < 0) {\n      i = repeatTimes - 1 - index;\n    }\n\n    position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];\n    return {\n      position: position,\n      scale: symbolMeta.symbolScale.slice(),\n      rotation: symbolMeta.rotation\n    };\n  }\n\n  function onMouseOver() {\n    eachPath(bar, function (path) {\n      path.trigger('emphasis');\n    });\n  }\n\n  function onMouseOut() {\n    eachPath(bar, function (path) {\n      path.trigger('normal');\n    });\n  }\n}\n\nfunction createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {\n  var bundle = bar.__pictorialBundle;\n  var mainPath = bar.__pictorialMainPath;\n\n  if (!mainPath) {\n    mainPath = bar.__pictorialMainPath = createPath(symbolMeta);\n    bundle.add(mainPath);\n    updateAttr(mainPath, {\n      position: symbolMeta.pathPosition.slice(),\n      scale: [0, 0],\n      rotation: symbolMeta.rotation\n    }, {\n      scale: symbolMeta.symbolScale.slice()\n    }, symbolMeta, isUpdate);\n    mainPath.on('mouseover', onMouseOver).on('mouseout', onMouseOut);\n  } else {\n    updateAttr(mainPath, null, {\n      position: symbolMeta.pathPosition.slice(),\n      scale: symbolMeta.symbolScale.slice(),\n      rotation: symbolMeta.rotation\n    }, symbolMeta, isUpdate);\n  }\n\n  updateHoverAnimation(mainPath, symbolMeta);\n\n  function onMouseOver() {\n    this.trigger('emphasis');\n  }\n\n  function onMouseOut() {\n    this.trigger('normal');\n  }\n} // bar rect is used for label.\n\n\nfunction createOrUpdateBarRect(bar, symbolMeta, isUpdate) {\n  var rectShape = zrUtil.extend({}, symbolMeta.barRectShape);\n  var barRect = bar.__pictorialBarRect;\n\n  if (!barRect) {\n    barRect = bar.__pictorialBarRect = new graphic.Rect({\n      z2: 2,\n      shape: rectShape,\n      silent: true,\n      style: {\n        stroke: 'transparent',\n        fill: 'transparent',\n        lineWidth: 0\n      }\n    });\n    bar.add(barRect);\n  } else {\n    updateAttr(barRect, null, {\n      shape: rectShape\n    }, symbolMeta, isUpdate);\n  }\n}\n\nfunction createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {\n  // If not clip, symbol will be remove and rebuilt.\n  if (symbolMeta.symbolClip) {\n    var clipPath = bar.__pictorialClipPath;\n    var clipShape = zrUtil.extend({}, symbolMeta.clipShape);\n    var valueDim = opt.valueDim;\n    var animationModel = symbolMeta.animationModel;\n    var dataIndex = symbolMeta.dataIndex;\n\n    if (clipPath) {\n      graphic.updateProps(clipPath, {\n        shape: clipShape\n      }, animationModel, dataIndex);\n    } else {\n      clipShape[valueDim.wh] = 0;\n      clipPath = new graphic.Rect({\n        shape: clipShape\n      });\n\n      bar.__pictorialBundle.setClipPath(clipPath);\n\n      bar.__pictorialClipPath = clipPath;\n      var target = {};\n      target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](clipPath, {\n        shape: target\n      }, animationModel, dataIndex);\n    }\n  }\n}\n\nfunction getItemModel(data, dataIndex) {\n  var itemModel = data.getItemModel(dataIndex);\n  itemModel.getAnimationDelayParams = getAnimationDelayParams;\n  itemModel.isAnimationEnabled = isAnimationEnabled;\n  return itemModel;\n}\n\nfunction getAnimationDelayParams(path) {\n  // The order is the same as the z-order, see `symbolRepeatDiretion`.\n  return {\n    index: path.__pictorialAnimationIndex,\n    count: path.__pictorialRepeatTimes\n  };\n}\n\nfunction isAnimationEnabled() {\n  // `animation` prop can be set on itemModel in pictorial bar chart.\n  return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation');\n}\n\nfunction updateHoverAnimation(path, symbolMeta) {\n  path.off('emphasis').off('normal');\n  var scale = symbolMeta.symbolScale.slice();\n  symbolMeta.hoverAnimation && path.on('emphasis', function () {\n    this.animateTo({\n      scale: [scale[0] * 1.1, scale[1] * 1.1]\n    }, 400, 'elasticOut');\n  }).on('normal', function () {\n    this.animateTo({\n      scale: scale.slice()\n    }, 400, 'elasticOut');\n  });\n}\n\nfunction createBar(data, opt, symbolMeta, isUpdate) {\n  // bar is the main element for each data.\n  var bar = new graphic.Group(); // bundle is used for location and clip.\n\n  var bundle = new graphic.Group();\n  bar.add(bundle);\n  bar.__pictorialBundle = bundle;\n  bundle.attr('position', symbolMeta.bundlePosition.slice());\n\n  if (symbolMeta.symbolRepeat) {\n    createOrUpdateRepeatSymbols(bar, opt, symbolMeta);\n  } else {\n    createOrUpdateSingleSymbol(bar, opt, symbolMeta);\n  }\n\n  createOrUpdateBarRect(bar, symbolMeta, isUpdate);\n  createOrUpdateClip(bar, opt, symbolMeta, isUpdate);\n  bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);\n  bar.__pictorialSymbolMeta = symbolMeta;\n  return bar;\n}\n\nfunction updateBar(bar, opt, symbolMeta) {\n  var animationModel = symbolMeta.animationModel;\n  var dataIndex = symbolMeta.dataIndex;\n  var bundle = bar.__pictorialBundle;\n  graphic.updateProps(bundle, {\n    position: symbolMeta.bundlePosition.slice()\n  }, animationModel, dataIndex);\n\n  if (symbolMeta.symbolRepeat) {\n    createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);\n  } else {\n    createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);\n  }\n\n  createOrUpdateBarRect(bar, symbolMeta, true);\n  createOrUpdateClip(bar, opt, symbolMeta, true);\n}\n\nfunction removeBar(data, dataIndex, animationModel, bar) {\n  // Not show text when animating\n  var labelRect = bar.__pictorialBarRect;\n  labelRect && (labelRect.style.text = null);\n  var pathes = [];\n  eachPath(bar, function (path) {\n    pathes.push(path);\n  });\n  bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath); // I do not find proper remove animation for clip yet.\n\n  bar.__pictorialClipPath && (animationModel = null);\n  zrUtil.each(pathes, function (path) {\n    graphic.updateProps(path, {\n      scale: [0, 0]\n    }, animationModel, dataIndex, function () {\n      bar.parent && bar.parent.remove(bar);\n    });\n  });\n  data.setItemGraphicEl(dataIndex, null);\n}\n\nfunction getShapeStr(data, symbolMeta) {\n  return [data.getItemVisual(symbolMeta.dataIndex, 'symbol') || 'none', !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(':');\n}\n\nfunction eachPath(bar, cb, context) {\n  // Do not use Group#eachChild, because it do not support remove.\n  zrUtil.each(bar.__pictorialBundle.children(), function (el) {\n    el !== bar.__pictorialBarRect && cb.call(context, el);\n  });\n}\n\nfunction updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {\n  immediateAttrs && el.attr(immediateAttrs); // when symbolCip used, only clip path has init animation, otherwise it would be weird effect.\n\n  if (symbolMeta.symbolClip && !isUpdate) {\n    animationAttrs && el.attr(animationAttrs);\n  } else {\n    animationAttrs && graphic[isUpdate ? 'updateProps' : 'initProps'](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);\n  }\n}\n\nfunction updateCommon(bar, opt, symbolMeta) {\n  var color = symbolMeta.color;\n  var dataIndex = symbolMeta.dataIndex;\n  var itemModel = symbolMeta.itemModel; // Color must be excluded.\n  // Because symbol provide setColor individually to set fill and stroke\n\n  var normalStyle = itemModel.getModel('itemStyle').getItemStyle(['color']);\n  var hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  eachPath(bar, function (path) {\n    // PENDING setColor should be before setStyle!!!\n    path.setColor(color);\n    path.setStyle(zrUtil.defaults({\n      fill: color,\n      opacity: symbolMeta.opacity\n    }, normalStyle));\n    graphic.setHoverStyle(path, hoverStyle);\n    cursorStyle && (path.cursor = cursorStyle);\n    path.z2 = symbolMeta.z2;\n  });\n  var barRectHoverStyle = {};\n  var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];\n  var barRect = bar.__pictorialBarRect;\n  setLabel(barRect.style, barRectHoverStyle, itemModel, color, opt.seriesModel, dataIndex, barPositionOutside);\n  graphic.setHoverStyle(barRect, barRectHoverStyle);\n}\n\nfunction toIntTimes(times) {\n  var roundedTimes = Math.round(times); // Escapse accurate error\n\n  return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);\n}\n\nvar _default = BarView;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}