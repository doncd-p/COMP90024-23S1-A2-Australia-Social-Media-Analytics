{"ast":null,"code":"// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\nfunction minRunLength(n) {\n  var r = 0;\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n  return n + r;\n}\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n  if (runHi === hi) {\n    return 1;\n  }\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n  return runHi - lo;\n}\nfunction reverseRun(array, lo, hi) {\n  hi--;\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n    while (left < right) {\n      mid = left + right >>> 1;\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n    var n = start - left;\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n      case 2:\n        array[left + 2] = array[left + 1];\n      case 1:\n        array[left + 1] = array[left];\n        break;\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n    }\n    array[left] = pivot;\n  }\n}\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n  lastOffset++;\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n  return offset;\n}\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n    lastOffset += hint;\n    offset += hint;\n  }\n  lastOffset++;\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n  return offset;\n}\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n      mergeAt(n);\n    }\n  }\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n      mergeAt(n);\n    }\n  }\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n    if (length1 === 0) {\n      return;\n    }\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n    if (length2 === 0) {\n      return;\n    }\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n      return;\n    }\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n    var _minGallop = minGallop;\n    var count1;\n    var count2;\n    var exit;\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n      if (exit) {\n        break;\n      }\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n        array[dest++] = array[cursor2++];\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n        array[dest++] = tmp[cursor1++];\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n      if (exit) {\n        break;\n      }\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n      _minGallop += 2;\n    }\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n      return;\n    }\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n      array[dest] = tmp[cursor2];\n      return;\n    }\n    var _minGallop = minGallop;\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n      if (exit) {\n        break;\n      }\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n        array[dest--] = tmp[cursor2--];\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n        array[dest--] = array[cursor1--];\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n      if (exit) {\n        break;\n      }\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n      _minGallop += 2;\n    }\n    minGallop = _minGallop;\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n  if (!hi) {\n    hi = array.length;\n  }\n  var remaining = hi - lo;\n  if (remaining < 2) {\n    return;\n  }\n  var runLength = 0;\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    if (runLength < minRun) {\n      var force = remaining;\n      if (force > minRun) {\n        force = minRun;\n      }\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n  ts.forceMergeRuns();\n}\nmodule.exports = sort;","map":{"version":3,"names":["DEFAULT_MIN_MERGE","DEFAULT_MIN_GALLOPING","DEFAULT_TMP_STORAGE_LENGTH","minRunLength","n","r","makeAscendingRun","array","lo","hi","compare","runHi","reverseRun","t","binaryInsertionSort","start","pivot","left","right","mid","gallopLeft","value","length","hint","lastOffset","maxOffset","offset","tmp","m","gallopRight","TimSort","minGallop","tmpStorageLength","stackLength","runStart","runLength","stackSize","pushRun","_runStart","_runLength","mergeRuns","mergeAt","forceMergeRuns","i","start1","length1","start2","length2","k","mergeLow","mergeHigh","cursor1","cursor2","dest","_minGallop","count1","count2","exit","Error","customCursor","customDest","sort","remaining","ts","minRun","force","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/zrender/lib/core/timsort.js"],"sourcesContent":["// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\nfunction minRunLength(n) {\n  var r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n\n  return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n\n  if (runHi === hi) {\n    return 1;\n  }\n\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n\n  return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n  hi--;\n\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n\n    while (left < right) {\n      mid = left + right >>> 1;\n\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    var n = start - left;\n\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n\n      case 2:\n        array[left + 2] = array[left + 1];\n\n      case 1:\n        array[left + 1] = array[left];\n        break;\n\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n\n    }\n\n    array[left] = pivot;\n  }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n\n  return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n\n  return offset;\n}\n\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n\n    if (length1 === 0) {\n      return;\n    }\n\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n    if (length2 === 0) {\n      return;\n    }\n\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n\n      return;\n    }\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n\n    var _minGallop = minGallop;\n    var count1;\n    var count2;\n    var exit;\n\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = tmp[cursor1++];\n\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n\n      return;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n      return;\n    }\n\n    var _minGallop = minGallop;\n\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = tmp[cursor2--];\n\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n\n  if (!hi) {\n    hi = array.length;\n  }\n\n  var remaining = hi - lo;\n\n  if (remaining < 2) {\n    return;\n  }\n\n  var runLength = 0;\n\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n\n    if (runLength < minRun) {\n      var force = remaining;\n\n      if (force > minRun) {\n        force = minRun;\n      }\n\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n\n  ts.forceMergeRuns();\n}\n\nmodule.exports = sort;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}