{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar Scale = require(\"./Scale\");\nvar numberUtil = require(\"../util/number\");\nvar IntervalScale = require(\"./Interval\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n// Use some method of IntervalScale\nvar scaleProto = Scale.prototype;\nvar intervalScaleProto = IntervalScale.prototype;\nvar getPrecisionSafe = numberUtil.getPrecisionSafe;\nvar roundingErrorFix = numberUtil.round;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar mathPow = Math.pow;\nvar mathLog = Math.log;\nvar LogScale = Scale.extend({\n  type: 'log',\n  base: 10,\n  $constructor: function () {\n    Scale.apply(this, arguments);\n    this._originalScale = new IntervalScale();\n  },\n  /**\n   * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.\n   * @return {Array.<number>}\n   */\n  getTicks: function (expandToNicedExtent) {\n    var originalScale = this._originalScale;\n    var extent = this._extent;\n    var originalExtent = originalScale.getExtent();\n    return zrUtil.map(intervalScaleProto.getTicks.call(this, expandToNicedExtent), function (val) {\n      var powVal = numberUtil.round(mathPow(this.base, val)); // Fix #4158\n\n      powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;\n      powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;\n      return powVal;\n    }, this);\n  },\n  /**\n   * @param {number} splitNumber\n   * @return {Array.<Array.<number>>}\n   */\n  getMinorTicks: intervalScaleProto.getMinorTicks,\n  /**\n   * @param {number} val\n   * @return {string}\n   */\n  getLabel: intervalScaleProto.getLabel,\n  /**\n   * @param  {number} val\n   * @return {number}\n   */\n  scale: function (val) {\n    val = scaleProto.scale.call(this, val);\n    return mathPow(this.base, val);\n  },\n  /**\n   * @param {number} start\n   * @param {number} end\n   */\n  setExtent: function (start, end) {\n    var base = this.base;\n    start = mathLog(start) / mathLog(base);\n    end = mathLog(end) / mathLog(base);\n    intervalScaleProto.setExtent.call(this, start, end);\n  },\n  /**\n   * @return {number} end\n   */\n  getExtent: function () {\n    var base = this.base;\n    var extent = scaleProto.getExtent.call(this);\n    extent[0] = mathPow(base, extent[0]);\n    extent[1] = mathPow(base, extent[1]); // Fix #4158\n\n    var originalScale = this._originalScale;\n    var originalExtent = originalScale.getExtent();\n    originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n    originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n    return extent;\n  },\n  /**\n   * @param  {Array.<number>} extent\n   */\n  unionExtent: function (extent) {\n    this._originalScale.unionExtent(extent);\n    var base = this.base;\n    extent[0] = mathLog(extent[0]) / mathLog(base);\n    extent[1] = mathLog(extent[1]) / mathLog(base);\n    scaleProto.unionExtent.call(this, extent);\n  },\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    // TODO\n    // filter value that <= 0\n    this.unionExtent(data.getApproximateExtent(dim));\n  },\n  /**\n   * Update interval and extent of intervals for nice ticks\n   * @param  {number} [approxTickNum = 10] Given approx tick number\n   */\n  niceTicks: function (approxTickNum) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n    if (span === Infinity || span <= 0) {\n      return;\n    }\n    var interval = numberUtil.quantity(span);\n    var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.\n\n    if (err <= 0.5) {\n      interval *= 10;\n    } // Interval should be integer\n\n    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n      interval *= 10;\n    }\n    var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];\n    this._interval = interval;\n    this._niceExtent = niceExtent;\n  },\n  /**\n   * Nice extent.\n   * @override\n   */\n  niceExtent: function (opt) {\n    intervalScaleProto.niceExtent.call(this, opt);\n    var originalScale = this._originalScale;\n    originalScale.__fixMin = opt.fixMin;\n    originalScale.__fixMax = opt.fixMax;\n  }\n});\nzrUtil.each(['contain', 'normalize'], function (methodName) {\n  LogScale.prototype[methodName] = function (val) {\n    val = mathLog(val) / mathLog(this.base);\n    return scaleProto[methodName].call(this, val);\n  };\n});\nLogScale.create = function () {\n  return new LogScale();\n};\nfunction fixRoundingError(val, originalVal) {\n  return roundingErrorFix(val, getPrecisionSafe(originalVal));\n}\nvar _default = LogScale;\nmodule.exports = _default;","map":{"version":3,"names":["zrUtil","require","Scale","numberUtil","IntervalScale","scaleProto","prototype","intervalScaleProto","getPrecisionSafe","roundingErrorFix","round","mathFloor","Math","floor","mathCeil","ceil","mathPow","pow","mathLog","log","LogScale","extend","type","base","$constructor","apply","arguments","_originalScale","getTicks","expandToNicedExtent","originalScale","extent","_extent","originalExtent","getExtent","map","call","val","powVal","__fixMin","fixRoundingError","__fixMax","getMinorTicks","getLabel","scale","setExtent","start","end","unionExtent","unionExtentFromData","data","dim","getApproximateExtent","niceTicks","approxTickNum","span","Infinity","interval","quantity","err","isNaN","abs","niceExtent","_interval","_niceExtent","opt","fixMin","fixMax","each","methodName","create","originalVal","_default","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/echarts/lib/scale/Log.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Scale = require(\"./Scale\");\n\nvar numberUtil = require(\"../util/number\");\n\nvar IntervalScale = require(\"./Interval\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n// Use some method of IntervalScale\nvar scaleProto = Scale.prototype;\nvar intervalScaleProto = IntervalScale.prototype;\nvar getPrecisionSafe = numberUtil.getPrecisionSafe;\nvar roundingErrorFix = numberUtil.round;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar mathPow = Math.pow;\nvar mathLog = Math.log;\nvar LogScale = Scale.extend({\n  type: 'log',\n  base: 10,\n  $constructor: function () {\n    Scale.apply(this, arguments);\n    this._originalScale = new IntervalScale();\n  },\n\n  /**\n   * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.\n   * @return {Array.<number>}\n   */\n  getTicks: function (expandToNicedExtent) {\n    var originalScale = this._originalScale;\n    var extent = this._extent;\n    var originalExtent = originalScale.getExtent();\n    return zrUtil.map(intervalScaleProto.getTicks.call(this, expandToNicedExtent), function (val) {\n      var powVal = numberUtil.round(mathPow(this.base, val)); // Fix #4158\n\n      powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;\n      powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;\n      return powVal;\n    }, this);\n  },\n\n  /**\n   * @param {number} splitNumber\n   * @return {Array.<Array.<number>>}\n   */\n  getMinorTicks: intervalScaleProto.getMinorTicks,\n\n  /**\n   * @param {number} val\n   * @return {string}\n   */\n  getLabel: intervalScaleProto.getLabel,\n\n  /**\n   * @param  {number} val\n   * @return {number}\n   */\n  scale: function (val) {\n    val = scaleProto.scale.call(this, val);\n    return mathPow(this.base, val);\n  },\n\n  /**\n   * @param {number} start\n   * @param {number} end\n   */\n  setExtent: function (start, end) {\n    var base = this.base;\n    start = mathLog(start) / mathLog(base);\n    end = mathLog(end) / mathLog(base);\n    intervalScaleProto.setExtent.call(this, start, end);\n  },\n\n  /**\n   * @return {number} end\n   */\n  getExtent: function () {\n    var base = this.base;\n    var extent = scaleProto.getExtent.call(this);\n    extent[0] = mathPow(base, extent[0]);\n    extent[1] = mathPow(base, extent[1]); // Fix #4158\n\n    var originalScale = this._originalScale;\n    var originalExtent = originalScale.getExtent();\n    originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n    originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n    return extent;\n  },\n\n  /**\n   * @param  {Array.<number>} extent\n   */\n  unionExtent: function (extent) {\n    this._originalScale.unionExtent(extent);\n\n    var base = this.base;\n    extent[0] = mathLog(extent[0]) / mathLog(base);\n    extent[1] = mathLog(extent[1]) / mathLog(base);\n    scaleProto.unionExtent.call(this, extent);\n  },\n\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    // TODO\n    // filter value that <= 0\n    this.unionExtent(data.getApproximateExtent(dim));\n  },\n\n  /**\n   * Update interval and extent of intervals for nice ticks\n   * @param  {number} [approxTickNum = 10] Given approx tick number\n   */\n  niceTicks: function (approxTickNum) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (span === Infinity || span <= 0) {\n      return;\n    }\n\n    var interval = numberUtil.quantity(span);\n    var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.\n\n    if (err <= 0.5) {\n      interval *= 10;\n    } // Interval should be integer\n\n\n    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n      interval *= 10;\n    }\n\n    var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];\n    this._interval = interval;\n    this._niceExtent = niceExtent;\n  },\n\n  /**\n   * Nice extent.\n   * @override\n   */\n  niceExtent: function (opt) {\n    intervalScaleProto.niceExtent.call(this, opt);\n    var originalScale = this._originalScale;\n    originalScale.__fixMin = opt.fixMin;\n    originalScale.__fixMax = opt.fixMax;\n  }\n});\nzrUtil.each(['contain', 'normalize'], function (methodName) {\n  LogScale.prototype[methodName] = function (val) {\n    val = mathLog(val) / mathLog(this.base);\n    return scaleProto[methodName].call(this, val);\n  };\n});\n\nLogScale.create = function () {\n  return new LogScale();\n};\n\nfunction fixRoundingError(val, originalVal) {\n  return roundingErrorFix(val, getPrecisionSafe(originalVal));\n}\n\nvar _default = LogScale;\nmodule.exports = _default;"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,uBAAuB,CAAC;AAE7C,IAAIC,KAAK,GAAGD,OAAO,CAAC,SAAS,CAAC;AAE9B,IAAIE,UAAU,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AAE1C,IAAIG,aAAa,GAAGH,OAAO,CAAC,YAAY,CAAC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAII,UAAU,GAAGH,KAAK,CAACI,SAAS;AAChC,IAAIC,kBAAkB,GAAGH,aAAa,CAACE,SAAS;AAChD,IAAIE,gBAAgB,GAAGL,UAAU,CAACK,gBAAgB;AAClD,IAAIC,gBAAgB,GAAGN,UAAU,CAACO,KAAK;AACvC,IAAIC,SAAS,GAAGC,IAAI,CAACC,KAAK;AAC1B,IAAIC,QAAQ,GAAGF,IAAI,CAACG,IAAI;AACxB,IAAIC,OAAO,GAAGJ,IAAI,CAACK,GAAG;AACtB,IAAIC,OAAO,GAAGN,IAAI,CAACO,GAAG;AACtB,IAAIC,QAAQ,GAAGlB,KAAK,CAACmB,MAAM,CAAC;EAC1BC,IAAI,EAAE,KAAK;EACXC,IAAI,EAAE,EAAE;EACRC,YAAY,EAAE,SAAAA,CAAA,EAAY;IACxBtB,KAAK,CAACuB,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IAC5B,IAAI,CAACC,cAAc,GAAG,IAAIvB,aAAa,EAAE;EAC3C,CAAC;EAED;AACF;AACA;AACA;EACEwB,QAAQ,EAAE,SAAAA,CAAUC,mBAAmB,EAAE;IACvC,IAAIC,aAAa,GAAG,IAAI,CAACH,cAAc;IACvC,IAAII,MAAM,GAAG,IAAI,CAACC,OAAO;IACzB,IAAIC,cAAc,GAAGH,aAAa,CAACI,SAAS,EAAE;IAC9C,OAAOlC,MAAM,CAACmC,GAAG,CAAC5B,kBAAkB,CAACqB,QAAQ,CAACQ,IAAI,CAAC,IAAI,EAAEP,mBAAmB,CAAC,EAAE,UAAUQ,GAAG,EAAE;MAC5F,IAAIC,MAAM,GAAGnC,UAAU,CAACO,KAAK,CAACM,OAAO,CAAC,IAAI,CAACO,IAAI,EAAEc,GAAG,CAAC,CAAC,CAAC,CAAC;;MAExDC,MAAM,GAAGD,GAAG,KAAKN,MAAM,CAAC,CAAC,CAAC,IAAID,aAAa,CAACS,QAAQ,GAAGC,gBAAgB,CAACF,MAAM,EAAEL,cAAc,CAAC,CAAC,CAAC,CAAC,GAAGK,MAAM;MAC3GA,MAAM,GAAGD,GAAG,KAAKN,MAAM,CAAC,CAAC,CAAC,IAAID,aAAa,CAACW,QAAQ,GAAGD,gBAAgB,CAACF,MAAM,EAAEL,cAAc,CAAC,CAAC,CAAC,CAAC,GAAGK,MAAM;MAC3G,OAAOA,MAAM;IACf,CAAC,EAAE,IAAI,CAAC;EACV,CAAC;EAED;AACF;AACA;AACA;EACEI,aAAa,EAAEnC,kBAAkB,CAACmC,aAAa;EAE/C;AACF;AACA;AACA;EACEC,QAAQ,EAAEpC,kBAAkB,CAACoC,QAAQ;EAErC;AACF;AACA;AACA;EACEC,KAAK,EAAE,SAAAA,CAAUP,GAAG,EAAE;IACpBA,GAAG,GAAGhC,UAAU,CAACuC,KAAK,CAACR,IAAI,CAAC,IAAI,EAAEC,GAAG,CAAC;IACtC,OAAOrB,OAAO,CAAC,IAAI,CAACO,IAAI,EAAEc,GAAG,CAAC;EAChC,CAAC;EAED;AACF;AACA;AACA;EACEQ,SAAS,EAAE,SAAAA,CAAUC,KAAK,EAAEC,GAAG,EAAE;IAC/B,IAAIxB,IAAI,GAAG,IAAI,CAACA,IAAI;IACpBuB,KAAK,GAAG5B,OAAO,CAAC4B,KAAK,CAAC,GAAG5B,OAAO,CAACK,IAAI,CAAC;IACtCwB,GAAG,GAAG7B,OAAO,CAAC6B,GAAG,CAAC,GAAG7B,OAAO,CAACK,IAAI,CAAC;IAClChB,kBAAkB,CAACsC,SAAS,CAACT,IAAI,CAAC,IAAI,EAAEU,KAAK,EAAEC,GAAG,CAAC;EACrD,CAAC;EAED;AACF;AACA;EACEb,SAAS,EAAE,SAAAA,CAAA,EAAY;IACrB,IAAIX,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAIQ,MAAM,GAAG1B,UAAU,CAAC6B,SAAS,CAACE,IAAI,CAAC,IAAI,CAAC;IAC5CL,MAAM,CAAC,CAAC,CAAC,GAAGf,OAAO,CAACO,IAAI,EAAEQ,MAAM,CAAC,CAAC,CAAC,CAAC;IACpCA,MAAM,CAAC,CAAC,CAAC,GAAGf,OAAO,CAACO,IAAI,EAAEQ,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;IAEtC,IAAID,aAAa,GAAG,IAAI,CAACH,cAAc;IACvC,IAAIM,cAAc,GAAGH,aAAa,CAACI,SAAS,EAAE;IAC9CJ,aAAa,CAACS,QAAQ,KAAKR,MAAM,CAAC,CAAC,CAAC,GAAGS,gBAAgB,CAACT,MAAM,CAAC,CAAC,CAAC,EAAEE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IACtFH,aAAa,CAACW,QAAQ,KAAKV,MAAM,CAAC,CAAC,CAAC,GAAGS,gBAAgB,CAACT,MAAM,CAAC,CAAC,CAAC,EAAEE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IACtF,OAAOF,MAAM;EACf,CAAC;EAED;AACF;AACA;EACEiB,WAAW,EAAE,SAAAA,CAAUjB,MAAM,EAAE;IAC7B,IAAI,CAACJ,cAAc,CAACqB,WAAW,CAACjB,MAAM,CAAC;IAEvC,IAAIR,IAAI,GAAG,IAAI,CAACA,IAAI;IACpBQ,MAAM,CAAC,CAAC,CAAC,GAAGb,OAAO,CAACa,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGb,OAAO,CAACK,IAAI,CAAC;IAC9CQ,MAAM,CAAC,CAAC,CAAC,GAAGb,OAAO,CAACa,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGb,OAAO,CAACK,IAAI,CAAC;IAC9ClB,UAAU,CAAC2C,WAAW,CAACZ,IAAI,CAAC,IAAI,EAAEL,MAAM,CAAC;EAC3C,CAAC;EAED;AACF;AACA;EACEkB,mBAAmB,EAAE,SAAAA,CAAUC,IAAI,EAAEC,GAAG,EAAE;IACxC;IACA;IACA,IAAI,CAACH,WAAW,CAACE,IAAI,CAACE,oBAAoB,CAACD,GAAG,CAAC,CAAC;EAClD,CAAC;EAED;AACF;AACA;AACA;EACEE,SAAS,EAAE,SAAAA,CAAUC,aAAa,EAAE;IAClCA,aAAa,GAAGA,aAAa,IAAI,EAAE;IACnC,IAAIvB,MAAM,GAAG,IAAI,CAACC,OAAO;IACzB,IAAIuB,IAAI,GAAGxB,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC;IAEhC,IAAIwB,IAAI,KAAKC,QAAQ,IAAID,IAAI,IAAI,CAAC,EAAE;MAClC;IACF;IAEA,IAAIE,QAAQ,GAAGtD,UAAU,CAACuD,QAAQ,CAACH,IAAI,CAAC;IACxC,IAAII,GAAG,GAAGL,aAAa,GAAGC,IAAI,GAAGE,QAAQ,CAAC,CAAC;;IAE3C,IAAIE,GAAG,IAAI,GAAG,EAAE;MACdF,QAAQ,IAAI,EAAE;IAChB,CAAC,CAAC;;IAGF,OAAO,CAACG,KAAK,CAACH,QAAQ,CAAC,IAAI7C,IAAI,CAACiD,GAAG,CAACJ,QAAQ,CAAC,GAAG,CAAC,IAAI7C,IAAI,CAACiD,GAAG,CAACJ,QAAQ,CAAC,GAAG,CAAC,EAAE;MAC3EA,QAAQ,IAAI,EAAE;IAChB;IAEA,IAAIK,UAAU,GAAG,CAAC3D,UAAU,CAACO,KAAK,CAACI,QAAQ,CAACiB,MAAM,CAAC,CAAC,CAAC,GAAG0B,QAAQ,CAAC,GAAGA,QAAQ,CAAC,EAAEtD,UAAU,CAACO,KAAK,CAACC,SAAS,CAACoB,MAAM,CAAC,CAAC,CAAC,GAAG0B,QAAQ,CAAC,GAAGA,QAAQ,CAAC,CAAC;IAC5I,IAAI,CAACM,SAAS,GAAGN,QAAQ;IACzB,IAAI,CAACO,WAAW,GAAGF,UAAU;EAC/B,CAAC;EAED;AACF;AACA;AACA;EACEA,UAAU,EAAE,SAAAA,CAAUG,GAAG,EAAE;IACzB1D,kBAAkB,CAACuD,UAAU,CAAC1B,IAAI,CAAC,IAAI,EAAE6B,GAAG,CAAC;IAC7C,IAAInC,aAAa,GAAG,IAAI,CAACH,cAAc;IACvCG,aAAa,CAACS,QAAQ,GAAG0B,GAAG,CAACC,MAAM;IACnCpC,aAAa,CAACW,QAAQ,GAAGwB,GAAG,CAACE,MAAM;EACrC;AACF,CAAC,CAAC;AACFnE,MAAM,CAACoE,IAAI,CAAC,CAAC,SAAS,EAAE,WAAW,CAAC,EAAE,UAAUC,UAAU,EAAE;EAC1DjD,QAAQ,CAACd,SAAS,CAAC+D,UAAU,CAAC,GAAG,UAAUhC,GAAG,EAAE;IAC9CA,GAAG,GAAGnB,OAAO,CAACmB,GAAG,CAAC,GAAGnB,OAAO,CAAC,IAAI,CAACK,IAAI,CAAC;IACvC,OAAOlB,UAAU,CAACgE,UAAU,CAAC,CAACjC,IAAI,CAAC,IAAI,EAAEC,GAAG,CAAC;EAC/C,CAAC;AACH,CAAC,CAAC;AAEFjB,QAAQ,CAACkD,MAAM,GAAG,YAAY;EAC5B,OAAO,IAAIlD,QAAQ,EAAE;AACvB,CAAC;AAED,SAASoB,gBAAgBA,CAACH,GAAG,EAAEkC,WAAW,EAAE;EAC1C,OAAO9D,gBAAgB,CAAC4B,GAAG,EAAE7B,gBAAgB,CAAC+D,WAAW,CAAC,CAAC;AAC7D;AAEA,IAAIC,QAAQ,GAAGpD,QAAQ;AACvBqD,MAAM,CAACC,OAAO,GAAGF,QAAQ"},"metadata":{},"sourceType":"script","externalDependencies":[]}