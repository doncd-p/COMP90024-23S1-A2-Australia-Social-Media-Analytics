{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _util = require(\"zrender/lib/core/util\");\nvar each = _util.each;\nvar isString = _util.isString;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Note that it is too complicated to support 3d stack by value\n * (have to create two-dimension inverted index), so in 3d case\n * we just support that stacked by index.\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Array.<string|Object>} dimensionInfoList The same as the input of <module:echarts/data/List>.\n *        The input dimensionInfoList will be modified.\n * @param {Object} [opt]\n * @param {boolean} [opt.stackedCoordDimension=''] Specify a coord dimension if needed.\n * @param {boolean} [opt.byIndex=false]\n * @return {Object} calculationInfo\n * {\n *     stackedDimension: string\n *     stackedByDimension: string\n *     isStackedByIndex: boolean\n *     stackedOverDimension: string\n *     stackResultDimension: string\n * }\n */\nfunction enableDataStack(seriesModel, dimensionInfoList, opt) {\n  opt = opt || {};\n  var byIndex = opt.byIndex;\n  var stackedCoordDimension = opt.stackedCoordDimension; // Compatibal: when `stack` is set as '', do not stack.\n\n  var mayStack = !!(seriesModel && seriesModel.get('stack'));\n  var stackedByDimInfo;\n  var stackedDimInfo;\n  var stackResultDimension;\n  var stackedOverDimension;\n  each(dimensionInfoList, function (dimensionInfo, index) {\n    if (isString(dimensionInfo)) {\n      dimensionInfoList[index] = dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n    if (mayStack && !dimensionInfo.isExtraCoord) {\n      // Find the first ordinal dimension as the stackedByDimInfo.\n      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {\n        stackedByDimInfo = dimensionInfo;\n      } // Find the first stackable dimension as the stackedDimInfo.\n\n      if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {\n        stackedDimInfo = dimensionInfo;\n      }\n    }\n  });\n  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {\n    // Compatible with previous design, value axis (time axis) only stack by index.\n    // It may make sense if the user provides elaborately constructed data.\n    byIndex = true;\n  } // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.\n  // That put stack logic in List is for using conveniently in echarts extensions, but it\n  // might not be a good way.\n\n  if (stackedDimInfo) {\n    // Use a weird name that not duplicated with other names.\n    stackResultDimension = '__\\0ecstackresult';\n    stackedOverDimension = '__\\0ecstackedover'; // Create inverted index to fast query index by value.\n\n    if (stackedByDimInfo) {\n      stackedByDimInfo.createInvertedIndices = true;\n    }\n    var stackedDimCoordDim = stackedDimInfo.coordDim;\n    var stackedDimType = stackedDimInfo.type;\n    var stackedDimCoordIndex = 0;\n    each(dimensionInfoList, function (dimensionInfo) {\n      if (dimensionInfo.coordDim === stackedDimCoordDim) {\n        stackedDimCoordIndex++;\n      }\n    });\n    dimensionInfoList.push({\n      name: stackResultDimension,\n      coordDim: stackedDimCoordDim,\n      coordDimIndex: stackedDimCoordIndex,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true\n    });\n    stackedDimCoordIndex++;\n    dimensionInfoList.push({\n      name: stackedOverDimension,\n      // This dimension contains stack base (generally, 0), so do not set it as\n      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.\n      coordDim: stackedOverDimension,\n      coordDimIndex: stackedDimCoordIndex,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true\n    });\n  }\n  return {\n    stackedDimension: stackedDimInfo && stackedDimInfo.name,\n    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,\n    isStackedByIndex: byIndex,\n    stackedOverDimension: stackedOverDimension,\n    stackResultDimension: stackResultDimension\n  };\n}\n/**\n * @param {module:echarts/data/List} data\n * @param {string} stackedDim\n */\n\nfunction isDimensionStacked(data, stackedDim\n/*, stackedByDim*/) {\n  // Each single series only maps to one pair of axis. So we do not need to\n  // check stackByDim, whatever stacked by a dimension or stacked by index.\n  return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension'); // && (\n  //     stackedByDim != null\n  //         ? stackedByDim === data.getCalculationInfo('stackedByDimension')\n  //         : data.getCalculationInfo('isStackedByIndex')\n  // );\n}\n/**\n * @param {module:echarts/data/List} data\n * @param {string} targetDim\n * @param {string} [stackedByDim] If not input this parameter, check whether\n *                                stacked by index.\n * @return {string} dimension\n */\n\nfunction getStackedDimension(data, targetDim) {\n  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;\n}\nexports.enableDataStack = enableDataStack;\nexports.isDimensionStacked = isDimensionStacked;\nexports.getStackedDimension = getStackedDimension;","map":{"version":3,"names":["_util","require","each","isString","enableDataStack","seriesModel","dimensionInfoList","opt","byIndex","stackedCoordDimension","mayStack","get","stackedByDimInfo","stackedDimInfo","stackResultDimension","stackedOverDimension","dimensionInfo","index","name","isExtraCoord","ordinalMeta","type","coordDim","createInvertedIndices","stackedDimCoordDim","stackedDimType","stackedDimCoordIndex","push","coordDimIndex","isCalculationCoord","stackedDimension","stackedByDimension","isStackedByIndex","isDimensionStacked","data","stackedDim","getCalculationInfo","getStackedDimension","targetDim","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/echarts/lib/data/helper/dataStackHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar isString = _util.isString;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Note that it is too complicated to support 3d stack by value\n * (have to create two-dimension inverted index), so in 3d case\n * we just support that stacked by index.\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Array.<string|Object>} dimensionInfoList The same as the input of <module:echarts/data/List>.\n *        The input dimensionInfoList will be modified.\n * @param {Object} [opt]\n * @param {boolean} [opt.stackedCoordDimension=''] Specify a coord dimension if needed.\n * @param {boolean} [opt.byIndex=false]\n * @return {Object} calculationInfo\n * {\n *     stackedDimension: string\n *     stackedByDimension: string\n *     isStackedByIndex: boolean\n *     stackedOverDimension: string\n *     stackResultDimension: string\n * }\n */\nfunction enableDataStack(seriesModel, dimensionInfoList, opt) {\n  opt = opt || {};\n  var byIndex = opt.byIndex;\n  var stackedCoordDimension = opt.stackedCoordDimension; // Compatibal: when `stack` is set as '', do not stack.\n\n  var mayStack = !!(seriesModel && seriesModel.get('stack'));\n  var stackedByDimInfo;\n  var stackedDimInfo;\n  var stackResultDimension;\n  var stackedOverDimension;\n  each(dimensionInfoList, function (dimensionInfo, index) {\n    if (isString(dimensionInfo)) {\n      dimensionInfoList[index] = dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n\n    if (mayStack && !dimensionInfo.isExtraCoord) {\n      // Find the first ordinal dimension as the stackedByDimInfo.\n      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {\n        stackedByDimInfo = dimensionInfo;\n      } // Find the first stackable dimension as the stackedDimInfo.\n\n\n      if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {\n        stackedDimInfo = dimensionInfo;\n      }\n    }\n  });\n\n  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {\n    // Compatible with previous design, value axis (time axis) only stack by index.\n    // It may make sense if the user provides elaborately constructed data.\n    byIndex = true;\n  } // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.\n  // That put stack logic in List is for using conveniently in echarts extensions, but it\n  // might not be a good way.\n\n\n  if (stackedDimInfo) {\n    // Use a weird name that not duplicated with other names.\n    stackResultDimension = '__\\0ecstackresult';\n    stackedOverDimension = '__\\0ecstackedover'; // Create inverted index to fast query index by value.\n\n    if (stackedByDimInfo) {\n      stackedByDimInfo.createInvertedIndices = true;\n    }\n\n    var stackedDimCoordDim = stackedDimInfo.coordDim;\n    var stackedDimType = stackedDimInfo.type;\n    var stackedDimCoordIndex = 0;\n    each(dimensionInfoList, function (dimensionInfo) {\n      if (dimensionInfo.coordDim === stackedDimCoordDim) {\n        stackedDimCoordIndex++;\n      }\n    });\n    dimensionInfoList.push({\n      name: stackResultDimension,\n      coordDim: stackedDimCoordDim,\n      coordDimIndex: stackedDimCoordIndex,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true\n    });\n    stackedDimCoordIndex++;\n    dimensionInfoList.push({\n      name: stackedOverDimension,\n      // This dimension contains stack base (generally, 0), so do not set it as\n      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.\n      coordDim: stackedOverDimension,\n      coordDimIndex: stackedDimCoordIndex,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true\n    });\n  }\n\n  return {\n    stackedDimension: stackedDimInfo && stackedDimInfo.name,\n    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,\n    isStackedByIndex: byIndex,\n    stackedOverDimension: stackedOverDimension,\n    stackResultDimension: stackResultDimension\n  };\n}\n/**\n * @param {module:echarts/data/List} data\n * @param {string} stackedDim\n */\n\n\nfunction isDimensionStacked(data, stackedDim\n/*, stackedByDim*/\n) {\n  // Each single series only maps to one pair of axis. So we do not need to\n  // check stackByDim, whatever stacked by a dimension or stacked by index.\n  return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension'); // && (\n  //     stackedByDim != null\n  //         ? stackedByDim === data.getCalculationInfo('stackedByDimension')\n  //         : data.getCalculationInfo('isStackedByIndex')\n  // );\n}\n/**\n * @param {module:echarts/data/List} data\n * @param {string} targetDim\n * @param {string} [stackedByDim] If not input this parameter, check whether\n *                                stacked by index.\n * @return {string} dimension\n */\n\n\nfunction getStackedDimension(data, targetDim) {\n  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;\n}\n\nexports.enableDataStack = enableDataStack;\nexports.isDimensionStacked = isDimensionStacked;\nexports.getStackedDimension = getStackedDimension;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}