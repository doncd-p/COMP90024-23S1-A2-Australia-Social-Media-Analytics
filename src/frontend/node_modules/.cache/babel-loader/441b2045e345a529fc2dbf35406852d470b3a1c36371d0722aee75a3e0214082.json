{"ast":null,"code":"require(\"core-js/modules/es.function.bind.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.map.js\");\nrequire(\"core-js/modules/es.array.slice.js\");\nrequire(\"core-js/modules/es.array.sort.js\");\nrequire(\"core-js/modules/es.array.index-of.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar zrColor = require(\"zrender/lib/tool/color\");\nvar _number = require(\"../util/number\");\nvar linearMap = _number.linearMap;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n/**\n * @param {Object} option\n * @param {string} [option.type] See visualHandlers.\n * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'\n * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],\n *                                              required when mappingMethod is 'linear'\n * @param {Array.<Object>=} [option.pieceList] [\n *                                             {value: someValue},\n *                                             {interval: [min1, max1], visual: {...}},\n *                                             {interval: [min2, max2]}\n *                                             ],\n *                                            required when mappingMethod is 'piecewise'.\n *                                            Visual for only each piece can be specified.\n * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']\n *                                            required when mappingMethod is 'category'.\n *                                            If no option.categories, categories is set\n *                                            as [0, 1, 2, ...].\n * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.\n * @param {(Array|Object|*)} [option.visual]  Visual data.\n *                                            when mappingMethod is 'category',\n *                                            visual data can be array or object\n *                                            (like: {cate1: '#222', none: '#fff'})\n *                                            or primary types (which represents\n *                                            default category visual), otherwise visual\n *                                            can be array or primary (which will be\n *                                            normalized to array).\n *\n */\n\nvar VisualMapping = function VisualMapping(option) {\n  var mappingMethod = option.mappingMethod;\n  var visualType = option.type;\n  /**\n   * @readOnly\n   * @type {Object}\n   */\n\n  var thisOption = this.option = zrUtil.clone(option);\n  /**\n   * @readOnly\n   * @type {string}\n   */\n\n  this.type = visualType;\n  /**\n   * @readOnly\n   * @type {string}\n   */\n\n  this.mappingMethod = mappingMethod;\n  /**\n   * @private\n   * @type {Function}\n   */\n\n  this._normalizeData = normalizers[mappingMethod];\n  var visualHandler = visualHandlers[visualType];\n  /**\n   * @public\n   * @type {Function}\n   */\n\n  this.applyVisual = visualHandler.applyVisual;\n  /**\n   * @public\n   * @type {Function}\n   */\n\n  this.getColorMapper = visualHandler.getColorMapper;\n  /**\n   * @private\n   * @type {Function}\n   */\n\n  this._doMap = visualHandler._doMap[mappingMethod];\n  if (mappingMethod === 'piecewise') {\n    normalizeVisualRange(thisOption);\n    preprocessForPiecewise(thisOption);\n  } else if (mappingMethod === 'category') {\n    thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n    // which need no more preprocess except normalize visual.\n    : normalizeVisualRange(thisOption, true);\n  } else {\n    // mappingMethod === 'linear' or 'fixed'\n    zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n    normalizeVisualRange(thisOption);\n  }\n};\nVisualMapping.prototype = {\n  constructor: VisualMapping,\n  mapValueToVisual: function mapValueToVisual(value) {\n    var normalized = this._normalizeData(value);\n    return this._doMap(normalized, value);\n  },\n  getNormalizer: function getNormalizer() {\n    return zrUtil.bind(this._normalizeData, this);\n  }\n};\nvar visualHandlers = VisualMapping.visualHandlers = {\n  color: {\n    applyVisual: makeApplyVisual('color'),\n    /**\n     * Create a mapper function\n     * @return {Function}\n     */\n    getColorMapper: function getColorMapper() {\n      var thisOption = this.option;\n      return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n        !isNormalized && (value = this._normalizeData(value));\n        return doMapCategory.call(this, value);\n      } : function (value, isNormalized, out) {\n        // If output rgb array\n        // which will be much faster and useful in pixel manipulation\n        var returnRGBArray = !!out;\n        !isNormalized && (value = this._normalizeData(value));\n        out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n        return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n      }, this);\n    },\n    _doMap: {\n      linear: function linear(normalized) {\n        return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n      },\n      category: doMapCategory,\n      piecewise: function piecewise(normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n        if (result == null) {\n          result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        }\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  colorHue: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, value);\n  }),\n  colorSaturation: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, value);\n  }),\n  colorLightness: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, null, value);\n  }),\n  colorAlpha: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyAlpha(color, value);\n  }),\n  opacity: {\n    applyVisual: makeApplyVisual('opacity'),\n    _doMap: makeDoMap([0, 1])\n  },\n  liftZ: {\n    applyVisual: makeApplyVisual('liftZ'),\n    _doMap: {\n      linear: doMapFixed,\n      category: doMapFixed,\n      piecewise: doMapFixed,\n      fixed: doMapFixed\n    }\n  },\n  symbol: {\n    applyVisual: function applyVisual(value, getter, setter) {\n      var symbolCfg = this.mapValueToVisual(value);\n      if (zrUtil.isString(symbolCfg)) {\n        setter('symbol', symbolCfg);\n      } else if (isObject(symbolCfg)) {\n        for (var name in symbolCfg) {\n          if (symbolCfg.hasOwnProperty(name)) {\n            setter(name, symbolCfg[name]);\n          }\n        }\n      }\n    },\n    _doMap: {\n      linear: doMapToArray,\n      category: doMapCategory,\n      piecewise: function piecewise(normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n        if (result == null) {\n          result = doMapToArray.call(this, normalized);\n        }\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  symbolSize: {\n    applyVisual: makeApplyVisual('symbolSize'),\n    _doMap: makeDoMap([0, 1])\n  }\n};\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var visual = thisOption.visual;\n  var categoryMap = thisOption.categoryMap = {};\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr = [];\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n    visual = setVisualToOption(thisOption, visualArr);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n  setVisualToOption(thisOption, visualArr);\n}\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function applyVisual(value, getter, setter) {\n      value = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), value));\n    },\n    _doMap: makeDoMap([0, 1])\n  };\n}\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};\n}\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\nfunction doMapFixed() {\n  return this.option.visual[0];\n}\nfunction makeDoMap(sourceExtent) {\n  return {\n    linear: function linear(normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function piecewise(normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      return zrColor.parse(item);\n    });\n  }\n  return visualArr;\n}\n/**\n * Normalizers by mapping methods.\n */\n\nvar normalizers = {\n  linear: function linear(value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function piecewise(value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function category(value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n/**\n * List available visual types.\n *\n * @public\n * @return {Array.<string>}\n */\n\nVisualMapping.listVisualTypes = function () {\n  var visualTypes = [];\n  zrUtil.each(visualHandlers, function (handler, key) {\n    visualTypes.push(key);\n  });\n  return visualTypes;\n};\n/**\n * @public\n */\n\nVisualMapping.addVisualHandler = function (name, handler) {\n  visualHandlers[name] = handler;\n};\n/**\n * @public\n */\n\nVisualMapping.isValidType = function (visualType) {\n  return visualHandlers.hasOwnProperty(visualType);\n};\n/**\n * Convinent method.\n * Visual can be Object or Array or primary type.\n *\n * @public\n */\n\nVisualMapping.eachVisual = function (visual, callback, context) {\n  if (zrUtil.isObject(visual)) {\n    zrUtil.each(visual, callback, context);\n  } else {\n    callback.call(context, visual);\n  }\n};\nVisualMapping.mapVisual = function (visual, callback, context) {\n  var isPrimary;\n  var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n  VisualMapping.eachVisual(visual, function (v, key) {\n    var newVal = callback.call(context, v, key);\n    isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n  });\n  return newVisual;\n};\n/**\n * @public\n * @param {Object} obj\n * @return {Object} new object containers visual values.\n *                 If no visuals, return null.\n */\n\nVisualMapping.retrieveVisuals = function (obj) {\n  var ret = {};\n  var hasVisual;\n  obj && each(visualHandlers, function (h, visualType) {\n    if (obj.hasOwnProperty(visualType)) {\n      ret[visualType] = obj[visualType];\n      hasVisual = true;\n    }\n  });\n  return hasVisual ? ret : null;\n};\n/**\n * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\n *\n * @public\n * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\n *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\n * @return {Array.<string>} Sorted visual types.\n */\n\nVisualMapping.prepareVisualTypes = function (visualTypes) {\n  if (isObject(visualTypes)) {\n    var types = [];\n    each(visualTypes, function (item, type) {\n      types.push(type);\n    });\n    visualTypes = types;\n  } else if (zrUtil.isArray(visualTypes)) {\n    visualTypes = visualTypes.slice();\n  } else {\n    return [];\n  }\n  visualTypes.sort(function (type1, type2) {\n    // color should be front of colorSaturation, colorAlpha, ...\n    // symbol and symbolSize do not matter.\n    return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n  });\n  return visualTypes;\n};\n/**\n * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\n * Other visuals are only depends on themself.\n *\n * @public\n * @param {string} visualType1\n * @param {string} visualType2\n * @return {boolean}\n */\n\nVisualMapping.dependsOn = function (visualType1, visualType2) {\n  return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n};\n/**\n * @param {number} value\n * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]\n *                         Always from small to big.\n * @param {boolean} [findClosestWhenOutside=false]\n * @return {number} index\n */\n\nVisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n  var possibleI;\n  var abs = Infinity; // value has the higher priority.\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var pieceValue = pieceList[i].value;\n    if (pieceValue != null) {\n      if (pieceValue === value // FIXME\n      // It is supposed to compare value according to value type of dimension,\n      // but currently value type can exactly be string or number.\n      // Compromise for numeric-like string (like '12'), especially\n      // in the case that visualMap.categories is ['22', '33'].\n      || typeof pieceValue === 'string' && pieceValue === value + '') {\n        return i;\n      }\n      findClosestWhenOutside && updatePossible(pieceValue, i);\n    }\n  }\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var piece = pieceList[i];\n    var interval = piece.interval;\n    var close = piece.close;\n    if (interval) {\n      if (interval[0] === -Infinity) {\n        if (littleThan(close[1], value, interval[1])) {\n          return i;\n        }\n      } else if (interval[1] === Infinity) {\n        if (littleThan(close[0], interval[0], value)) {\n          return i;\n        }\n      } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {\n        return i;\n      }\n      findClosestWhenOutside && updatePossible(interval[0], i);\n      findClosestWhenOutside && updatePossible(interval[1], i);\n    }\n  }\n  if (findClosestWhenOutside) {\n    return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n  }\n  function updatePossible(val, index) {\n    var newAbs = Math.abs(val - value);\n    if (newAbs < abs) {\n      abs = newAbs;\n      possibleI = index;\n    }\n  }\n};\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\nvar _default = VisualMapping;\nmodule.exports = _default;","map":{"version":3,"names":["zrUtil","require","zrColor","_number","linearMap","each","isObject","CATEGORY_DEFAULT_VISUAL_INDEX","VisualMapping","option","mappingMethod","visualType","type","thisOption","clone","_normalizeData","normalizers","visualHandler","visualHandlers","applyVisual","getColorMapper","_doMap","normalizeVisualRange","preprocessForPiecewise","categories","preprocessForSpecifiedCategory","assert","dataExtent","prototype","constructor","mapValueToVisual","value","normalized","getNormalizer","bind","color","makeApplyVisual","isNormalized","doMapCategory","call","out","returnRGBArray","fastLerp","parsedVisual","stringify","linear","category","piecewise","result","getSpecifiedVisual","fixed","doMapFixed","colorHue","makePartialColorVisualHandler","modifyHSL","colorSaturation","colorLightness","colorAlpha","modifyAlpha","opacity","makeDoMap","liftZ","symbol","getter","setter","symbolCfg","isString","name","hasOwnProperty","doMapToArray","symbolSize","pieceList","hasSpecialVisual","piece","index","originIndex","visual","categoryMap","cate","isArray","visualArr","v","setVisualToOption","i","length","pop","isCategory","push","doNotNeedPair","applyValue","Math","round","loop","sourceExtent","pieceIndex","findPieceIndex","map","item","parse","noop","listVisualTypes","visualTypes","handler","key","addVisualHandler","isValidType","eachVisual","callback","context","mapVisual","isPrimary","newVisual","newVal","retrieveVisuals","obj","ret","hasVisual","h","prepareVisualTypes","types","slice","sort","type1","type2","indexOf","dependsOn","visualType1","visualType2","findClosestWhenOutside","possibleI","abs","Infinity","len","pieceValue","updatePossible","interval","close","littleThan","val","newAbs","a","b","_default","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc/COMP90024-23S1-A2-Australia-Social-Media-Analytics/src/frontend/node_modules/echarts/lib/visual/VisualMapping.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar zrColor = require(\"zrender/lib/tool/color\");\n\nvar _number = require(\"../util/number\");\n\nvar linearMap = _number.linearMap;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n/**\n * @param {Object} option\n * @param {string} [option.type] See visualHandlers.\n * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'\n * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],\n *                                              required when mappingMethod is 'linear'\n * @param {Array.<Object>=} [option.pieceList] [\n *                                             {value: someValue},\n *                                             {interval: [min1, max1], visual: {...}},\n *                                             {interval: [min2, max2]}\n *                                             ],\n *                                            required when mappingMethod is 'piecewise'.\n *                                            Visual for only each piece can be specified.\n * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']\n *                                            required when mappingMethod is 'category'.\n *                                            If no option.categories, categories is set\n *                                            as [0, 1, 2, ...].\n * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.\n * @param {(Array|Object|*)} [option.visual]  Visual data.\n *                                            when mappingMethod is 'category',\n *                                            visual data can be array or object\n *                                            (like: {cate1: '#222', none: '#fff'})\n *                                            or primary types (which represents\n *                                            default category visual), otherwise visual\n *                                            can be array or primary (which will be\n *                                            normalized to array).\n *\n */\n\nvar VisualMapping = function (option) {\n  var mappingMethod = option.mappingMethod;\n  var visualType = option.type;\n  /**\n   * @readOnly\n   * @type {Object}\n   */\n\n  var thisOption = this.option = zrUtil.clone(option);\n  /**\n   * @readOnly\n   * @type {string}\n   */\n\n  this.type = visualType;\n  /**\n   * @readOnly\n   * @type {string}\n   */\n\n  this.mappingMethod = mappingMethod;\n  /**\n   * @private\n   * @type {Function}\n   */\n\n  this._normalizeData = normalizers[mappingMethod];\n  var visualHandler = visualHandlers[visualType];\n  /**\n   * @public\n   * @type {Function}\n   */\n\n  this.applyVisual = visualHandler.applyVisual;\n  /**\n   * @public\n   * @type {Function}\n   */\n\n  this.getColorMapper = visualHandler.getColorMapper;\n  /**\n   * @private\n   * @type {Function}\n   */\n\n  this._doMap = visualHandler._doMap[mappingMethod];\n\n  if (mappingMethod === 'piecewise') {\n    normalizeVisualRange(thisOption);\n    preprocessForPiecewise(thisOption);\n  } else if (mappingMethod === 'category') {\n    thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n    // which need no more preprocess except normalize visual.\n    : normalizeVisualRange(thisOption, true);\n  } else {\n    // mappingMethod === 'linear' or 'fixed'\n    zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n    normalizeVisualRange(thisOption);\n  }\n};\n\nVisualMapping.prototype = {\n  constructor: VisualMapping,\n  mapValueToVisual: function (value) {\n    var normalized = this._normalizeData(value);\n\n    return this._doMap(normalized, value);\n  },\n  getNormalizer: function () {\n    return zrUtil.bind(this._normalizeData, this);\n  }\n};\nvar visualHandlers = VisualMapping.visualHandlers = {\n  color: {\n    applyVisual: makeApplyVisual('color'),\n\n    /**\n     * Create a mapper function\n     * @return {Function}\n     */\n    getColorMapper: function () {\n      var thisOption = this.option;\n      return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n        !isNormalized && (value = this._normalizeData(value));\n        return doMapCategory.call(this, value);\n      } : function (value, isNormalized, out) {\n        // If output rgb array\n        // which will be much faster and useful in pixel manipulation\n        var returnRGBArray = !!out;\n        !isNormalized && (value = this._normalizeData(value));\n        out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n        return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n      }, this);\n    },\n    _doMap: {\n      linear: function (normalized) {\n        return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n      },\n      category: doMapCategory,\n      piecewise: function (normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n\n        if (result == null) {\n          result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        }\n\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  colorHue: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, value);\n  }),\n  colorSaturation: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, value);\n  }),\n  colorLightness: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, null, value);\n  }),\n  colorAlpha: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyAlpha(color, value);\n  }),\n  opacity: {\n    applyVisual: makeApplyVisual('opacity'),\n    _doMap: makeDoMap([0, 1])\n  },\n  liftZ: {\n    applyVisual: makeApplyVisual('liftZ'),\n    _doMap: {\n      linear: doMapFixed,\n      category: doMapFixed,\n      piecewise: doMapFixed,\n      fixed: doMapFixed\n    }\n  },\n  symbol: {\n    applyVisual: function (value, getter, setter) {\n      var symbolCfg = this.mapValueToVisual(value);\n\n      if (zrUtil.isString(symbolCfg)) {\n        setter('symbol', symbolCfg);\n      } else if (isObject(symbolCfg)) {\n        for (var name in symbolCfg) {\n          if (symbolCfg.hasOwnProperty(name)) {\n            setter(name, symbolCfg[name]);\n          }\n        }\n      }\n    },\n    _doMap: {\n      linear: doMapToArray,\n      category: doMapCategory,\n      piecewise: function (normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n\n        if (result == null) {\n          result = doMapToArray.call(this, normalized);\n        }\n\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  symbolSize: {\n    applyVisual: makeApplyVisual('symbolSize'),\n    _doMap: makeDoMap([0, 1])\n  }\n};\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var visual = thisOption.visual;\n  var categoryMap = thisOption.categoryMap = {};\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function (value, getter, setter) {\n      value = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), value));\n    },\n    _doMap: makeDoMap([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  return this.option.visual[0];\n}\n\nfunction makeDoMap(sourceExtent) {\n  return {\n    linear: function (normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function (normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      return zrColor.parse(item);\n    });\n  }\n\n  return visualArr;\n}\n/**\n * Normalizers by mapping methods.\n */\n\n\nvar normalizers = {\n  linear: function (value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function (value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function (value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n/**\n * List available visual types.\n *\n * @public\n * @return {Array.<string>}\n */\n\nVisualMapping.listVisualTypes = function () {\n  var visualTypes = [];\n  zrUtil.each(visualHandlers, function (handler, key) {\n    visualTypes.push(key);\n  });\n  return visualTypes;\n};\n/**\n * @public\n */\n\n\nVisualMapping.addVisualHandler = function (name, handler) {\n  visualHandlers[name] = handler;\n};\n/**\n * @public\n */\n\n\nVisualMapping.isValidType = function (visualType) {\n  return visualHandlers.hasOwnProperty(visualType);\n};\n/**\n * Convinent method.\n * Visual can be Object or Array or primary type.\n *\n * @public\n */\n\n\nVisualMapping.eachVisual = function (visual, callback, context) {\n  if (zrUtil.isObject(visual)) {\n    zrUtil.each(visual, callback, context);\n  } else {\n    callback.call(context, visual);\n  }\n};\n\nVisualMapping.mapVisual = function (visual, callback, context) {\n  var isPrimary;\n  var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n  VisualMapping.eachVisual(visual, function (v, key) {\n    var newVal = callback.call(context, v, key);\n    isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n  });\n  return newVisual;\n};\n/**\n * @public\n * @param {Object} obj\n * @return {Object} new object containers visual values.\n *                 If no visuals, return null.\n */\n\n\nVisualMapping.retrieveVisuals = function (obj) {\n  var ret = {};\n  var hasVisual;\n  obj && each(visualHandlers, function (h, visualType) {\n    if (obj.hasOwnProperty(visualType)) {\n      ret[visualType] = obj[visualType];\n      hasVisual = true;\n    }\n  });\n  return hasVisual ? ret : null;\n};\n/**\n * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\n *\n * @public\n * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\n *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\n * @return {Array.<string>} Sorted visual types.\n */\n\n\nVisualMapping.prepareVisualTypes = function (visualTypes) {\n  if (isObject(visualTypes)) {\n    var types = [];\n    each(visualTypes, function (item, type) {\n      types.push(type);\n    });\n    visualTypes = types;\n  } else if (zrUtil.isArray(visualTypes)) {\n    visualTypes = visualTypes.slice();\n  } else {\n    return [];\n  }\n\n  visualTypes.sort(function (type1, type2) {\n    // color should be front of colorSaturation, colorAlpha, ...\n    // symbol and symbolSize do not matter.\n    return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n  });\n  return visualTypes;\n};\n/**\n * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\n * Other visuals are only depends on themself.\n *\n * @public\n * @param {string} visualType1\n * @param {string} visualType2\n * @return {boolean}\n */\n\n\nVisualMapping.dependsOn = function (visualType1, visualType2) {\n  return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n};\n/**\n * @param {number} value\n * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]\n *                         Always from small to big.\n * @param {boolean} [findClosestWhenOutside=false]\n * @return {number} index\n */\n\n\nVisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n  var possibleI;\n  var abs = Infinity; // value has the higher priority.\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var pieceValue = pieceList[i].value;\n\n    if (pieceValue != null) {\n      if (pieceValue === value // FIXME\n      // It is supposed to compare value according to value type of dimension,\n      // but currently value type can exactly be string or number.\n      // Compromise for numeric-like string (like '12'), especially\n      // in the case that visualMap.categories is ['22', '33'].\n      || typeof pieceValue === 'string' && pieceValue === value + '') {\n        return i;\n      }\n\n      findClosestWhenOutside && updatePossible(pieceValue, i);\n    }\n  }\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var piece = pieceList[i];\n    var interval = piece.interval;\n    var close = piece.close;\n\n    if (interval) {\n      if (interval[0] === -Infinity) {\n        if (littleThan(close[1], value, interval[1])) {\n          return i;\n        }\n      } else if (interval[1] === Infinity) {\n        if (littleThan(close[0], interval[0], value)) {\n          return i;\n        }\n      } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {\n        return i;\n      }\n\n      findClosestWhenOutside && updatePossible(interval[0], i);\n      findClosestWhenOutside && updatePossible(interval[1], i);\n    }\n  }\n\n  if (findClosestWhenOutside) {\n    return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n  }\n\n  function updatePossible(val, index) {\n    var newAbs = Math.abs(val - value);\n\n    if (newAbs < abs) {\n      abs = newAbs;\n      possibleI = index;\n    }\n  }\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nvar _default = VisualMapping;\nmodule.exports = _default;"],"mappings":";;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,uBAAuB,CAAC;AAE7C,IAAIC,OAAO,GAAGD,OAAO,CAAC,wBAAwB,CAAC;AAE/C,IAAIE,OAAO,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AAEvC,IAAIG,SAAS,GAAGD,OAAO,CAACC,SAAS;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,IAAI,GAAGL,MAAM,CAACK,IAAI;AACtB,IAAIC,QAAQ,GAAGN,MAAM,CAACM,QAAQ;AAC9B,IAAIC,6BAA6B,GAAG,CAAC,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,aAAa,GAAG,SAAhBA,aAAaA,CAAaC,MAAM,EAAE;EACpC,IAAIC,aAAa,GAAGD,MAAM,CAACC,aAAa;EACxC,IAAIC,UAAU,GAAGF,MAAM,CAACG,IAAI;EAC5B;AACF;AACA;AACA;;EAEE,IAAIC,UAAU,GAAG,IAAI,CAACJ,MAAM,GAAGT,MAAM,CAACc,KAAK,CAACL,MAAM,CAAC;EACnD;AACF;AACA;AACA;;EAEE,IAAI,CAACG,IAAI,GAAGD,UAAU;EACtB;AACF;AACA;AACA;;EAEE,IAAI,CAACD,aAAa,GAAGA,aAAa;EAClC;AACF;AACA;AACA;;EAEE,IAAI,CAACK,cAAc,GAAGC,WAAW,CAACN,aAAa,CAAC;EAChD,IAAIO,aAAa,GAAGC,cAAc,CAACP,UAAU,CAAC;EAC9C;AACF;AACA;AACA;;EAEE,IAAI,CAACQ,WAAW,GAAGF,aAAa,CAACE,WAAW;EAC5C;AACF;AACA;AACA;;EAEE,IAAI,CAACC,cAAc,GAAGH,aAAa,CAACG,cAAc;EAClD;AACF;AACA;AACA;;EAEE,IAAI,CAACC,MAAM,GAAGJ,aAAa,CAACI,MAAM,CAACX,aAAa,CAAC;EAEjD,IAAIA,aAAa,KAAK,WAAW,EAAE;IACjCY,oBAAoB,CAACT,UAAU,CAAC;IAChCU,sBAAsB,CAACV,UAAU,CAAC;EACpC,CAAC,MAAM,IAAIH,aAAa,KAAK,UAAU,EAAE;IACvCG,UAAU,CAACW,UAAU,GAAGC,8BAA8B,CAACZ,UAAU,CAAC,CAAC;IACnE;IAAA,EACES,oBAAoB,CAACT,UAAU,EAAE,IAAI,CAAC;EAC1C,CAAC,MAAM;IACL;IACAb,MAAM,CAAC0B,MAAM,CAAChB,aAAa,KAAK,QAAQ,IAAIG,UAAU,CAACc,UAAU,CAAC;IAClEL,oBAAoB,CAACT,UAAU,CAAC;EAClC;AACF,CAAC;AAEDL,aAAa,CAACoB,SAAS,GAAG;EACxBC,WAAW,EAAErB,aAAa;EAC1BsB,gBAAgB,EAAE,SAAAA,iBAAUC,KAAK,EAAE;IACjC,IAAIC,UAAU,GAAG,IAAI,CAACjB,cAAc,CAACgB,KAAK,CAAC;IAE3C,OAAO,IAAI,CAACV,MAAM,CAACW,UAAU,EAAED,KAAK,CAAC;EACvC,CAAC;EACDE,aAAa,EAAE,SAAAA,cAAA,EAAY;IACzB,OAAOjC,MAAM,CAACkC,IAAI,CAAC,IAAI,CAACnB,cAAc,EAAE,IAAI,CAAC;EAC/C;AACF,CAAC;AACD,IAAIG,cAAc,GAAGV,aAAa,CAACU,cAAc,GAAG;EAClDiB,KAAK,EAAE;IACLhB,WAAW,EAAEiB,eAAe,CAAC,OAAO,CAAC;IAErC;AACJ;AACA;AACA;IACIhB,cAAc,EAAE,SAAAA,eAAA,EAAY;MAC1B,IAAIP,UAAU,GAAG,IAAI,CAACJ,MAAM;MAC5B,OAAOT,MAAM,CAACkC,IAAI,CAACrB,UAAU,CAACH,aAAa,KAAK,UAAU,GAAG,UAAUqB,KAAK,EAAEM,YAAY,EAAE;QAC1F,CAACA,YAAY,KAAKN,KAAK,GAAG,IAAI,CAAChB,cAAc,CAACgB,KAAK,CAAC,CAAC;QACrD,OAAOO,aAAa,CAACC,IAAI,CAAC,IAAI,EAAER,KAAK,CAAC;MACxC,CAAC,GAAG,UAAUA,KAAK,EAAEM,YAAY,EAAEG,GAAG,EAAE;QACtC;QACA;QACA,IAAIC,cAAc,GAAG,CAAC,CAACD,GAAG;QAC1B,CAACH,YAAY,KAAKN,KAAK,GAAG,IAAI,CAAChB,cAAc,CAACgB,KAAK,CAAC,CAAC;QACrDS,GAAG,GAAGtC,OAAO,CAACwC,QAAQ,CAACX,KAAK,EAAElB,UAAU,CAAC8B,YAAY,EAAEH,GAAG,CAAC;QAC3D,OAAOC,cAAc,GAAGD,GAAG,GAAGtC,OAAO,CAAC0C,SAAS,CAACJ,GAAG,EAAE,MAAM,CAAC;MAC9D,CAAC,EAAE,IAAI,CAAC;IACV,CAAC;IACDnB,MAAM,EAAE;MACNwB,MAAM,EAAE,SAAAA,OAAUb,UAAU,EAAE;QAC5B,OAAO9B,OAAO,CAAC0C,SAAS,CAAC1C,OAAO,CAACwC,QAAQ,CAACV,UAAU,EAAE,IAAI,CAACvB,MAAM,CAACkC,YAAY,CAAC,EAAE,MAAM,CAAC;MAC1F,CAAC;MACDG,QAAQ,EAAER,aAAa;MACvBS,SAAS,EAAE,SAAAA,UAAUf,UAAU,EAAED,KAAK,EAAE;QACtC,IAAIiB,MAAM,GAAGC,kBAAkB,CAACV,IAAI,CAAC,IAAI,EAAER,KAAK,CAAC;QAEjD,IAAIiB,MAAM,IAAI,IAAI,EAAE;UAClBA,MAAM,GAAG9C,OAAO,CAAC0C,SAAS,CAAC1C,OAAO,CAACwC,QAAQ,CAACV,UAAU,EAAE,IAAI,CAACvB,MAAM,CAACkC,YAAY,CAAC,EAAE,MAAM,CAAC;QAC5F;QAEA,OAAOK,MAAM;MACf,CAAC;MACDE,KAAK,EAAEC;IACT;EACF,CAAC;EACDC,QAAQ,EAAEC,6BAA6B,CAAC,UAAUlB,KAAK,EAAEJ,KAAK,EAAE;IAC9D,OAAO7B,OAAO,CAACoD,SAAS,CAACnB,KAAK,EAAEJ,KAAK,CAAC;EACxC,CAAC,CAAC;EACFwB,eAAe,EAAEF,6BAA6B,CAAC,UAAUlB,KAAK,EAAEJ,KAAK,EAAE;IACrE,OAAO7B,OAAO,CAACoD,SAAS,CAACnB,KAAK,EAAE,IAAI,EAAEJ,KAAK,CAAC;EAC9C,CAAC,CAAC;EACFyB,cAAc,EAAEH,6BAA6B,CAAC,UAAUlB,KAAK,EAAEJ,KAAK,EAAE;IACpE,OAAO7B,OAAO,CAACoD,SAAS,CAACnB,KAAK,EAAE,IAAI,EAAE,IAAI,EAAEJ,KAAK,CAAC;EACpD,CAAC,CAAC;EACF0B,UAAU,EAAEJ,6BAA6B,CAAC,UAAUlB,KAAK,EAAEJ,KAAK,EAAE;IAChE,OAAO7B,OAAO,CAACwD,WAAW,CAACvB,KAAK,EAAEJ,KAAK,CAAC;EAC1C,CAAC,CAAC;EACF4B,OAAO,EAAE;IACPxC,WAAW,EAAEiB,eAAe,CAAC,SAAS,CAAC;IACvCf,MAAM,EAAEuC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EAC1B,CAAC;EACDC,KAAK,EAAE;IACL1C,WAAW,EAAEiB,eAAe,CAAC,OAAO,CAAC;IACrCf,MAAM,EAAE;MACNwB,MAAM,EAAEM,UAAU;MAClBL,QAAQ,EAAEK,UAAU;MACpBJ,SAAS,EAAEI,UAAU;MACrBD,KAAK,EAAEC;IACT;EACF,CAAC;EACDW,MAAM,EAAE;IACN3C,WAAW,EAAE,SAAAA,YAAUY,KAAK,EAAEgC,MAAM,EAAEC,MAAM,EAAE;MAC5C,IAAIC,SAAS,GAAG,IAAI,CAACnC,gBAAgB,CAACC,KAAK,CAAC;MAE5C,IAAI/B,MAAM,CAACkE,QAAQ,CAACD,SAAS,CAAC,EAAE;QAC9BD,MAAM,CAAC,QAAQ,EAAEC,SAAS,CAAC;MAC7B,CAAC,MAAM,IAAI3D,QAAQ,CAAC2D,SAAS,CAAC,EAAE;QAC9B,KAAK,IAAIE,IAAI,IAAIF,SAAS,EAAE;UAC1B,IAAIA,SAAS,CAACG,cAAc,CAACD,IAAI,CAAC,EAAE;YAClCH,MAAM,CAACG,IAAI,EAAEF,SAAS,CAACE,IAAI,CAAC,CAAC;UAC/B;QACF;MACF;IACF,CAAC;IACD9C,MAAM,EAAE;MACNwB,MAAM,EAAEwB,YAAY;MACpBvB,QAAQ,EAAER,aAAa;MACvBS,SAAS,EAAE,SAAAA,UAAUf,UAAU,EAAED,KAAK,EAAE;QACtC,IAAIiB,MAAM,GAAGC,kBAAkB,CAACV,IAAI,CAAC,IAAI,EAAER,KAAK,CAAC;QAEjD,IAAIiB,MAAM,IAAI,IAAI,EAAE;UAClBA,MAAM,GAAGqB,YAAY,CAAC9B,IAAI,CAAC,IAAI,EAAEP,UAAU,CAAC;QAC9C;QAEA,OAAOgB,MAAM;MACf,CAAC;MACDE,KAAK,EAAEC;IACT;EACF,CAAC;EACDmB,UAAU,EAAE;IACVnD,WAAW,EAAEiB,eAAe,CAAC,YAAY,CAAC;IAC1Cf,MAAM,EAAEuC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EAC1B;AACF,CAAC;AAED,SAASrC,sBAAsBA,CAACV,UAAU,EAAE;EAC1C,IAAI0D,SAAS,GAAG1D,UAAU,CAAC0D,SAAS;EACpC1D,UAAU,CAAC2D,gBAAgB,GAAG,KAAK;EACnCxE,MAAM,CAACK,IAAI,CAACkE,SAAS,EAAE,UAAUE,KAAK,EAAEC,KAAK,EAAE;IAC7CD,KAAK,CAACE,WAAW,GAAGD,KAAK,CAAC,CAAC;IAC3B;;IAEA,IAAID,KAAK,CAACG,MAAM,IAAI,IAAI,EAAE;MACxB/D,UAAU,CAAC2D,gBAAgB,GAAG,IAAI;IACpC;EACF,CAAC,CAAC;AACJ;AAEA,SAAS/C,8BAA8BA,CAACZ,UAAU,EAAE;EAClD;EACA,IAAIW,UAAU,GAAGX,UAAU,CAACW,UAAU;EACtC,IAAIoD,MAAM,GAAG/D,UAAU,CAAC+D,MAAM;EAC9B,IAAIC,WAAW,GAAGhE,UAAU,CAACgE,WAAW,GAAG,CAAC,CAAC;EAC7CxE,IAAI,CAACmB,UAAU,EAAE,UAAUsD,IAAI,EAAEJ,KAAK,EAAE;IACtCG,WAAW,CAACC,IAAI,CAAC,GAAGJ,KAAK;EAC3B,CAAC,CAAC,CAAC,CAAC;;EAEJ,IAAI,CAAC1E,MAAM,CAAC+E,OAAO,CAACH,MAAM,CAAC,EAAE;IAC3B,IAAII,SAAS,GAAG,EAAE;IAElB,IAAIhF,MAAM,CAACM,QAAQ,CAACsE,MAAM,CAAC,EAAE;MAC3BvE,IAAI,CAACuE,MAAM,EAAE,UAAUK,CAAC,EAAEH,IAAI,EAAE;QAC9B,IAAIJ,KAAK,GAAGG,WAAW,CAACC,IAAI,CAAC;QAC7BE,SAAS,CAACN,KAAK,IAAI,IAAI,GAAGA,KAAK,GAAGnE,6BAA6B,CAAC,GAAG0E,CAAC;MACtE,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACAD,SAAS,CAACzE,6BAA6B,CAAC,GAAGqE,MAAM;IACnD;IAEAA,MAAM,GAAGM,iBAAiB,CAACrE,UAAU,EAAEmE,SAAS,CAAC;EACnD,CAAC,CAAC;EACF;;EAGA,KAAK,IAAIG,CAAC,GAAG3D,UAAU,CAAC4D,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC/C,IAAIP,MAAM,CAACO,CAAC,CAAC,IAAI,IAAI,EAAE;MACrB,OAAON,WAAW,CAACrD,UAAU,CAAC2D,CAAC,CAAC,CAAC;MACjC3D,UAAU,CAAC6D,GAAG,EAAE;IAClB;EACF;AACF;AAEA,SAAS/D,oBAAoBA,CAACT,UAAU,EAAEyE,UAAU,EAAE;EACpD,IAAIV,MAAM,GAAG/D,UAAU,CAAC+D,MAAM;EAC9B,IAAII,SAAS,GAAG,EAAE;EAElB,IAAIhF,MAAM,CAACM,QAAQ,CAACsE,MAAM,CAAC,EAAE;IAC3BvE,IAAI,CAACuE,MAAM,EAAE,UAAUK,CAAC,EAAE;MACxBD,SAAS,CAACO,IAAI,CAACN,CAAC,CAAC;IACnB,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIL,MAAM,IAAI,IAAI,EAAE;IACzBI,SAAS,CAACO,IAAI,CAACX,MAAM,CAAC;EACxB;EAEA,IAAIY,aAAa,GAAG;IAClBrD,KAAK,EAAE,CAAC;IACR2B,MAAM,EAAE;EACV,CAAC;EAED,IAAI,CAACwB,UAAU,IAAIN,SAAS,CAACI,MAAM,KAAK,CAAC,IAAI,CAACI,aAAa,CAACpB,cAAc,CAACvD,UAAU,CAACD,IAAI,CAAC,EAAE;IAC3F;IACAoE,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC,CAAC;EAC7B;EAEAE,iBAAiB,CAACrE,UAAU,EAAEmE,SAAS,CAAC;AAC1C;AAEA,SAAS3B,6BAA6BA,CAACoC,UAAU,EAAE;EACjD,OAAO;IACLtE,WAAW,EAAE,SAAAA,YAAUY,KAAK,EAAEgC,MAAM,EAAEC,MAAM,EAAE;MAC5CjC,KAAK,GAAG,IAAI,CAACD,gBAAgB,CAACC,KAAK,CAAC,CAAC,CAAC;;MAEtCiC,MAAM,CAAC,OAAO,EAAEyB,UAAU,CAAC1B,MAAM,CAAC,OAAO,CAAC,EAAEhC,KAAK,CAAC,CAAC;IACrD,CAAC;IACDV,MAAM,EAAEuC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EAC1B,CAAC;AACH;AAEA,SAASS,YAAYA,CAACrC,UAAU,EAAE;EAChC,IAAI4C,MAAM,GAAG,IAAI,CAACnE,MAAM,CAACmE,MAAM;EAC/B,OAAOA,MAAM,CAACc,IAAI,CAACC,KAAK,CAACvF,SAAS,CAAC4B,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE4C,MAAM,CAACQ,MAAM,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;AAC9F;AAEA,SAAShD,eAAeA,CAACzB,UAAU,EAAE;EACnC,OAAO,UAAUoB,KAAK,EAAEgC,MAAM,EAAEC,MAAM,EAAE;IACtCA,MAAM,CAACrD,UAAU,EAAE,IAAI,CAACmB,gBAAgB,CAACC,KAAK,CAAC,CAAC;EAClD,CAAC;AACH;AAEA,SAASO,aAAaA,CAACN,UAAU,EAAE;EACjC,IAAI4C,MAAM,GAAG,IAAI,CAACnE,MAAM,CAACmE,MAAM;EAC/B,OAAOA,MAAM,CAAC,IAAI,CAACnE,MAAM,CAACmF,IAAI,IAAI5D,UAAU,KAAKzB,6BAA6B,GAAGyB,UAAU,GAAG4C,MAAM,CAACQ,MAAM,GAAGpD,UAAU,CAAC;AAC3H;AAEA,SAASmB,UAAUA,CAAA,EAAG;EACpB,OAAO,IAAI,CAAC1C,MAAM,CAACmE,MAAM,CAAC,CAAC,CAAC;AAC9B;AAEA,SAAShB,SAASA,CAACiC,YAAY,EAAE;EAC/B,OAAO;IACLhD,MAAM,EAAE,SAAAA,OAAUb,UAAU,EAAE;MAC5B,OAAO5B,SAAS,CAAC4B,UAAU,EAAE6D,YAAY,EAAE,IAAI,CAACpF,MAAM,CAACmE,MAAM,EAAE,IAAI,CAAC;IACtE,CAAC;IACD9B,QAAQ,EAAER,aAAa;IACvBS,SAAS,EAAE,SAAAA,UAAUf,UAAU,EAAED,KAAK,EAAE;MACtC,IAAIiB,MAAM,GAAGC,kBAAkB,CAACV,IAAI,CAAC,IAAI,EAAER,KAAK,CAAC;MAEjD,IAAIiB,MAAM,IAAI,IAAI,EAAE;QAClBA,MAAM,GAAG5C,SAAS,CAAC4B,UAAU,EAAE6D,YAAY,EAAE,IAAI,CAACpF,MAAM,CAACmE,MAAM,EAAE,IAAI,CAAC;MACxE;MAEA,OAAO5B,MAAM;IACf,CAAC;IACDE,KAAK,EAAEC;EACT,CAAC;AACH;AAEA,SAASF,kBAAkBA,CAAClB,KAAK,EAAE;EACjC,IAAIlB,UAAU,GAAG,IAAI,CAACJ,MAAM;EAC5B,IAAI8D,SAAS,GAAG1D,UAAU,CAAC0D,SAAS;EAEpC,IAAI1D,UAAU,CAAC2D,gBAAgB,EAAE;IAC/B,IAAIsB,UAAU,GAAGtF,aAAa,CAACuF,cAAc,CAAChE,KAAK,EAAEwC,SAAS,CAAC;IAC/D,IAAIE,KAAK,GAAGF,SAAS,CAACuB,UAAU,CAAC;IAEjC,IAAIrB,KAAK,IAAIA,KAAK,CAACG,MAAM,EAAE;MACzB,OAAOH,KAAK,CAACG,MAAM,CAAC,IAAI,CAAChE,IAAI,CAAC;IAChC;EACF;AACF;AAEA,SAASsE,iBAAiBA,CAACrE,UAAU,EAAEmE,SAAS,EAAE;EAChDnE,UAAU,CAAC+D,MAAM,GAAGI,SAAS;EAE7B,IAAInE,UAAU,CAACD,IAAI,KAAK,OAAO,EAAE;IAC/BC,UAAU,CAAC8B,YAAY,GAAG3C,MAAM,CAACgG,GAAG,CAAChB,SAAS,EAAE,UAAUiB,IAAI,EAAE;MAC9D,OAAO/F,OAAO,CAACgG,KAAK,CAACD,IAAI,CAAC;IAC5B,CAAC,CAAC;EACJ;EAEA,OAAOjB,SAAS;AAClB;AACA;AACA;AACA;;AAGA,IAAIhE,WAAW,GAAG;EAChB6B,MAAM,EAAE,SAAAA,OAAUd,KAAK,EAAE;IACvB,OAAO3B,SAAS,CAAC2B,KAAK,EAAE,IAAI,CAACtB,MAAM,CAACkB,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC;EAC/D,CAAC;EACDoB,SAAS,EAAE,SAAAA,UAAUhB,KAAK,EAAE;IAC1B,IAAIwC,SAAS,GAAG,IAAI,CAAC9D,MAAM,CAAC8D,SAAS;IACrC,IAAIuB,UAAU,GAAGtF,aAAa,CAACuF,cAAc,CAAChE,KAAK,EAAEwC,SAAS,EAAE,IAAI,CAAC;IAErE,IAAIuB,UAAU,IAAI,IAAI,EAAE;MACtB,OAAO1F,SAAS,CAAC0F,UAAU,EAAE,CAAC,CAAC,EAAEvB,SAAS,CAACa,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC;IACvE;EACF,CAAC;EACDtC,QAAQ,EAAE,SAAAA,SAAUf,KAAK,EAAE;IACzB,IAAI2C,KAAK,GAAG,IAAI,CAACjE,MAAM,CAACe,UAAU,GAAG,IAAI,CAACf,MAAM,CAACoE,WAAW,CAAC9C,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC;;IAE7E,OAAO2C,KAAK,IAAI,IAAI,GAAGnE,6BAA6B,GAAGmE,KAAK;EAC9D,CAAC;EACDxB,KAAK,EAAElD,MAAM,CAACmG;AAChB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA3F,aAAa,CAAC4F,eAAe,GAAG,YAAY;EAC1C,IAAIC,WAAW,GAAG,EAAE;EACpBrG,MAAM,CAACK,IAAI,CAACa,cAAc,EAAE,UAAUoF,OAAO,EAAEC,GAAG,EAAE;IAClDF,WAAW,CAACd,IAAI,CAACgB,GAAG,CAAC;EACvB,CAAC,CAAC;EACF,OAAOF,WAAW;AACpB,CAAC;AACD;AACA;AACA;;AAGA7F,aAAa,CAACgG,gBAAgB,GAAG,UAAUrC,IAAI,EAAEmC,OAAO,EAAE;EACxDpF,cAAc,CAACiD,IAAI,CAAC,GAAGmC,OAAO;AAChC,CAAC;AACD;AACA;AACA;;AAGA9F,aAAa,CAACiG,WAAW,GAAG,UAAU9F,UAAU,EAAE;EAChD,OAAOO,cAAc,CAACkD,cAAc,CAACzD,UAAU,CAAC;AAClD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAGAH,aAAa,CAACkG,UAAU,GAAG,UAAU9B,MAAM,EAAE+B,QAAQ,EAAEC,OAAO,EAAE;EAC9D,IAAI5G,MAAM,CAACM,QAAQ,CAACsE,MAAM,CAAC,EAAE;IAC3B5E,MAAM,CAACK,IAAI,CAACuE,MAAM,EAAE+B,QAAQ,EAAEC,OAAO,CAAC;EACxC,CAAC,MAAM;IACLD,QAAQ,CAACpE,IAAI,CAACqE,OAAO,EAAEhC,MAAM,CAAC;EAChC;AACF,CAAC;AAEDpE,aAAa,CAACqG,SAAS,GAAG,UAAUjC,MAAM,EAAE+B,QAAQ,EAAEC,OAAO,EAAE;EAC7D,IAAIE,SAAS;EACb,IAAIC,SAAS,GAAG/G,MAAM,CAAC+E,OAAO,CAACH,MAAM,CAAC,GAAG,EAAE,GAAG5E,MAAM,CAACM,QAAQ,CAACsE,MAAM,CAAC,GAAG,CAAC,CAAC,IAAIkC,SAAS,GAAG,IAAI,EAAE,IAAI,CAAC;EACrGtG,aAAa,CAACkG,UAAU,CAAC9B,MAAM,EAAE,UAAUK,CAAC,EAAEsB,GAAG,EAAE;IACjD,IAAIS,MAAM,GAAGL,QAAQ,CAACpE,IAAI,CAACqE,OAAO,EAAE3B,CAAC,EAAEsB,GAAG,CAAC;IAC3CO,SAAS,GAAGC,SAAS,GAAGC,MAAM,GAAGD,SAAS,CAACR,GAAG,CAAC,GAAGS,MAAM;EAC1D,CAAC,CAAC;EACF,OAAOD,SAAS;AAClB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAGAvG,aAAa,CAACyG,eAAe,GAAG,UAAUC,GAAG,EAAE;EAC7C,IAAIC,GAAG,GAAG,CAAC,CAAC;EACZ,IAAIC,SAAS;EACbF,GAAG,IAAI7G,IAAI,CAACa,cAAc,EAAE,UAAUmG,CAAC,EAAE1G,UAAU,EAAE;IACnD,IAAIuG,GAAG,CAAC9C,cAAc,CAACzD,UAAU,CAAC,EAAE;MAClCwG,GAAG,CAACxG,UAAU,CAAC,GAAGuG,GAAG,CAACvG,UAAU,CAAC;MACjCyG,SAAS,GAAG,IAAI;IAClB;EACF,CAAC,CAAC;EACF,OAAOA,SAAS,GAAGD,GAAG,GAAG,IAAI;AAC/B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA3G,aAAa,CAAC8G,kBAAkB,GAAG,UAAUjB,WAAW,EAAE;EACxD,IAAI/F,QAAQ,CAAC+F,WAAW,CAAC,EAAE;IACzB,IAAIkB,KAAK,GAAG,EAAE;IACdlH,IAAI,CAACgG,WAAW,EAAE,UAAUJ,IAAI,EAAErF,IAAI,EAAE;MACtC2G,KAAK,CAAChC,IAAI,CAAC3E,IAAI,CAAC;IAClB,CAAC,CAAC;IACFyF,WAAW,GAAGkB,KAAK;EACrB,CAAC,MAAM,IAAIvH,MAAM,CAAC+E,OAAO,CAACsB,WAAW,CAAC,EAAE;IACtCA,WAAW,GAAGA,WAAW,CAACmB,KAAK,EAAE;EACnC,CAAC,MAAM;IACL,OAAO,EAAE;EACX;EAEAnB,WAAW,CAACoB,IAAI,CAAC,UAAUC,KAAK,EAAEC,KAAK,EAAE;IACvC;IACA;IACA,OAAOA,KAAK,KAAK,OAAO,IAAID,KAAK,KAAK,OAAO,IAAIA,KAAK,CAACE,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EACxF,CAAC,CAAC;EACF,OAAOvB,WAAW;AACpB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA7F,aAAa,CAACqH,SAAS,GAAG,UAAUC,WAAW,EAAEC,WAAW,EAAE;EAC5D,OAAOA,WAAW,KAAK,OAAO,GAAG,CAAC,EAAED,WAAW,IAAIA,WAAW,CAACF,OAAO,CAACG,WAAW,CAAC,KAAK,CAAC,CAAC,GAAGD,WAAW,KAAKC,WAAW;AAC1H,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAGAvH,aAAa,CAACuF,cAAc,GAAG,UAAUhE,KAAK,EAAEwC,SAAS,EAAEyD,sBAAsB,EAAE;EACjF,IAAIC,SAAS;EACb,IAAIC,GAAG,GAAGC,QAAQ,CAAC,CAAC;;EAEpB,KAAK,IAAIhD,CAAC,GAAG,CAAC,EAAEiD,GAAG,GAAG7D,SAAS,CAACa,MAAM,EAAED,CAAC,GAAGiD,GAAG,EAAEjD,CAAC,EAAE,EAAE;IACpD,IAAIkD,UAAU,GAAG9D,SAAS,CAACY,CAAC,CAAC,CAACpD,KAAK;IAEnC,IAAIsG,UAAU,IAAI,IAAI,EAAE;MACtB,IAAIA,UAAU,KAAKtG,KAAK,CAAC;MACzB;MACA;MACA;MACA;MAAA,GACG,OAAOsG,UAAU,KAAK,QAAQ,IAAIA,UAAU,KAAKtG,KAAK,GAAG,EAAE,EAAE;QAC9D,OAAOoD,CAAC;MACV;MAEA6C,sBAAsB,IAAIM,cAAc,CAACD,UAAU,EAAElD,CAAC,CAAC;IACzD;EACF;EAEA,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEiD,GAAG,GAAG7D,SAAS,CAACa,MAAM,EAAED,CAAC,GAAGiD,GAAG,EAAEjD,CAAC,EAAE,EAAE;IACpD,IAAIV,KAAK,GAAGF,SAAS,CAACY,CAAC,CAAC;IACxB,IAAIoD,QAAQ,GAAG9D,KAAK,CAAC8D,QAAQ;IAC7B,IAAIC,KAAK,GAAG/D,KAAK,CAAC+D,KAAK;IAEvB,IAAID,QAAQ,EAAE;MACZ,IAAIA,QAAQ,CAAC,CAAC,CAAC,KAAK,CAACJ,QAAQ,EAAE;QAC7B,IAAIM,UAAU,CAACD,KAAK,CAAC,CAAC,CAAC,EAAEzG,KAAK,EAAEwG,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE;UAC5C,OAAOpD,CAAC;QACV;MACF,CAAC,MAAM,IAAIoD,QAAQ,CAAC,CAAC,CAAC,KAAKJ,QAAQ,EAAE;QACnC,IAAIM,UAAU,CAACD,KAAK,CAAC,CAAC,CAAC,EAAED,QAAQ,CAAC,CAAC,CAAC,EAAExG,KAAK,CAAC,EAAE;UAC5C,OAAOoD,CAAC;QACV;MACF,CAAC,MAAM,IAAIsD,UAAU,CAACD,KAAK,CAAC,CAAC,CAAC,EAAED,QAAQ,CAAC,CAAC,CAAC,EAAExG,KAAK,CAAC,IAAI0G,UAAU,CAACD,KAAK,CAAC,CAAC,CAAC,EAAEzG,KAAK,EAAEwG,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE;QAC/F,OAAOpD,CAAC;MACV;MAEA6C,sBAAsB,IAAIM,cAAc,CAACC,QAAQ,CAAC,CAAC,CAAC,EAAEpD,CAAC,CAAC;MACxD6C,sBAAsB,IAAIM,cAAc,CAACC,QAAQ,CAAC,CAAC,CAAC,EAAEpD,CAAC,CAAC;IAC1D;EACF;EAEA,IAAI6C,sBAAsB,EAAE;IAC1B,OAAOjG,KAAK,KAAKoG,QAAQ,GAAG5D,SAAS,CAACa,MAAM,GAAG,CAAC,GAAGrD,KAAK,KAAK,CAACoG,QAAQ,GAAG,CAAC,GAAGF,SAAS;EACxF;EAEA,SAASK,cAAcA,CAACI,GAAG,EAAEhE,KAAK,EAAE;IAClC,IAAIiE,MAAM,GAAGjD,IAAI,CAACwC,GAAG,CAACQ,GAAG,GAAG3G,KAAK,CAAC;IAElC,IAAI4G,MAAM,GAAGT,GAAG,EAAE;MAChBA,GAAG,GAAGS,MAAM;MACZV,SAAS,GAAGvD,KAAK;IACnB;EACF;AACF,CAAC;AAED,SAAS+D,UAAUA,CAACD,KAAK,EAAEI,CAAC,EAAEC,CAAC,EAAE;EAC/B,OAAOL,KAAK,GAAGI,CAAC,IAAIC,CAAC,GAAGD,CAAC,GAAGC,CAAC;AAC/B;AAEA,IAAIC,QAAQ,GAAGtI,aAAa;AAC5BuI,MAAM,CAACC,OAAO,GAAGF,QAAQ"},"metadata":{},"sourceType":"script","externalDependencies":[]}