{"ast":null,"code":"var Definable = require(\"./Definable\");\nvar zrUtil = require(\"../../core/util\");\nvar matrix = require(\"../../core/matrix\");\n\n/**\n * @file Manages SVG clipPath elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG clipPath elements.\n *\n * @class\n * @extends Definable\n * @param   {number}     zrId    zrender instance id\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction ClippathManager(zrId, svgRoot) {\n  Definable.call(this, zrId, svgRoot, 'clipPath', '__clippath_in_use__');\n}\nzrUtil.inherits(ClippathManager, Definable);\n/**\n * Update clipPath.\n *\n * @param {Displayable} displayable displayable element\n */\n\nClippathManager.prototype.update = function (displayable) {\n  var svgEl = this.getSvgElement(displayable);\n  if (svgEl) {\n    this.updateDom(svgEl, displayable.__clipPaths, false);\n  }\n  var textEl = this.getTextSvgElement(displayable);\n  if (textEl) {\n    // Make another clipPath for text, since it's transform\n    // matrix is not the same with svgElement\n    this.updateDom(textEl, displayable.__clipPaths, true);\n  }\n  this.markUsed(displayable);\n};\n/**\n * Create an SVGElement of displayable and create a <clipPath> of its\n * clipPath\n *\n * @param {Displayable} parentEl  parent element\n * @param {ClipPath[]}  clipPaths clipPaths of parent element\n * @param {boolean}     isText    if parent element is Text\n */\n\nClippathManager.prototype.updateDom = function (parentEl, clipPaths, isText) {\n  if (clipPaths && clipPaths.length > 0) {\n    // Has clipPath, create <clipPath> with the first clipPath\n    var defs = this.getDefs(true);\n    var clipPath = clipPaths[0];\n    var clipPathEl;\n    var id;\n    var dom = isText ? '_textDom' : '_dom';\n    if (clipPath[dom]) {\n      // Use a dom that is already in <defs>\n      id = clipPath[dom].getAttribute('id');\n      clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>\n\n      if (!defs.contains(clipPathEl)) {\n        // This happens when set old clipPath that has\n        // been previously removed\n        defs.appendChild(clipPathEl);\n      }\n    } else {\n      // New <clipPath>\n      id = 'zr' + this._zrId + '-clip-' + this.nextId;\n      ++this.nextId;\n      clipPathEl = this.createElement('clipPath');\n      clipPathEl.setAttribute('id', id);\n      defs.appendChild(clipPathEl);\n      clipPath[dom] = clipPathEl;\n    } // Build path and add to <clipPath>\n\n    var svgProxy = this.getSvgProxy(clipPath);\n    if (clipPath.transform && clipPath.parent.invTransform && !isText) {\n      /**\n       * If a clipPath has a parent with transform, the transform\n       * of parent should not be considered when setting transform\n       * of clipPath. So we need to transform back from parent's\n       * transform, which is done by multiplying parent's inverse\n       * transform.\n       */\n      // Store old transform\n      var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path\n\n      matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);\n      svgProxy.brush(clipPath); // Set back transform of clipPath\n\n      clipPath.transform = transform;\n    } else {\n      svgProxy.brush(clipPath);\n    }\n    var pathEl = this.getSvgElement(clipPath);\n    clipPathEl.innerHTML = '';\n    /**\n     * Use `cloneNode()` here to appendChild to multiple parents,\n     * which may happend when Text and other shapes are using the same\n     * clipPath. Since Text will create an extra clipPath DOM due to\n     * different transform rules.\n     */\n\n    clipPathEl.appendChild(pathEl.cloneNode());\n    parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n    if (clipPaths.length > 1) {\n      // Make the other clipPaths recursively\n      this.updateDom(clipPathEl, clipPaths.slice(1), isText);\n    }\n  } else {\n    // No clipPath\n    if (parentEl) {\n      parentEl.setAttribute('clip-path', 'none');\n    }\n  }\n};\n/**\n * Mark a single clipPath to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\nClippathManager.prototype.markUsed = function (displayable) {\n  var that = this; // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n\n  if (displayable.__clipPaths) {\n    zrUtil.each(displayable.__clipPaths, function (clipPath) {\n      if (clipPath._dom) {\n        Definable.prototype.markUsed.call(that, clipPath._dom);\n      }\n      if (clipPath._textDom) {\n        Definable.prototype.markUsed.call(that, clipPath._textDom);\n      }\n    });\n  }\n};\nvar _default = ClippathManager;\nmodule.exports = _default;","map":{"version":3,"names":["Definable","require","zrUtil","matrix","ClippathManager","zrId","svgRoot","call","inherits","prototype","update","displayable","svgEl","getSvgElement","updateDom","__clipPaths","textEl","getTextSvgElement","markUsed","parentEl","clipPaths","isText","length","defs","getDefs","clipPath","clipPathEl","id","dom","getAttribute","contains","appendChild","_zrId","nextId","createElement","setAttribute","svgProxy","getSvgProxy","transform","parent","invTransform","Array","slice","mul","brush","pathEl","innerHTML","cloneNode","that","each","_dom","_textDom","_default","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/zrender/lib/svg/helper/ClippathManager.js"],"sourcesContent":["var Definable = require(\"./Definable\");\n\nvar zrUtil = require(\"../../core/util\");\n\nvar matrix = require(\"../../core/matrix\");\n\n/**\n * @file Manages SVG clipPath elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG clipPath elements.\n *\n * @class\n * @extends Definable\n * @param   {number}     zrId    zrender instance id\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction ClippathManager(zrId, svgRoot) {\n  Definable.call(this, zrId, svgRoot, 'clipPath', '__clippath_in_use__');\n}\n\nzrUtil.inherits(ClippathManager, Definable);\n/**\n * Update clipPath.\n *\n * @param {Displayable} displayable displayable element\n */\n\nClippathManager.prototype.update = function (displayable) {\n  var svgEl = this.getSvgElement(displayable);\n\n  if (svgEl) {\n    this.updateDom(svgEl, displayable.__clipPaths, false);\n  }\n\n  var textEl = this.getTextSvgElement(displayable);\n\n  if (textEl) {\n    // Make another clipPath for text, since it's transform\n    // matrix is not the same with svgElement\n    this.updateDom(textEl, displayable.__clipPaths, true);\n  }\n\n  this.markUsed(displayable);\n};\n/**\n * Create an SVGElement of displayable and create a <clipPath> of its\n * clipPath\n *\n * @param {Displayable} parentEl  parent element\n * @param {ClipPath[]}  clipPaths clipPaths of parent element\n * @param {boolean}     isText    if parent element is Text\n */\n\n\nClippathManager.prototype.updateDom = function (parentEl, clipPaths, isText) {\n  if (clipPaths && clipPaths.length > 0) {\n    // Has clipPath, create <clipPath> with the first clipPath\n    var defs = this.getDefs(true);\n    var clipPath = clipPaths[0];\n    var clipPathEl;\n    var id;\n    var dom = isText ? '_textDom' : '_dom';\n\n    if (clipPath[dom]) {\n      // Use a dom that is already in <defs>\n      id = clipPath[dom].getAttribute('id');\n      clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>\n\n      if (!defs.contains(clipPathEl)) {\n        // This happens when set old clipPath that has\n        // been previously removed\n        defs.appendChild(clipPathEl);\n      }\n    } else {\n      // New <clipPath>\n      id = 'zr' + this._zrId + '-clip-' + this.nextId;\n      ++this.nextId;\n      clipPathEl = this.createElement('clipPath');\n      clipPathEl.setAttribute('id', id);\n      defs.appendChild(clipPathEl);\n      clipPath[dom] = clipPathEl;\n    } // Build path and add to <clipPath>\n\n\n    var svgProxy = this.getSvgProxy(clipPath);\n\n    if (clipPath.transform && clipPath.parent.invTransform && !isText) {\n      /**\n       * If a clipPath has a parent with transform, the transform\n       * of parent should not be considered when setting transform\n       * of clipPath. So we need to transform back from parent's\n       * transform, which is done by multiplying parent's inverse\n       * transform.\n       */\n      // Store old transform\n      var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path\n\n      matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);\n      svgProxy.brush(clipPath); // Set back transform of clipPath\n\n      clipPath.transform = transform;\n    } else {\n      svgProxy.brush(clipPath);\n    }\n\n    var pathEl = this.getSvgElement(clipPath);\n    clipPathEl.innerHTML = '';\n    /**\n     * Use `cloneNode()` here to appendChild to multiple parents,\n     * which may happend when Text and other shapes are using the same\n     * clipPath. Since Text will create an extra clipPath DOM due to\n     * different transform rules.\n     */\n\n    clipPathEl.appendChild(pathEl.cloneNode());\n    parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n\n    if (clipPaths.length > 1) {\n      // Make the other clipPaths recursively\n      this.updateDom(clipPathEl, clipPaths.slice(1), isText);\n    }\n  } else {\n    // No clipPath\n    if (parentEl) {\n      parentEl.setAttribute('clip-path', 'none');\n    }\n  }\n};\n/**\n * Mark a single clipPath to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nClippathManager.prototype.markUsed = function (displayable) {\n  var that = this; // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n\n  if (displayable.__clipPaths) {\n    zrUtil.each(displayable.__clipPaths, function (clipPath) {\n      if (clipPath._dom) {\n        Definable.prototype.markUsed.call(that, clipPath._dom);\n      }\n\n      if (clipPath._textDom) {\n        Definable.prototype.markUsed.call(that, clipPath._textDom);\n      }\n    });\n  }\n};\n\nvar _default = ClippathManager;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}