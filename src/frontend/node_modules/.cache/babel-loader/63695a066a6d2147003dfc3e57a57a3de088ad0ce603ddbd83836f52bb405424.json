{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nvar _config = require(\"./config\");\nvar devicePixelRatio = _config.devicePixelRatio;\nvar util = require(\"./core/util\");\nvar logError = require(\"./core/log\");\nvar BoundingRect = require(\"./core/BoundingRect\");\nvar timsort = require(\"./core/timsort\");\nvar Layer = require(\"./Layer\");\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\nvar Image = require(\"./graphic/Image\");\nvar env = require(\"./core/env\");\nvar HOVER_LAYER_ZLEVEL = 1e5;\nvar CANVAS_ZLEVEL = 314159;\nvar EL_AFTER_INCREMENTAL_INC = 0.01;\nvar INCREMENTAL_INC = 0.001;\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n  if (layer.__builtin__) {\n    return true;\n  }\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n  return true;\n}\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n  if (clipPaths === prevClipPaths) {\n    return false;\n  }\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // Avoid page selected\n\n  domRoot.style.cssText = ['position:relative',\n  // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent\n  // dom does not act as expected) when some of the parent dom has\n  // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and\n  // the canvas is not at the top part of the page.\n  // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove\n  // this `overflow:hidden` to avoid the bug.\n  // 'overflow:hidden',\n  'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @private\n   */\n\n  this._layerConfig = {};\n  /**\n   * zrender will do compositing when root is a canvas and have multiple zlevels.\n   */\n\n  this._needsManuallyCompositing = false;\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    var width = root.width;\n    var height = root.height;\n    if (opts.width != null) {\n      width = opts.width;\n    }\n    if (opts.height != null) {\n      height = opts.height;\n    }\n    this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly\n\n    root.width = width * this.dpr;\n    root.height = height * this.dpr;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device can be specified to create a high dpi image.\n\n    var mainLayer = new Layer(root, this, this.dpr);\n    mainLayer.__builtin__ = true;\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[CANVAS_ZLEVEL] = mainLayer;\n    mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.\n\n    zlevelList.push(CANVAS_ZLEVEL);\n    this._domRoot = root;\n  }\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n  this._hoverlayer = null;\n  this._hoverElements = [];\n};\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n    this._redrawId = Math.random();\n    this._paintList(list, paintAll, this._redrawId); // Paint custum layers\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n      if (!layer.__builtin__ && layer.refresh) {\n        var clearColor = i === 0 ? this._backgroundColor : null;\n        layer.refresh(clearColor);\n      }\n    }\n    this.refreshHover();\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape,\n      z: el.z,\n      z2: el.z2,\n      silent: el.silent\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    hoverStyle && elMirror.setStyle(hoverStyle);\n    this._hoverElements.push(elMirror);\n    return elMirror;\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n    if (!len) {\n      return;\n    }\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);\n    }\n    var scope = {};\n    hoverLayer.ctx.save();\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n    hoverLayer.ctx.restore();\n  },\n  getHoverLayer: function () {\n    return this.getLayer(HOVER_LAYER_ZLEVEL);\n  },\n  _paintList: function (list, paintAll, redrawId) {\n    if (this._redrawId !== redrawId) {\n      return;\n    }\n    paintAll = paintAll || false;\n    this._updateLayerStatus(list);\n    var finished = this._doPaintList(list, paintAll);\n    if (this._needsManuallyCompositing) {\n      this._compositeManually();\n    }\n    if (!finished) {\n      var self = this;\n      requestAnimationFrame(function () {\n        self._paintList(list, paintAll, redrawId);\n      });\n    }\n  },\n  _compositeManually: function () {\n    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;\n    var width = this._domRoot.width;\n    var height = this._domRoot.height;\n    ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?\n\n    this.eachBuiltinLayer(function (layer) {\n      if (layer.virtual) {\n        ctx.drawImage(layer.dom, 0, 0, width, height);\n      }\n    });\n  },\n  _doPaintList: function (list, paintAll) {\n    var layerList = [];\n    for (var zi = 0; zi < this._zlevelList.length; zi++) {\n      var zlevel = this._zlevelList[zi];\n      var layer = this._layers[zlevel];\n      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {\n        layerList.push(layer);\n      }\n    }\n    var finished = true;\n    for (var k = 0; k < layerList.length; k++) {\n      var layer = layerList[k];\n      var ctx = layer.ctx;\n      var scope = {};\n      ctx.save();\n      var start = paintAll ? layer.__startIndex : layer.__drawIndex;\n      var useTimer = !paintAll && layer.incremental && Date.now;\n      var startTime = useTimer && Date.now();\n      var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.\n\n      if (layer.__startIndex === layer.__endIndex) {\n        layer.clear(false, clearColor);\n      } else if (start === layer.__startIndex) {\n        var firstEl = list[start];\n        if (!firstEl.incremental || !firstEl.notClear || paintAll) {\n          layer.clear(false, clearColor);\n        }\n      }\n      if (start === -1) {\n        console.error('For some unknown reason. drawIndex is -1');\n        start = layer.__startIndex;\n      }\n      for (var i = start; i < layer.__endIndex; i++) {\n        var el = list[i];\n        this._doPaintEl(el, layer, paintAll, scope);\n        el.__dirty = el.__dirtyText = false;\n        if (useTimer) {\n          // Date.now can be executed in 13,025,305 ops/second.\n          var dTime = Date.now() - startTime; // Give 15 millisecond to draw.\n          // The rest elements will be drawn in the next frame.\n\n          if (dTime > 15) {\n            break;\n          }\n        }\n      }\n      layer.__drawIndex = i;\n      if (layer.__drawIndex < layer.__endIndex) {\n        finished = false;\n      }\n      if (scope.prevElClipPaths) {\n        // Needs restore the state. If last drawn element is in the clipping area.\n        ctx.restore();\n      }\n      ctx.restore();\n    }\n    if (env.wxa) {\n      // Flush for weixin application\n      util.each(this._layers, function (layer) {\n        if (layer && layer.ctx && layer.ctx.draw) {\n          layer.ctx.draw();\n        }\n      });\n    }\n    return finished;\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n    if ((currentLayer.__dirty || forcePaint) &&\n    // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths;\n      var prevElClipPaths = scope.prevElClipPaths; // Optimize when clipping on group with several elements\n\n      if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (prevElClipPaths) {\n          ctx.restore();\n          scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @param {boolean} virtual Virtual layer will not be inserted into dom.\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel, virtual) {\n    if (this._singleCanvas && !this._needsManuallyCompositing) {\n      zlevel = CANVAS_ZLEVEL;\n    }\n    var layer = this._layers[zlevel];\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.zlevel = zlevel;\n      layer.__builtin__ = true;\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      } // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n      else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {\n        util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);\n      }\n      if (virtual) {\n        layer.virtual = virtual;\n      }\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n    if (layersMap[zlevel]) {\n      logError('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n    if (!isLayerValid(layer)) {\n      logError('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n      prevLayer = layersMap[zlevelList[i]];\n    }\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    this.eachBuiltinLayer(function (layer, z) {\n      layer.__dirty = layer.__used = false;\n    });\n    function updatePrevLayer(idx) {\n      if (prevLayer) {\n        if (prevLayer.__endIndex !== idx) {\n          prevLayer.__dirty = true;\n        }\n        prevLayer.__endIndex = idx;\n      }\n    }\n    if (this._singleCanvas) {\n      for (var i = 1; i < list.length; i++) {\n        var el = list[i];\n        if (el.zlevel !== list[i - 1].zlevel || el.incremental) {\n          this._needsManuallyCompositing = true;\n          break;\n        }\n      }\n    }\n    var prevLayer = null;\n    var incrementalLayerCount = 0;\n    var prevZlevel;\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n      var zlevel = el.zlevel;\n      var layer;\n      if (prevZlevel !== zlevel) {\n        prevZlevel = zlevel;\n        incrementalLayerCount = 0;\n      } // TODO Not use magic number on zlevel.\n      // Each layer with increment element can be separated to 3 layers.\n      //          (Other Element drawn after incremental element)\n      // -----------------zlevel + EL_AFTER_INCREMENTAL_INC--------------------\n      //                      (Incremental element)\n      // ----------------------zlevel + INCREMENTAL_INC------------------------\n      //              (Element drawn before incremental element)\n      // --------------------------------zlevel--------------------------------\n\n      if (el.incremental) {\n        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);\n        layer.incremental = true;\n        incrementalLayerCount = 1;\n      } else {\n        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);\n      }\n      if (!layer.__builtin__) {\n        logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);\n      }\n      if (layer !== prevLayer) {\n        layer.__used = true;\n        if (layer.__startIndex !== i) {\n          layer.__dirty = true;\n        }\n        layer.__startIndex = i;\n        if (!layer.incremental) {\n          layer.__drawIndex = i;\n        } else {\n          // Mark layer draw index needs to update.\n          layer.__drawIndex = -1;\n        }\n        updatePrevLayer(i);\n        prevLayer = layer;\n      }\n      if (el.__dirty) {\n        layer.__dirty = true;\n        if (layer.incremental && layer.__drawIndex < 0) {\n          // Start draw from the first dirty element.\n          layer.__drawIndex = i;\n        }\n      }\n    }\n    updatePrevLayer(i);\n    this.eachBuiltinLayer(function (layer, z) {\n      // Used in last frame but not in this frame. Needs clear\n      if (!layer.__used && layer.getElementCount() > 0) {\n        layer.__dirty = true;\n        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;\n      } // For incremental layer. In case start index changed and no elements are dirty.\n\n      if (layer.__dirty && layer.__drawIndex < 0) {\n        layer.__drawIndex = layer.__startIndex;\n      }\n    });\n  },\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n  setBackgroundColor: function (backgroundColor) {\n    this._backgroundColor = backgroundColor;\n  },\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n      for (var i = 0; i < this._zlevelList.length; i++) {\n        var _zlevel = this._zlevelList[i]; // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n\n        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {\n          var layer = this._layers[_zlevel];\n          util.merge(layer, layerConfig[zlevel], true);\n        }\n      }\n    }\n  },\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n    if (!layer) {\n      return;\n    }\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    if (!this._domRoot.style) {\n      // Maybe in node or worker\n      if (width == null || height == null) {\n        return;\n      }\n      this._width = width;\n      this._height = height;\n      this.getLayer(CANVAS_ZLEVEL).resize(width, height);\n    } else {\n      var domRoot = this._domRoot; // FIXME Why ?\n\n      domRoot.style.display = 'none'; // Save input w/h\n\n      var opts = this._opts;\n      width != null && (opts.width = width);\n      height != null && (opts.height = height);\n      width = this._getSize(0);\n      height = this._getSize(1);\n      domRoot.style.display = ''; // 优化没有实际改变的resize\n\n      if (this._width !== width || height !== this._height) {\n        domRoot.style.width = width + 'px';\n        domRoot.style.height = height + 'px';\n        for (var id in this._layers) {\n          if (this._layers.hasOwnProperty(id)) {\n            this._layers[id].resize(width, height);\n          }\n        }\n        util.each(this._progressiveLayers, function (layer) {\n          layer.resize(width, height);\n        });\n        this.refresh(true);\n      }\n      this._width = width;\n      this._height = height;\n    }\n    return this;\n  },\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n    if (layer) {\n      layer.clear();\n    }\n  },\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n    if (this._singleCanvas && !this._compositeManually) {\n      return this._layers[CANVAS_ZLEVEL].dom;\n    }\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);\n    if (opts.pixelRatio <= this.dpr) {\n      this.refresh();\n      var width = imageLayer.dom.width;\n      var height = imageLayer.dom.height;\n      var ctx = imageLayer.ctx;\n      this.eachLayer(function (layer) {\n        if (layer.__builtin__) {\n          ctx.drawImage(layer.dom, 0, 0, width, height);\n        } else if (layer.renderToCanvas) {\n          imageLayer.ctx.save();\n          layer.renderToCanvas(imageLayer.ctx);\n          imageLayer.ctx.restore();\n        }\n      });\n    } else {\n      // PENDING, echarts-gl and incremental rendering.\n      var scope = {};\n      var displayList = this.storage.getDisplayList(true);\n      for (var i = 0; i < displayList.length; i++) {\n        var el = displayList[i];\n        this._doPaintEl(el, imageLayer, true, scope);\n      }\n    }\n    return imageLayer.dom;\n  },\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur * dpr;\n    var shadowOffsetX = style.shadowOffsetX * dpr;\n    var shadowOffsetY = style.shadowOffsetY * dpr;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n    if (path) {\n      path.brush(ctx);\n    }\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","devicePixelRatio","util","logError","BoundingRect","timsort","Layer","requestAnimationFrame","Image","env","HOVER_LAYER_ZLEVEL","CANVAS_ZLEVEL","EL_AFTER_INCREMENTAL_INC","INCREMENTAL_INC","parseInt10","val","parseInt","isLayerValid","layer","__builtin__","resize","refresh","tmpRect","viewRect","isDisplayableCulled","el","width","height","copy","getBoundingRect","transform","applyTransform","intersect","isClipPathChanged","clipPaths","prevClipPaths","length","i","doClip","ctx","clipPath","setTransform","beginPath","buildPath","shape","clip","restoreTransform","createRoot","domRoot","document","createElement","style","cssText","join","Painter","root","storage","opts","type","singleCanvas","nodeName","toUpperCase","_opts","extend","dpr","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_needsManuallyCompositing","_width","_getSize","_height","_domRoot","appendChild","mainLayer","initContext","zlevel","push","_hoverlayer","_hoverElements","prototype","constructor","getType","isSingleCanvas","getViewportRoot","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","paintAll","list","getDisplayList","_redrawId","Math","random","_paintList","z","clearColor","_backgroundColor","refreshHover","addHover","hoverStyle","__hoverMir","elMirror","z2","silent","__from","setStyle","removeHover","hoverElements","idx","indexOf","splice","clearHover","from","len","hoverLayer","clear","displayableSortFunc","getLayer","scope","save","originalEl","__zr","invisible","invTransform","__clipPaths","_doPaintEl","restore","getHoverLayer","redrawId","_updateLayerStatus","finished","_doPaintList","_compositeManually","self","clearRect","eachBuiltinLayer","virtual","drawImage","dom","layerList","zi","__dirty","k","start","__startIndex","__drawIndex","useTimer","incremental","Date","now","startTime","__endIndex","firstEl","notClear","console","error","__dirtyText","dTime","prevElClipPaths","wxa","each","draw","currentLayer","forcePaint","m","opacity","culling","prevEl","beforeBrush","brush","afterBrush","merge","insertLayer","layersMap","prevLayer","prevDom","nextSibling","insertBefore","firstChild","eachLayer","cb","context","call","eachOtherLayer","getLayers","__used","updatePrevLayer","incrementalLayerCount","prevZlevel","id","getElementCount","_clearLayer","setBackgroundColor","backgroundColor","configLayer","config","layerConfig","_zlevel","delLayer","parentNode","removeChild","display","hasOwnProperty","_progressiveLayers","clearLayer","dispose","getRenderedCanvas","imageLayer","pixelRatio","renderToCanvas","displayList","getWidth","getHeight","whIdx","wh","cwh","plt","prb","parseFloat","stl","defaultView","getComputedStyle","pathToImage","path","canvas","getContext","rect","shadowBlurSize","shadowBlur","shadowOffsetX","shadowOffsetY","lineWidth","hasStroke","leftMargin","max","rightMargin","topMargin","bottomMargin","scale","pathTransform","position","rotation","x","y","updateTransform","ImageShape","imgShape","image","_default","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/zrender/lib/Painter.js"],"sourcesContent":["var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar logError = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\nvar env = require(\"./core/env\");\n\nvar HOVER_LAYER_ZLEVEL = 1e5;\nvar CANVAS_ZLEVEL = 314159;\nvar EL_AFTER_INCREMENTAL_INC = 0.01;\nvar INCREMENTAL_INC = 0.001;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n  if (clipPaths === prevClipPaths) {\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // Avoid page selected\n\n  domRoot.style.cssText = ['position:relative', // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent\n  // dom does not act as expected) when some of the parent dom has\n  // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and\n  // the canvas is not at the top part of the page.\n  // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove\n  // this `overflow:hidden` to avoid the bug.\n  // 'overflow:hidden',\n  'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @private\n   */\n\n  this._layerConfig = {};\n  /**\n   * zrender will do compositing when root is a canvas and have multiple zlevels.\n   */\n\n  this._needsManuallyCompositing = false;\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    var width = root.width;\n    var height = root.height;\n\n    if (opts.width != null) {\n      width = opts.width;\n    }\n\n    if (opts.height != null) {\n      height = opts.height;\n    }\n\n    this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly\n\n    root.width = width * this.dpr;\n    root.height = height * this.dpr;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device can be specified to create a high dpi image.\n\n    var mainLayer = new Layer(root, this, this.dpr);\n    mainLayer.__builtin__ = true;\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[CANVAS_ZLEVEL] = mainLayer;\n    mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.\n\n    zlevelList.push(CANVAS_ZLEVEL);\n    this._domRoot = root;\n  }\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n\n  this._hoverlayer = null;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n    this._redrawId = Math.random();\n\n    this._paintList(list, paintAll, this._redrawId); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        var clearColor = i === 0 ? this._backgroundColor : null;\n        layer.refresh(clearColor);\n      }\n    }\n\n    this.refreshHover();\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape,\n      z: el.z,\n      z2: el.z2,\n      silent: el.silent\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    hoverStyle && elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n\n    return elMirror;\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  getHoverLayer: function () {\n    return this.getLayer(HOVER_LAYER_ZLEVEL);\n  },\n  _paintList: function (list, paintAll, redrawId) {\n    if (this._redrawId !== redrawId) {\n      return;\n    }\n\n    paintAll = paintAll || false;\n\n    this._updateLayerStatus(list);\n\n    var finished = this._doPaintList(list, paintAll);\n\n    if (this._needsManuallyCompositing) {\n      this._compositeManually();\n    }\n\n    if (!finished) {\n      var self = this;\n      requestAnimationFrame(function () {\n        self._paintList(list, paintAll, redrawId);\n      });\n    }\n  },\n  _compositeManually: function () {\n    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;\n    var width = this._domRoot.width;\n    var height = this._domRoot.height;\n    ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?\n\n    this.eachBuiltinLayer(function (layer) {\n      if (layer.virtual) {\n        ctx.drawImage(layer.dom, 0, 0, width, height);\n      }\n    });\n  },\n  _doPaintList: function (list, paintAll) {\n    var layerList = [];\n\n    for (var zi = 0; zi < this._zlevelList.length; zi++) {\n      var zlevel = this._zlevelList[zi];\n      var layer = this._layers[zlevel];\n\n      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {\n        layerList.push(layer);\n      }\n    }\n\n    var finished = true;\n\n    for (var k = 0; k < layerList.length; k++) {\n      var layer = layerList[k];\n      var ctx = layer.ctx;\n      var scope = {};\n      ctx.save();\n      var start = paintAll ? layer.__startIndex : layer.__drawIndex;\n      var useTimer = !paintAll && layer.incremental && Date.now;\n      var startTime = useTimer && Date.now();\n      var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.\n\n      if (layer.__startIndex === layer.__endIndex) {\n        layer.clear(false, clearColor);\n      } else if (start === layer.__startIndex) {\n        var firstEl = list[start];\n\n        if (!firstEl.incremental || !firstEl.notClear || paintAll) {\n          layer.clear(false, clearColor);\n        }\n      }\n\n      if (start === -1) {\n        console.error('For some unknown reason. drawIndex is -1');\n        start = layer.__startIndex;\n      }\n\n      for (var i = start; i < layer.__endIndex; i++) {\n        var el = list[i];\n\n        this._doPaintEl(el, layer, paintAll, scope);\n\n        el.__dirty = el.__dirtyText = false;\n\n        if (useTimer) {\n          // Date.now can be executed in 13,025,305 ops/second.\n          var dTime = Date.now() - startTime; // Give 15 millisecond to draw.\n          // The rest elements will be drawn in the next frame.\n\n          if (dTime > 15) {\n            break;\n          }\n        }\n      }\n\n      layer.__drawIndex = i;\n\n      if (layer.__drawIndex < layer.__endIndex) {\n        finished = false;\n      }\n\n      if (scope.prevElClipPaths) {\n        // Needs restore the state. If last drawn element is in the clipping area.\n        ctx.restore();\n      }\n\n      ctx.restore();\n    }\n\n    if (env.wxa) {\n      // Flush for weixin application\n      util.each(this._layers, function (layer) {\n        if (layer && layer.ctx && layer.ctx.draw) {\n          layer.ctx.draw();\n        }\n      });\n    }\n\n    return finished;\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths;\n      var prevElClipPaths = scope.prevElClipPaths; // Optimize when clipping on group with several elements\n\n      if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (prevElClipPaths) {\n          ctx.restore();\n          scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @param {boolean} virtual Virtual layer will not be inserted into dom.\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel, virtual) {\n    if (this._singleCanvas && !this._needsManuallyCompositing) {\n      zlevel = CANVAS_ZLEVEL;\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.zlevel = zlevel;\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      } // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n      else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {\n          util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);\n        }\n\n      if (virtual) {\n        layer.virtual = virtual;\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      logError('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      logError('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    this.eachBuiltinLayer(function (layer, z) {\n      layer.__dirty = layer.__used = false;\n    });\n\n    function updatePrevLayer(idx) {\n      if (prevLayer) {\n        if (prevLayer.__endIndex !== idx) {\n          prevLayer.__dirty = true;\n        }\n\n        prevLayer.__endIndex = idx;\n      }\n    }\n\n    if (this._singleCanvas) {\n      for (var i = 1; i < list.length; i++) {\n        var el = list[i];\n\n        if (el.zlevel !== list[i - 1].zlevel || el.incremental) {\n          this._needsManuallyCompositing = true;\n          break;\n        }\n      }\n    }\n\n    var prevLayer = null;\n    var incrementalLayerCount = 0;\n    var prevZlevel;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n      var zlevel = el.zlevel;\n      var layer;\n\n      if (prevZlevel !== zlevel) {\n        prevZlevel = zlevel;\n        incrementalLayerCount = 0;\n      } // TODO Not use magic number on zlevel.\n      // Each layer with increment element can be separated to 3 layers.\n      //          (Other Element drawn after incremental element)\n      // -----------------zlevel + EL_AFTER_INCREMENTAL_INC--------------------\n      //                      (Incremental element)\n      // ----------------------zlevel + INCREMENTAL_INC------------------------\n      //              (Element drawn before incremental element)\n      // --------------------------------zlevel--------------------------------\n\n\n      if (el.incremental) {\n        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);\n        layer.incremental = true;\n        incrementalLayerCount = 1;\n      } else {\n        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);\n      }\n\n      if (!layer.__builtin__) {\n        logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);\n      }\n\n      if (layer !== prevLayer) {\n        layer.__used = true;\n\n        if (layer.__startIndex !== i) {\n          layer.__dirty = true;\n        }\n\n        layer.__startIndex = i;\n\n        if (!layer.incremental) {\n          layer.__drawIndex = i;\n        } else {\n          // Mark layer draw index needs to update.\n          layer.__drawIndex = -1;\n        }\n\n        updatePrevLayer(i);\n        prevLayer = layer;\n      }\n\n      if (el.__dirty) {\n        layer.__dirty = true;\n\n        if (layer.incremental && layer.__drawIndex < 0) {\n          // Start draw from the first dirty element.\n          layer.__drawIndex = i;\n        }\n      }\n    }\n\n    updatePrevLayer(i);\n    this.eachBuiltinLayer(function (layer, z) {\n      // Used in last frame but not in this frame. Needs clear\n      if (!layer.__used && layer.getElementCount() > 0) {\n        layer.__dirty = true;\n        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;\n      } // For incremental layer. In case start index changed and no elements are dirty.\n\n\n      if (layer.__dirty && layer.__drawIndex < 0) {\n        layer.__drawIndex = layer.__startIndex;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n  setBackgroundColor: function (backgroundColor) {\n    this._backgroundColor = backgroundColor;\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      for (var i = 0; i < this._zlevelList.length; i++) {\n        var _zlevel = this._zlevelList[i]; // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n\n        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {\n          var layer = this._layers[_zlevel];\n          util.merge(layer, layerConfig[zlevel], true);\n        }\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    if (!this._domRoot.style) {\n      // Maybe in node or worker\n      if (width == null || height == null) {\n        return;\n      }\n\n      this._width = width;\n      this._height = height;\n      this.getLayer(CANVAS_ZLEVEL).resize(width, height);\n    } else {\n      var domRoot = this._domRoot; // FIXME Why ?\n\n      domRoot.style.display = 'none'; // Save input w/h\n\n      var opts = this._opts;\n      width != null && (opts.width = width);\n      height != null && (opts.height = height);\n      width = this._getSize(0);\n      height = this._getSize(1);\n      domRoot.style.display = ''; // 优化没有实际改变的resize\n\n      if (this._width !== width || height !== this._height) {\n        domRoot.style.width = width + 'px';\n        domRoot.style.height = height + 'px';\n\n        for (var id in this._layers) {\n          if (this._layers.hasOwnProperty(id)) {\n            this._layers[id].resize(width, height);\n          }\n        }\n\n        util.each(this._progressiveLayers, function (layer) {\n          layer.resize(width, height);\n        });\n        this.refresh(true);\n      }\n\n      this._width = width;\n      this._height = height;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas && !this._compositeManually) {\n      return this._layers[CANVAS_ZLEVEL].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);\n\n    if (opts.pixelRatio <= this.dpr) {\n      this.refresh();\n      var width = imageLayer.dom.width;\n      var height = imageLayer.dom.height;\n      var ctx = imageLayer.ctx;\n      this.eachLayer(function (layer) {\n        if (layer.__builtin__) {\n          ctx.drawImage(layer.dom, 0, 0, width, height);\n        } else if (layer.renderToCanvas) {\n          imageLayer.ctx.save();\n          layer.renderToCanvas(imageLayer.ctx);\n          imageLayer.ctx.restore();\n        }\n      });\n    } else {\n      // PENDING, echarts-gl and incremental rendering.\n      var scope = {};\n      var displayList = this.storage.getDisplayList(true);\n\n      for (var i = 0; i < displayList.length; i++) {\n        var el = displayList[i];\n\n        this._doPaintEl(el, imageLayer, true, scope);\n      }\n    }\n\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur * dpr;\n    var shadowOffsetX = style.shadowOffsetX * dpr;\n    var shadowOffsetY = style.shadowOffsetY * dpr;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}