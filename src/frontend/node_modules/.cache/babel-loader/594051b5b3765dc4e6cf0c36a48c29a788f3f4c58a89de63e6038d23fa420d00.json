{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar graphic = require(\"../../util/graphic\");\nvar layoutUtil = require(\"../../util/layout\");\nvar LegendView = require(\"./LegendView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n    this._controllerGroup.removeAll();\n    this._containerGroup.removeClipPath();\n    this._containerGroup.__rectSize = null;\n  },\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layoutUtil.box(\n    // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = zrUtil.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx);\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.attr('position', selectorPos);\n    }\n    return mainRect;\n  },\n  _layoutContentAndController: function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box(\n    // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup.position[orientIdx];\n    } // Layout container group based on 0.\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n        containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n      }\n    } // Always align controller to content as 'middle'.\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n    var pageInfo = this._getPageInfo(legendModel);\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    },\n    // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : false);\n    this._updatePageInfoView(legendModel, pageInfo);\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no previous page.\n   *  pageNextDataIndex: number, null when no next page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: contentGroup.position.slice(),\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n    if (!targetItem) {\n      return result;\n    }\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n      if (\n      // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize ||\n      // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n          ++result.pageCount;\n        }\n      }\n      winEndItemInfo = currItemInfo;\n    }\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n      if (\n      // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) &&\n      // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n      winStartItemInfo = currItemInfo;\n    }\n    return result;\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el.position[orientIdx];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  },\n  _findTargetItemIndex: function (targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex; // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;","map":{"version":3,"names":["zrUtil","require","graphic","layoutUtil","LegendView","Group","WH","XY","ScrollableLegendView","extend","type","newlineDisabled","init","superCall","_currentIndex","group","add","_containerGroup","getContentGroup","_controllerGroup","_showController","resetInner","removeAll","removeClipPath","__rectSize","renderInner","itemAlign","legendModel","ecModel","api","selector","orient","selectorPosition","me","controllerGroup","pageIconSize","get","isArray","createPageButton","pageTextStyleModel","getModel","Text","name","style","textFill","getTextColor","font","getFont","textVerticalAlign","textAlign","silent","iconIdx","pageDataIndexName","icon","createIcon","getOrient","onclick","bind","_pageGo","x","y","width","height","layoutInner","maxSize","isFirstRender","selectorGroup","getSelectorGroup","orientIdx","index","wh","xy","hw","yx","box","selectorButtonGap","selectorRect","getBoundingRect","selectorPos","processMaxSize","clone","mainRect","_layoutContentAndController","offset","Math","max","min","attr","contentGroup","containerGroup","contentRect","controllerRect","showController","contentPos","position","containerPos","controllerPos","pageButtonGap","retrieve2","pageButtonPosition","clipShape","setClipPath","Rect","shape","eachChild","child","invisible","pageInfo","_getPageInfo","pageIndex","updateProps","contentPosition","_updatePageInfoView","to","scrollDataIndex","dispatchAction","legendId","id","each","canJump","childOfName","setStyle","cursor","pageText","pageFormatter","current","total","pageCount","isString","replace","containerRectSize","targetItemIndex","_findTargetItemIndex","children","targetItem","itemCount","length","pCount","result","slice","pagePrevDataIndex","pageNextDataIndex","targetItemInfo","getItemInfo","s","i","winStartItemInfo","winEndItemInfo","currItemInfo","e","intersect","el","itemRect","start","__legendDataIndex","itemInfo","winStart","targetDataIndex","defaultIndex","idx","legendDataIdx","_default","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/echarts/lib/component/legend/ScrollableLegendView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar LegendView = require(\"./LegendView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layoutUtil.box( // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = zrUtil.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx);\n\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.attr('position', selectorPos);\n    }\n\n    return mainRect;\n  },\n  _layoutContentAndController: function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup.position[orientIdx];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no previous page.\n   *  pageNextDataIndex: number, null when no next page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: contentGroup.position.slice(),\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el.position[orientIdx];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  },\n  _findTargetItemIndex: function (targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex; // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}