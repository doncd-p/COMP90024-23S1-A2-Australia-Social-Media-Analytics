{"ast":null,"code":"require(\"core-js/modules/es.array.slice.js\");\nrequire(\"core-js/modules/es.array.push.js\");\n// Myers' Diff Algorithm\n// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js\nfunction Diff() {}\nDiff.prototype = {\n  diff: function diff(oldArr, newArr, equals) {\n    if (!equals) {\n      equals = function equals(a, b) {\n        return a === b;\n      };\n    }\n    this.equals = equals;\n    var self = this;\n    oldArr = oldArr.slice();\n    newArr = newArr.slice(); // Allow subclasses to massage the input prior to running\n\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      var indices = [];\n      for (var i = 0; i < newArr.length; i++) {\n        indices.push(i);\n      } // Identity per the equality and tokenizer\n\n      return [{\n        indices: indices,\n        count: newArr.length\n      }];\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath;\n        var addPath = bestPath[diagonalPath - 1];\n        var removePath = bestPath[diagonalPath + 1];\n        var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n        var canAdd = addPath && addPath.newPos + 1 < newLen;\n        var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n        oldPos = self.extractCommon(basePath, newArr, oldArr, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newArr, oldArr);\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n      editLength++;\n    }\n    while (editLength <= maxEditLength) {\n      var ret = execEditLength();\n      if (ret) {\n        return ret;\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newArr, oldArr, diagonalPath) {\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var newPos = basePath.newPos;\n    var oldPos = newPos - diagonalPath;\n    var commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  tokenize: function tokenize(value) {\n    return value.slice();\n  },\n  join: function join(value) {\n    return value.slice();\n  }\n};\nfunction buildValues(diff, components, newArr, oldArr) {\n  var componentPos = 0;\n  var componentLen = components.length;\n  var newPos = 0;\n  var oldPos = 0;\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n    if (!component.removed) {\n      var indices = [];\n      for (var i = newPos; i < newPos + component.count; i++) {\n        indices.push(i);\n      }\n      component.indices = indices;\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      var indices = [];\n      for (var i = oldPos; i < oldPos + component.count; i++) {\n        indices.push(i);\n      }\n      component.indices = indices;\n      oldPos += component.count;\n    }\n  }\n  return components;\n}\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\nvar arrayDiff = new Diff();\nfunction _default(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\nmodule.exports = _default;","map":{"version":3,"names":["Diff","prototype","diff","oldArr","newArr","equals","a","b","self","slice","newLen","length","oldLen","editLength","maxEditLength","bestPath","newPos","components","oldPos","extractCommon","indices","i","push","count","execEditLength","diagonalPath","basePath","addPath","removePath","undefined","canAdd","canRemove","clonePath","pushComponent","buildValues","ret","added","removed","last","commonCount","tokenize","value","join","componentPos","componentLen","component","path","arrayDiff","_default","callback","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc/COMP90024-23S1-A2-Australia-Social-Media-Analytics/src/frontend/node_modules/zrender/lib/core/arrayDiff2.js"],"sourcesContent":["// Myers' Diff Algorithm\n// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js\nfunction Diff() {}\n\nDiff.prototype = {\n  diff: function (oldArr, newArr, equals) {\n    if (!equals) {\n      equals = function (a, b) {\n        return a === b;\n      };\n    }\n\n    this.equals = equals;\n    var self = this;\n    oldArr = oldArr.slice();\n    newArr = newArr.slice(); // Allow subclasses to massage the input prior to running\n\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      var indices = [];\n\n      for (var i = 0; i < newArr.length; i++) {\n        indices.push(i);\n      } // Identity per the equality and tokenizer\n\n\n      return [{\n        indices: indices,\n        count: newArr.length\n      }];\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath;\n        var addPath = bestPath[diagonalPath - 1];\n        var removePath = bestPath[diagonalPath + 1];\n        var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen;\n        var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newArr, oldArr, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newArr, oldArr);\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    while (editLength <= maxEditLength) {\n      var ret = execEditLength();\n\n      if (ret) {\n        return ret;\n      }\n    }\n  },\n  pushComponent: function (components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function (basePath, newArr, oldArr, diagonalPath) {\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var newPos = basePath.newPos;\n    var oldPos = newPos - diagonalPath;\n    var commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  tokenize: function (value) {\n    return value.slice();\n  },\n  join: function (value) {\n    return value.slice();\n  }\n};\n\nfunction buildValues(diff, components, newArr, oldArr) {\n  var componentPos = 0;\n  var componentLen = components.length;\n  var newPos = 0;\n  var oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      var indices = [];\n\n      for (var i = newPos; i < newPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      var indices = [];\n\n      for (var i = oldPos; i < oldPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      oldPos += component.count;\n    }\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar arrayDiff = new Diff();\n\nfunction _default(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}