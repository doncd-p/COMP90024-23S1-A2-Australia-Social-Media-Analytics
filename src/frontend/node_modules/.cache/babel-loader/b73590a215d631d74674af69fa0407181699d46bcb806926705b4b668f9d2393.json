{"ast":null,"code":"require(\"core-js/modules/esnext.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/esnext.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/esnext.typed-array.with.js\");\nrequire(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar _number = require(\"../util/number\");\nvar parsePercent = _number.parsePercent;\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float32Array */\nvar STACK_PREFIX = '__ec_stack_';\nvar LARGE_BAR_MIN_WIDTH = 0.5;\nvar LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barMinWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\nfunction getLayoutOnAxis(opt) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n  var bandWidth = baseAxis.getBandWidth();\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n  var widthAndOffsets = doCalBarWidthAndOffset(params);\n  var result = [];\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n  return result;\n}\nfunction prepareLayoutBarSeries(seriesType, ecModel) {\n  var seriesModels = [];\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {\n      seriesModels.push(seriesModel);\n    }\n  });\n  return seriesModels;\n}\n/**\n * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent\n * values.\n * This works for time axes, value axes, and log axes.\n * For a single time axis, return value is in the form like\n * {'x_0': [1000000]}.\n * The value of 1000000 is in milliseconds.\n */\n\nfunction getValueAxesMinGaps(barSeries) {\n  /**\n   * Map from axis.index to values.\n   * For a single time axis, axisValues is in the form like\n   * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.\n   * Items in axisValues[x], e.g. 1495555200000, are time values of all\n   * series.\n   */\n  var axisValues = {};\n  zrUtil.each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {\n      return;\n    }\n    var data = seriesModel.getData();\n    var key = baseAxis.dim + '_' + baseAxis.index;\n    var dim = data.mapDimension(baseAxis.dim);\n    for (var i = 0, cnt = data.count(); i < cnt; ++i) {\n      var value = data.get(dim, i);\n      if (!axisValues[key]) {\n        // No previous data for the axis\n        axisValues[key] = [value];\n      } else {\n        // No value in previous series\n        axisValues[key].push(value);\n      } // Ignore duplicated time values in the same axis\n    }\n  });\n\n  var axisMinGaps = [];\n  for (var key in axisValues) {\n    if (axisValues.hasOwnProperty(key)) {\n      var valuesInAxis = axisValues[key];\n      if (valuesInAxis) {\n        // Sort axis values into ascending order to calculate gaps\n        valuesInAxis.sort(function (a, b) {\n          return a - b;\n        });\n        var min = null;\n        for (var j = 1; j < valuesInAxis.length; ++j) {\n          var delta = valuesInAxis[j] - valuesInAxis[j - 1];\n          if (delta > 0) {\n            // Ignore 0 delta because they are of the same axis value\n            min = min === null ? delta : Math.min(min, delta);\n          }\n        } // Set to null if only have one data\n\n        axisMinGaps[key] = min;\n      }\n    }\n  }\n  return axisMinGaps;\n}\nfunction makeColumnLayout(barSeries) {\n  var axisMinGaps = getValueAxesMinGaps(barSeries);\n  var seriesInfoList = [];\n  zrUtil.each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth;\n    if (baseAxis.type === 'category') {\n      bandWidth = baseAxis.getBandWidth();\n    } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {\n      var key = baseAxis.dim + '_' + baseAxis.index;\n      var minGap = axisMinGaps[key];\n      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);\n      var scale = baseAxis.scale.getExtent();\n      var scaleSpan = Math.abs(scale[1] - scale[0]);\n      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan; // When there is only one data value\n    } else {\n      var data = seriesModel.getData();\n      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    }\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barMinWidth = parsePercent(\n    // barMinWidth by default is 1 in cartesian. Because in value axis,\n    // the auto-calculated bar width might be less than 1.\n    seriesModel.get('barMinWidth') || 1, bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    seriesInfoList.push({\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barMinWidth: barMinWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    });\n  });\n  return doCalBarWidthAndOffset(seriesInfoList);\n}\nfunction doCalBarWidthAndOffset(seriesInfoList) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n\n    var barWidth = seriesInfo.barWidth;\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barMinWidth = seriesInfo.barMinWidth;\n    barMinWidth && (stacks[stackId].minWidth = barMinWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column) {\n      var maxWidth = column.maxWidth;\n      var minWidth = column.minWidth;\n      if (!column.width) {\n        var finalWidth = autoWidth;\n        if (maxWidth && maxWidth < finalWidth) {\n          finalWidth = Math.min(maxWidth, remainedWidth);\n        } // `minWidth` has higher priority. `minWidth` decide that wheter the\n        // bar is able to be visible. So `minWidth` should not be restricted\n        // by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In\n        // the extreme cases for `value` axis, bars are allowed to overlap\n        // with each other if `minWidth` specified.\n\n        if (minWidth && minWidth > finalWidth) {\n          finalWidth = minWidth;\n        }\n        if (finalWidth !== autoWidth) {\n          column.width = finalWidth;\n          remainedWidth -= finalWidth + barGapPercent * finalWidth;\n          autoWidthCount--;\n        }\n      } else {\n        // `barMinWidth/barMaxWidth` has higher priority than `barWidth`, as\n        // CSS does. Becuase barWidth can be a percent value, where\n        // `barMaxWidth` can be used to restrict the final width.\n        var finalWidth = column.width;\n        if (maxWidth) {\n          finalWidth = Math.min(finalWidth, maxWidth);\n        } // `minWidth` has higher priority, as described above\n\n        if (minWidth) {\n          finalWidth = Math.max(finalWidth, minWidth);\n        }\n        column.width = finalWidth;\n        remainedWidth -= finalWidth + barGapPercent * finalWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        bandWidth: bandWidth,\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {Object} barWidthAndOffset The result of makeColumnLayout\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Series} [seriesModel] If not provided, return all.\n * @return {Object} {stackId: {offset, width}} or {offset, width} if seriesModel provided.\n */\n\nfunction retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n  if (barWidthAndOffset && axis) {\n    var result = barWidthAndOffset[getAxisKey(axis)];\n    if (result != null && seriesModel != null) {\n      result = result[getSeriesStackId(seriesModel)];\n    }\n    return result;\n  }\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n */\n\nfunction layout(seriesType, ecModel) {\n  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n  var barWidthAndOffset = makeColumnLayout(seriesModels);\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  zrUtil.each(seriesModels, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      bandWidth: columnLayoutInfo.bandWidth,\n      offset: columnOffset,\n      size: columnWidth\n    });\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = isDimensionStacked(data, valueDim\n    /*, baseDim*/);\n\n    var isValueAxisH = valueAxis.isHorizontal();\n    var valueAxisStart = getValueAxisStart(baseAxis, valueAxis, stacked);\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n\n      if (stacked) {\n        // Only ordinal axis can be stacked.\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            // Positive stack\n            n: valueAxisStart // Negative stack\n          };\n        } // Should also consider #4243\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n      var x;\n      var y;\n      var width;\n      var height;\n      if (isValueAxisH) {\n        var coord = cartesian.dataToPoint([value, baseValue]);\n        x = baseCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - valueAxisStart;\n        height = columnWidth;\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        } // Ignore stack from NaN value\n\n        if (!isNaN(width)) {\n          stacked && (lastStackCoords[stackId][baseValue][sign] += width);\n        }\n      } else {\n        var coord = cartesian.dataToPoint([baseValue, value]);\n        x = coord[0] + columnOffset;\n        y = baseCoord;\n        width = columnWidth;\n        height = coord[1] - valueAxisStart;\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        } // Ignore stack from NaN value\n\n        if (!isNaN(height)) {\n          stacked && (lastStackCoords[stackId][baseValue][sign] += height);\n        }\n      }\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }\n  }, this);\n} // TODO: Do not support stack in large mode yet.\n\nvar largeLayout = {\n  seriesType: 'bar',\n  plan: createRenderPlanner(),\n  reset: function (seriesModel) {\n    if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {\n      return;\n    }\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var coordLayout = cartesian.grid.getRect();\n    var baseAxis = cartesian.getBaseAxis();\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var valueAxisHorizontal = valueAxis.isHorizontal();\n    var valueDimIdx = valueAxisHorizontal ? 0 : 1;\n    var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;\n    if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {\n      // jshint ignore:line\n      barWidth = LARGE_BAR_MIN_WIDTH;\n    }\n    return {\n      progress: progress\n    };\n    function progress(params, data) {\n      var count = params.count;\n      var largePoints = new LargeArr(count * 2);\n      var largeBackgroundPoints = new LargeArr(count * 2);\n      var largeDataIndices = new LargeArr(count);\n      var dataIndex;\n      var coord = [];\n      var valuePair = [];\n      var pointsOffset = 0;\n      var idxOffset = 0;\n      while ((dataIndex = params.next()) != null) {\n        valuePair[valueDimIdx] = data.get(valueDim, dataIndex);\n        valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);\n        coord = cartesian.dataToPoint(valuePair, null, coord); // Data index might not be in order, depends on `progressiveChunkMode`.\n\n        largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];\n        largePoints[pointsOffset++] = coord[0];\n        largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;\n        largePoints[pointsOffset++] = coord[1];\n        largeDataIndices[idxOffset++] = dataIndex;\n      }\n      data.setLayout({\n        largePoints: largePoints,\n        largeDataIndices: largeDataIndices,\n        largeBackgroundPoints: largeBackgroundPoints,\n        barWidth: barWidth,\n        valueAxisStart: getValueAxisStart(baseAxis, valueAxis, false),\n        backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,\n        valueAxisHorizontal: valueAxisHorizontal\n      });\n    }\n  }\n};\nfunction isOnCartesian(seriesModel) {\n  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n}\nfunction isInLargeMode(seriesModel) {\n  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n} // See cases in `test/bar-start.html` and `#7412`, `#8747`.\n\nfunction getValueAxisStart(baseAxis, valueAxis, stacked) {\n  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));\n}\nexports.getLayoutOnAxis = getLayoutOnAxis;\nexports.prepareLayoutBarSeries = prepareLayoutBarSeries;\nexports.makeColumnLayout = makeColumnLayout;\nexports.retrieveColumnLayout = retrieveColumnLayout;\nexports.layout = layout;\nexports.largeLayout = largeLayout;","map":{"version":3,"names":["zrUtil","require","_number","parsePercent","_dataStackHelper","isDimensionStacked","createRenderPlanner","STACK_PREFIX","LARGE_BAR_MIN_WIDTH","LargeArr","Float32Array","Array","getSeriesStackId","seriesModel","get","seriesIndex","getAxisKey","axis","dim","index","getLayoutOnAxis","opt","params","baseAxis","axisKey","type","bandWidth","getBandWidth","i","count","push","defaults","stackId","widthAndOffsets","doCalBarWidthAndOffset","result","item","offsetCenter","offset","width","prepareLayoutBarSeries","seriesType","ecModel","seriesModels","eachSeriesByType","isOnCartesian","isInLargeMode","getValueAxesMinGaps","barSeries","axisValues","each","cartesian","coordinateSystem","getBaseAxis","data","getData","key","mapDimension","cnt","value","axisMinGaps","hasOwnProperty","valuesInAxis","sort","a","b","min","j","length","delta","Math","makeColumnLayout","seriesInfoList","axisExtent","getExtent","minGap","extentSpan","abs","scale","scaleSpan","barWidth","barMaxWidth","barMinWidth","barGap","barCategoryGap","columnsMap","seriesInfo","idx","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","maxWidth","minWidth","coordSysName","barGapPercent","autoWidth","max","column","finalWidth","widthSum","lastColumn","retrieveColumnLayout","barWidthAndOffset","layout","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","valueAxis","getOtherAxis","barMinHeight","setLayout","size","valueDim","baseDim","stacked","isValueAxisH","isHorizontal","valueAxisStart","getValueAxisStart","len","baseValue","sign","baseCoord","p","n","x","y","height","coord","dataToPoint","isNaN","setItemLayout","largeLayout","plan","reset","coordLayout","grid","getRect","valueAxisHorizontal","valueDimIdx","progress","largePoints","largeBackgroundPoints","largeDataIndices","dataIndex","valuePair","pointsOffset","idxOffset","next","backgroundStart","pipelineContext","large","toGlobalCoord","dataToCoord","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/echarts/lib/layout/barGrid.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float32Array */\nvar STACK_PREFIX = '__ec_stack_';\nvar LARGE_BAR_MIN_WIDTH = 0.5;\nvar LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barMinWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction prepareLayoutBarSeries(seriesType, ecModel) {\n  var seriesModels = [];\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {\n      seriesModels.push(seriesModel);\n    }\n  });\n  return seriesModels;\n}\n/**\n * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent\n * values.\n * This works for time axes, value axes, and log axes.\n * For a single time axis, return value is in the form like\n * {'x_0': [1000000]}.\n * The value of 1000000 is in milliseconds.\n */\n\n\nfunction getValueAxesMinGaps(barSeries) {\n  /**\n   * Map from axis.index to values.\n   * For a single time axis, axisValues is in the form like\n   * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.\n   * Items in axisValues[x], e.g. 1495555200000, are time values of all\n   * series.\n   */\n  var axisValues = {};\n  zrUtil.each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n\n    if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var key = baseAxis.dim + '_' + baseAxis.index;\n    var dim = data.mapDimension(baseAxis.dim);\n\n    for (var i = 0, cnt = data.count(); i < cnt; ++i) {\n      var value = data.get(dim, i);\n\n      if (!axisValues[key]) {\n        // No previous data for the axis\n        axisValues[key] = [value];\n      } else {\n        // No value in previous series\n        axisValues[key].push(value);\n      } // Ignore duplicated time values in the same axis\n\n    }\n  });\n  var axisMinGaps = [];\n\n  for (var key in axisValues) {\n    if (axisValues.hasOwnProperty(key)) {\n      var valuesInAxis = axisValues[key];\n\n      if (valuesInAxis) {\n        // Sort axis values into ascending order to calculate gaps\n        valuesInAxis.sort(function (a, b) {\n          return a - b;\n        });\n        var min = null;\n\n        for (var j = 1; j < valuesInAxis.length; ++j) {\n          var delta = valuesInAxis[j] - valuesInAxis[j - 1];\n\n          if (delta > 0) {\n            // Ignore 0 delta because they are of the same axis value\n            min = min === null ? delta : Math.min(min, delta);\n          }\n        } // Set to null if only have one data\n\n\n        axisMinGaps[key] = min;\n      }\n    }\n  }\n\n  return axisMinGaps;\n}\n\nfunction makeColumnLayout(barSeries) {\n  var axisMinGaps = getValueAxesMinGaps(barSeries);\n  var seriesInfoList = [];\n  zrUtil.each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth;\n\n    if (baseAxis.type === 'category') {\n      bandWidth = baseAxis.getBandWidth();\n    } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {\n      var key = baseAxis.dim + '_' + baseAxis.index;\n      var minGap = axisMinGaps[key];\n      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);\n      var scale = baseAxis.scale.getExtent();\n      var scaleSpan = Math.abs(scale[1] - scale[0]);\n      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan; // When there is only one data value\n    } else {\n      var data = seriesModel.getData();\n      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    }\n\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barMinWidth = parsePercent( // barMinWidth by default is 1 in cartesian. Because in value axis,\n    // the auto-calculated bar width might be less than 1.\n    seriesModel.get('barMinWidth') || 1, bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    seriesInfoList.push({\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barMinWidth: barMinWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    });\n  });\n  return doCalBarWidthAndOffset(seriesInfoList);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barMinWidth = seriesInfo.barMinWidth;\n    barMinWidth && (stacks[stackId].minWidth = barMinWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column) {\n      var maxWidth = column.maxWidth;\n      var minWidth = column.minWidth;\n\n      if (!column.width) {\n        var finalWidth = autoWidth;\n\n        if (maxWidth && maxWidth < finalWidth) {\n          finalWidth = Math.min(maxWidth, remainedWidth);\n        } // `minWidth` has higher priority. `minWidth` decide that wheter the\n        // bar is able to be visible. So `minWidth` should not be restricted\n        // by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In\n        // the extreme cases for `value` axis, bars are allowed to overlap\n        // with each other if `minWidth` specified.\n\n\n        if (minWidth && minWidth > finalWidth) {\n          finalWidth = minWidth;\n        }\n\n        if (finalWidth !== autoWidth) {\n          column.width = finalWidth;\n          remainedWidth -= finalWidth + barGapPercent * finalWidth;\n          autoWidthCount--;\n        }\n      } else {\n        // `barMinWidth/barMaxWidth` has higher priority than `barWidth`, as\n        // CSS does. Becuase barWidth can be a percent value, where\n        // `barMaxWidth` can be used to restrict the final width.\n        var finalWidth = column.width;\n\n        if (maxWidth) {\n          finalWidth = Math.min(finalWidth, maxWidth);\n        } // `minWidth` has higher priority, as described above\n\n\n        if (minWidth) {\n          finalWidth = Math.max(finalWidth, minWidth);\n        }\n\n        column.width = finalWidth;\n        remainedWidth -= finalWidth + barGapPercent * finalWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        bandWidth: bandWidth,\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {Object} barWidthAndOffset The result of makeColumnLayout\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Series} [seriesModel] If not provided, return all.\n * @return {Object} {stackId: {offset, width}} or {offset, width} if seriesModel provided.\n */\n\n\nfunction retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n  if (barWidthAndOffset && axis) {\n    var result = barWidthAndOffset[getAxisKey(axis)];\n\n    if (result != null && seriesModel != null) {\n      result = result[getSeriesStackId(seriesModel)];\n    }\n\n    return result;\n  }\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction layout(seriesType, ecModel) {\n  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n  var barWidthAndOffset = makeColumnLayout(seriesModels);\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  zrUtil.each(seriesModels, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      bandWidth: columnLayoutInfo.bandWidth,\n      offset: columnOffset,\n      size: columnWidth\n    });\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = isDimensionStacked(data, valueDim\n    /*, baseDim*/\n    );\n    var isValueAxisH = valueAxis.isHorizontal();\n    var valueAxisStart = getValueAxisStart(baseAxis, valueAxis, stacked);\n\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n\n      if (stacked) {\n        // Only ordinal axis can be stacked.\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            // Positive stack\n            n: valueAxisStart // Negative stack\n\n          };\n        } // Should also consider #4243\n\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (isValueAxisH) {\n        var coord = cartesian.dataToPoint([value, baseValue]);\n        x = baseCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - valueAxisStart;\n        height = columnWidth;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        } // Ignore stack from NaN value\n\n\n        if (!isNaN(width)) {\n          stacked && (lastStackCoords[stackId][baseValue][sign] += width);\n        }\n      } else {\n        var coord = cartesian.dataToPoint([baseValue, value]);\n        x = coord[0] + columnOffset;\n        y = baseCoord;\n        width = columnWidth;\n        height = coord[1] - valueAxisStart;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        } // Ignore stack from NaN value\n\n\n        if (!isNaN(height)) {\n          stacked && (lastStackCoords[stackId][baseValue][sign] += height);\n        }\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }\n  }, this);\n} // TODO: Do not support stack in large mode yet.\n\n\nvar largeLayout = {\n  seriesType: 'bar',\n  plan: createRenderPlanner(),\n  reset: function (seriesModel) {\n    if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var coordLayout = cartesian.grid.getRect();\n    var baseAxis = cartesian.getBaseAxis();\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var valueAxisHorizontal = valueAxis.isHorizontal();\n    var valueDimIdx = valueAxisHorizontal ? 0 : 1;\n    var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;\n\n    if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {\n      // jshint ignore:line\n      barWidth = LARGE_BAR_MIN_WIDTH;\n    }\n\n    return {\n      progress: progress\n    };\n\n    function progress(params, data) {\n      var count = params.count;\n      var largePoints = new LargeArr(count * 2);\n      var largeBackgroundPoints = new LargeArr(count * 2);\n      var largeDataIndices = new LargeArr(count);\n      var dataIndex;\n      var coord = [];\n      var valuePair = [];\n      var pointsOffset = 0;\n      var idxOffset = 0;\n\n      while ((dataIndex = params.next()) != null) {\n        valuePair[valueDimIdx] = data.get(valueDim, dataIndex);\n        valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);\n        coord = cartesian.dataToPoint(valuePair, null, coord); // Data index might not be in order, depends on `progressiveChunkMode`.\n\n        largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];\n        largePoints[pointsOffset++] = coord[0];\n        largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;\n        largePoints[pointsOffset++] = coord[1];\n        largeDataIndices[idxOffset++] = dataIndex;\n      }\n\n      data.setLayout({\n        largePoints: largePoints,\n        largeDataIndices: largeDataIndices,\n        largeBackgroundPoints: largeBackgroundPoints,\n        barWidth: barWidth,\n        valueAxisStart: getValueAxisStart(baseAxis, valueAxis, false),\n        backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,\n        valueAxisHorizontal: valueAxisHorizontal\n      });\n    }\n  }\n};\n\nfunction isOnCartesian(seriesModel) {\n  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n}\n\nfunction isInLargeMode(seriesModel) {\n  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n} // See cases in `test/bar-start.html` and `#7412`, `#8747`.\n\n\nfunction getValueAxisStart(baseAxis, valueAxis, stacked) {\n  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));\n}\n\nexports.getLayoutOnAxis = getLayoutOnAxis;\nexports.prepareLayoutBarSeries = prepareLayoutBarSeries;\nexports.makeColumnLayout = makeColumnLayout;\nexports.retrieveColumnLayout = retrieveColumnLayout;\nexports.layout = layout;\nexports.largeLayout = largeLayout;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}