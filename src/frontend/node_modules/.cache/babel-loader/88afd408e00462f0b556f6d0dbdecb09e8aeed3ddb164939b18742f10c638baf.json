{"ast":null,"code":"require(\"core-js/modules/es.array.map.js\");\nrequire(\"core-js/modules/es.error.cause.js\");\nrequire(\"core-js/modules/es.error.to-string.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.function.name.js\");\nrequire(\"core-js/modules/es.array.slice.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\nvar __DEV__ = _config.__DEV__;\nvar _model = require(\"../../util/model\");\nvar makeInner = _model.makeInner;\nvar getDataItemValue = _model.getDataItemValue;\nvar _util = require(\"zrender/lib/core/util\");\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\nvar isTypedArray = _util.isTypedArray;\nvar isArrayLike = _util.isArrayLike;\nvar extend = _util.extend;\nvar assert = _util.assert;\nvar Source = require(\"../Source\");\nvar _sourceType = require(\"./sourceType\");\nvar SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;\nvar SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;\nvar SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;\nvar SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;\nvar SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;\nvar SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;\nvar SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// The result of `guessOrdinal`.\nvar BE_ORDINAL = {\n  Must: 1,\n  // Encounter string but not '-' and not number-like.\n  Might: 2,\n  // Encounter string but number-like.\n  Not: 3 // Other cases\n};\n\nvar inner = makeInner();\n/**\n * @see {module:echarts/data/Source}\n * @param {module:echarts/component/dataset/DatasetModel} datasetModel\n * @return {string} sourceFormat\n */\n\nfunction detectSourceFormat(datasetModel) {\n  var data = datasetModel.option.source;\n  var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n  if (isTypedArray(data)) {\n    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n  } else if (isArray(data)) {\n    // FIXME Whether tolerate null in top level array?\n    if (data.length === 0) {\n      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n    }\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n      if (item == null) {\n        continue;\n      } else if (isArray(item)) {\n        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        break;\n      } else if (isObject(item)) {\n        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n        break;\n      }\n    }\n  } else if (isObject(data)) {\n    for (var key in data) {\n      if (data.hasOwnProperty(key) && isArrayLike(data[key])) {\n        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n        break;\n      }\n    }\n  } else if (data != null) {\n    throw new Error('Invalid data');\n  }\n  inner(datasetModel).sourceFormat = sourceFormat;\n}\n/**\n * [Scenarios]:\n * (1) Provide source data directly:\n *     series: {\n *         encode: {...},\n *         dimensions: [...]\n *         seriesLayoutBy: 'row',\n *         data: [[...]]\n *     }\n * (2) Refer to datasetModel.\n *     series: [{\n *         encode: {...}\n *         // Ignore datasetIndex means `datasetIndex: 0`\n *         // and the dimensions defination in dataset is used\n *     }, {\n *         encode: {...},\n *         seriesLayoutBy: 'column',\n *         datasetIndex: 1\n *     }]\n *\n * Get data from series itself or datset.\n * @return {module:echarts/data/Source} source\n */\n\nfunction getSource(seriesModel) {\n  return inner(seriesModel).source;\n}\n/**\n * MUST be called before mergeOption of all series.\n * @param {module:echarts/model/Global} ecModel\n */\n\nfunction resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  inner(ecModel).datasetMap = createHashMap();\n}\n/**\n * [Caution]:\n * MUST be called after series option merged and\n * before \"series.getInitailData()\" called.\n *\n * [The rule of making default encode]:\n * Category axis (if exists) alway map to the first dimension.\n * Each other axis occupies a subsequent dimension.\n *\n * [Why make default encode]:\n * Simplify the typing of encode in option, avoiding the case like that:\n * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],\n * where the \"y\" have to be manually typed as \"1, 2, 3, ...\".\n *\n * @param {module:echarts/model/Series} seriesModel\n */\n\nfunction prepareSource(seriesModel) {\n  var seriesOption = seriesModel.option;\n  var data = seriesOption.data;\n  var sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n  var fromDataset = false;\n  var seriesLayoutBy = seriesOption.seriesLayoutBy;\n  var sourceHeader = seriesOption.sourceHeader;\n  var dimensionsDefine = seriesOption.dimensions;\n  var datasetModel = getDatasetModel(seriesModel);\n  if (datasetModel) {\n    var datasetOption = datasetModel.option;\n    data = datasetOption.source;\n    sourceFormat = inner(datasetModel).sourceFormat;\n    fromDataset = true; // These settings from series has higher priority.\n\n    seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;\n    sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);\n    dimensionsDefine = dimensionsDefine || datasetOption.dimensions;\n  }\n  var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine);\n  inner(seriesModel).source = new Source({\n    data: data,\n    fromDataset: fromDataset,\n    seriesLayoutBy: seriesLayoutBy,\n    sourceFormat: sourceFormat,\n    dimensionsDefine: completeResult.dimensionsDefine,\n    startIndex: completeResult.startIndex,\n    dimensionsDetectCount: completeResult.dimensionsDetectCount,\n    // Note: dataset option does not have `encode`.\n    encodeDefine: seriesOption.encode\n  });\n} // return {startIndex, dimensionsDefine, dimensionsCount}\n\nfunction completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)\n    };\n  }\n  var dimensionsDetectCount;\n  var startIndex;\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if (isString(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        } // 10 is an experience number, avoid long loop.\n      }, seriesLayoutBy, data, 10);\n    } else {\n      startIndex = sourceHeader ? 1 : 0;\n    }\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val : '';\n      }, seriesLayoutBy, data);\n    }\n    dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      each(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var value0 = getDataItemValue(data[0]);\n    dimensionsDetectCount = isArray(value0) && value0.length || 1;\n  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {}\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),\n    dimensionsDetectCount: dimensionsDetectCount\n  };\n} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefiend or string.\n\nfunction normalizeDimensionsDefine(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n  var nameMap = createHashMap();\n  return map(dimensionsDefine, function (item, index) {\n    item = extend({}, isObject(item) ? item : {\n      name: item\n    }); // User can set null in dimensions.\n    // We dont auto specify name, othewise a given name may\n    // cause it be refered unexpectedly.\n\n    if (item.name == null) {\n      return item;\n    } // Also consider number form like 2012.\n\n    item.name += ''; // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n    var exist = nameMap.get(item.name);\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n    return item;\n  });\n}\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  maxLoop == null && (maxLoop = Infinity);\n  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n\n  if (obj) {\n    var dimensions = [];\n    each(obj, function (value, key) {\n      dimensions.push(key);\n    });\n    return dimensions;\n  }\n}\n/**\n * [The strategy of the arrengment of data dimensions for dataset]:\n * \"value way\": all axes are non-category axes. So series one by one take\n *     several (the number is coordSysDims.length) dimensions from dataset.\n *     The result of data arrengment of data dimensions like:\n *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |\n * \"category way\": at least one axis is category axis. So the the first data\n *     dimension is always mapped to the first category axis and shared by\n *     all of the series. The other data dimensions are taken by series like\n *     \"value way\" does.\n *     The result of data arrengment of data dimensions like:\n *     | ser_shared_x | ser0_y | ser1_y | ser2_y |\n *\n * @param {Array.<Object|string>} coordDimensions [{name: <string>, type: <string>, dimsDef: <Array>}, ...]\n * @param {module:model/Series} seriesModel\n * @param {module:data/Source} source\n * @return {Object} encode Never be `null/undefined`.\n */\n\nfunction makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {\n  var encode = {};\n  var datasetModel = getDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.\n\n  if (!datasetModel || !coordDimensions) {\n    return encode;\n  }\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var ecModel = seriesModel.ecModel;\n  var datasetMap = inner(ecModel).datasetMap;\n  var key = datasetModel.uid + '_' + source.seriesLayoutBy;\n  var baseCategoryDimIndex;\n  var categoryWayValueDimStart;\n  coordDimensions = coordDimensions.slice();\n  each(coordDimensions, function (coordDimInfo, coordDimIdx) {\n    !isObject(coordDimInfo) && (coordDimensions[coordDimIdx] = {\n      name: coordDimInfo\n    });\n    if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {\n      baseCategoryDimIndex = coordDimIdx;\n      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimensions[coordDimIdx]);\n    }\n    encode[coordDimInfo.name] = [];\n  });\n  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n    categoryWayDim: categoryWayValueDimStart,\n    valueWayDim: 0\n  }); // TODO\n  // Auto detect first time axis and do arrangement.\n\n  each(coordDimensions, function (coordDimInfo, coordDimIdx) {\n    var coordDimName = coordDimInfo.name;\n    var count = getDataDimCountOnCoordDim(coordDimInfo); // In value way.\n\n    if (baseCategoryDimIndex == null) {\n      var start = datasetRecord.valueWayDim;\n      pushDim(encode[coordDimName], start, count);\n      pushDim(encodeSeriesName, start, count);\n      datasetRecord.valueWayDim += count; // ??? TODO give a better default series name rule?\n      // especially when encode x y specified.\n      // consider: when mutiple series share one dimension\n      // category axis, series name should better use\n      // the other dimsion name. On the other hand, use\n      // both dimensions name.\n    } // In category way, the first category axis.\n    else if (baseCategoryDimIndex === coordDimIdx) {\n      pushDim(encode[coordDimName], 0, count);\n      pushDim(encodeItemName, 0, count);\n    } // In category way, the other axis.\n    else {\n      var start = datasetRecord.categoryWayDim;\n      pushDim(encode[coordDimName], start, count);\n      pushDim(encodeSeriesName, start, count);\n      datasetRecord.categoryWayDim += count;\n    }\n  });\n  function pushDim(dimIdxArr, idxFrom, idxCount) {\n    for (var i = 0; i < idxCount; i++) {\n      dimIdxArr.push(idxFrom + i);\n    }\n  }\n  function getDataDimCountOnCoordDim(coordDimInfo) {\n    var dimsDef = coordDimInfo.dimsDef;\n    return dimsDef ? dimsDef.length : 1;\n  }\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * Work for data like [{name: ..., value: ...}, ...].\n *\n * @param {module:model/Series} seriesModel\n * @param {module:data/Source} source\n * @return {Object} encode Never be `null/undefined`.\n */\n\nfunction makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {\n  var encode = {};\n  var datasetModel = getDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.\n\n  if (!datasetModel) {\n    return encode;\n  }\n  var sourceFormat = source.sourceFormat;\n  var dimensionsDefine = source.dimensionsDefine;\n  var potentialNameDimIndex;\n  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    each(dimensionsDefine, function (dim, idx) {\n      if ((isObject(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  } // idxResult: {v, n}.\n\n  var idxResult = function () {\n    var idxRes0 = {};\n    var idxRes1 = {};\n    var guessRecords = []; // 5 is an experience value.\n\n    for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {\n      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);\n      guessRecords.push(guessResult);\n      var isPureNumber = guessResult === BE_ORDINAL.Not; // [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,\n      // and then find a name dim with the priority:\n      // \"BE_ORDINAL.Might|BE_ORDINAL.Must\" > \"other dim\" > \"the value dim itself\".\n\n      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {\n        idxRes0.v = i;\n      }\n      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {\n        idxRes0.n = i;\n      }\n      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {\n        return idxRes0;\n      } // [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),\n      // find the first BE_ORDINAL.Might as the value dim,\n      // and then find a name dim with the priority:\n      // \"other dim\" > \"the value dim itself\".\n      // That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be\n      // treated as number.\n\n      if (!isPureNumber) {\n        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {\n          idxRes1.v = i;\n        }\n        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {\n          idxRes1.n = i;\n        }\n      }\n    }\n    function fulfilled(idxResult) {\n      return idxResult.v != null && idxResult.n != null;\n    }\n    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;\n  }();\n  if (idxResult) {\n    encode.value = idxResult.v; // `potentialNameDimIndex` has highest priority.\n\n    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n; // By default, label use itemName in charts.\n    // So we dont set encodeLabel here.\n\n    encode.itemName = [nameDimIndex];\n    encode.seriesName = [nameDimIndex];\n  }\n  return encode;\n}\n/**\n * If return null/undefined, indicate that should not use datasetModel.\n */\n\nfunction getDatasetModel(seriesModel) {\n  var option = seriesModel.option; // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n\n  var thisData = option.data;\n  if (!thisData) {\n    return seriesModel.ecModel.getComponent('dataset', option.datasetIndex || 0);\n  }\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n *\n * @param {module:echars/data/Source} source\n * @param {number} dimIndex\n * @return {BE_ORDINAL} guess result.\n */\n\nfunction guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n} // dimIndex may be overflow source data.\n// return {BE_ORDINAL}\n\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result; // Experience value.\n\n  var maxLoop = 5;\n  if (isTypedArray(data)) {\n    return BE_ORDINAL.Not;\n  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n\n  var dimName;\n  var dimType;\n  if (dimensionsDefine) {\n    var dimDefItem = dimensionsDefine[dimIndex];\n    if (isObject(dimDefItem)) {\n      dimName = dimDefItem.name;\n      dimType = dimDefItem.type;\n    } else if (isString(dimDefItem)) {\n      dimName = dimDefItem;\n    }\n  }\n  if (dimType != null) {\n    return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not;\n  }\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n      var sample = data[dimIndex];\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < data.length && i < maxLoop; i++) {\n        var row = data[startIndex + i];\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n    var sample = data[dimName];\n    if (!sample || isTypedArray(sample)) {\n      return BE_ORDINAL.Not;\n    }\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n      var val = getDataItemValue(item);\n      if (!isArray(val)) {\n        return BE_ORDINAL.Not;\n      }\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n  function detectValue(val) {\n    var beStr = isString(val); // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n\n    if (val != null && isFinite(val) && val !== '') {\n      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;\n    } else if (beStr && val !== '-') {\n      return BE_ORDINAL.Must;\n    }\n  }\n  return BE_ORDINAL.Not;\n}\nexports.BE_ORDINAL = BE_ORDINAL;\nexports.detectSourceFormat = detectSourceFormat;\nexports.getSource = getSource;\nexports.resetSourceDefaulter = resetSourceDefaulter;\nexports.prepareSource = prepareSource;\nexports.makeSeriesEncodeForAxisCoordSys = makeSeriesEncodeForAxisCoordSys;\nexports.makeSeriesEncodeForNameBased = makeSeriesEncodeForNameBased;\nexports.guessOrdinal = guessOrdinal;","map":{"version":3,"names":["_config","require","__DEV__","_model","makeInner","getDataItemValue","_util","createHashMap","each","map","isArray","isString","isObject","isTypedArray","isArrayLike","extend","assert","Source","_sourceType","SOURCE_FORMAT_ORIGINAL","SOURCE_FORMAT_ARRAY_ROWS","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","SOURCE_FORMAT_UNKNOWN","SOURCE_FORMAT_TYPED_ARRAY","SERIES_LAYOUT_BY_ROW","BE_ORDINAL","Must","Might","Not","inner","detectSourceFormat","datasetModel","data","option","source","sourceFormat","length","i","len","item","key","hasOwnProperty","Error","getSource","seriesModel","resetSourceDefaulter","ecModel","datasetMap","prepareSource","seriesOption","fromDataset","seriesLayoutBy","sourceHeader","dimensionsDefine","dimensions","getDatasetModel","datasetOption","completeResult","completeBySourceData","startIndex","dimensionsDetectCount","encodeDefine","encode","normalizeDimensionsDefine","arrayRowsTravelFirst","val","index","objectRowsCollectDimensions","colArr","push","value0","nameMap","name","displayName","exist","get","set","count","cb","maxLoop","Infinity","firstIndex","obj","value","makeSeriesEncodeForAxisCoordSys","coordDimensions","encodeItemName","encodeSeriesName","uid","baseCategoryDimIndex","categoryWayValueDimStart","slice","coordDimInfo","coordDimIdx","type","getDataDimCountOnCoordDim","datasetRecord","categoryWayDim","valueWayDim","coordDimName","start","pushDim","dimIdxArr","idxFrom","idxCount","dimsDef","itemName","seriesName","makeSeriesEncodeForNameBased","dimCount","potentialNameDimIndex","dim","idx","idxResult","idxRes0","idxRes1","guessRecords","Math","min","guessResult","doGuessOrdinal","isPureNumber","v","n","fulfilled","nameDimIndex","thisData","getComponent","datasetIndex","guessOrdinal","dimIndex","result","dimName","dimType","dimDefItem","sample","detectValue","row","beStr","isFinite","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc/COMP90024-23S1-A2-Australia-Social-Media-Analytics/src/frontend/node_modules/echarts/lib/data/helper/sourceHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\nvar getDataItemValue = _model.getDataItemValue;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\nvar isTypedArray = _util.isTypedArray;\nvar isArrayLike = _util.isArrayLike;\nvar extend = _util.extend;\nvar assert = _util.assert;\n\nvar Source = require(\"../Source\");\n\nvar _sourceType = require(\"./sourceType\");\n\nvar SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;\nvar SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;\nvar SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;\nvar SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;\nvar SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;\nvar SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;\nvar SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// The result of `guessOrdinal`.\nvar BE_ORDINAL = {\n  Must: 1,\n  // Encounter string but not '-' and not number-like.\n  Might: 2,\n  // Encounter string but number-like.\n  Not: 3 // Other cases\n\n};\nvar inner = makeInner();\n/**\n * @see {module:echarts/data/Source}\n * @param {module:echarts/component/dataset/DatasetModel} datasetModel\n * @return {string} sourceFormat\n */\n\nfunction detectSourceFormat(datasetModel) {\n  var data = datasetModel.option.source;\n  var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n\n  if (isTypedArray(data)) {\n    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n  } else if (isArray(data)) {\n    // FIXME Whether tolerate null in top level array?\n    if (data.length === 0) {\n      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n    }\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n\n      if (item == null) {\n        continue;\n      } else if (isArray(item)) {\n        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        break;\n      } else if (isObject(item)) {\n        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n        break;\n      }\n    }\n  } else if (isObject(data)) {\n    for (var key in data) {\n      if (data.hasOwnProperty(key) && isArrayLike(data[key])) {\n        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n        break;\n      }\n    }\n  } else if (data != null) {\n    throw new Error('Invalid data');\n  }\n\n  inner(datasetModel).sourceFormat = sourceFormat;\n}\n/**\n * [Scenarios]:\n * (1) Provide source data directly:\n *     series: {\n *         encode: {...},\n *         dimensions: [...]\n *         seriesLayoutBy: 'row',\n *         data: [[...]]\n *     }\n * (2) Refer to datasetModel.\n *     series: [{\n *         encode: {...}\n *         // Ignore datasetIndex means `datasetIndex: 0`\n *         // and the dimensions defination in dataset is used\n *     }, {\n *         encode: {...},\n *         seriesLayoutBy: 'column',\n *         datasetIndex: 1\n *     }]\n *\n * Get data from series itself or datset.\n * @return {module:echarts/data/Source} source\n */\n\n\nfunction getSource(seriesModel) {\n  return inner(seriesModel).source;\n}\n/**\n * MUST be called before mergeOption of all series.\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  inner(ecModel).datasetMap = createHashMap();\n}\n/**\n * [Caution]:\n * MUST be called after series option merged and\n * before \"series.getInitailData()\" called.\n *\n * [The rule of making default encode]:\n * Category axis (if exists) alway map to the first dimension.\n * Each other axis occupies a subsequent dimension.\n *\n * [Why make default encode]:\n * Simplify the typing of encode in option, avoiding the case like that:\n * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],\n * where the \"y\" have to be manually typed as \"1, 2, 3, ...\".\n *\n * @param {module:echarts/model/Series} seriesModel\n */\n\n\nfunction prepareSource(seriesModel) {\n  var seriesOption = seriesModel.option;\n  var data = seriesOption.data;\n  var sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n  var fromDataset = false;\n  var seriesLayoutBy = seriesOption.seriesLayoutBy;\n  var sourceHeader = seriesOption.sourceHeader;\n  var dimensionsDefine = seriesOption.dimensions;\n  var datasetModel = getDatasetModel(seriesModel);\n\n  if (datasetModel) {\n    var datasetOption = datasetModel.option;\n    data = datasetOption.source;\n    sourceFormat = inner(datasetModel).sourceFormat;\n    fromDataset = true; // These settings from series has higher priority.\n\n    seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;\n    sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);\n    dimensionsDefine = dimensionsDefine || datasetOption.dimensions;\n  }\n\n  var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine);\n  inner(seriesModel).source = new Source({\n    data: data,\n    fromDataset: fromDataset,\n    seriesLayoutBy: seriesLayoutBy,\n    sourceFormat: sourceFormat,\n    dimensionsDefine: completeResult.dimensionsDefine,\n    startIndex: completeResult.startIndex,\n    dimensionsDetectCount: completeResult.dimensionsDetectCount,\n    // Note: dataset option does not have `encode`.\n    encodeDefine: seriesOption.encode\n  });\n} // return {startIndex, dimensionsDefine, dimensionsCount}\n\n\nfunction completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)\n    };\n  }\n\n  var dimensionsDetectCount;\n  var startIndex;\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if (isString(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        } // 10 is an experience number, avoid long loop.\n\n      }, seriesLayoutBy, data, 10);\n    } else {\n      startIndex = sourceHeader ? 1 : 0;\n    }\n\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val : '';\n      }, seriesLayoutBy, data);\n    }\n\n    dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      each(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var value0 = getDataItemValue(data[0]);\n    dimensionsDetectCount = isArray(value0) && value0.length || 1;\n  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {}\n\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),\n    dimensionsDetectCount: dimensionsDetectCount\n  };\n} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefiend or string.\n\n\nfunction normalizeDimensionsDefine(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n\n  var nameMap = createHashMap();\n  return map(dimensionsDefine, function (item, index) {\n    item = extend({}, isObject(item) ? item : {\n      name: item\n    }); // User can set null in dimensions.\n    // We dont auto specify name, othewise a given name may\n    // cause it be refered unexpectedly.\n\n    if (item.name == null) {\n      return item;\n    } // Also consider number form like 2012.\n\n\n    item.name += ''; // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n\n    var exist = nameMap.get(item.name);\n\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n\n    return item;\n  });\n}\n\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  maxLoop == null && (maxLoop = Infinity);\n\n  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\n\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n\n\n  if (obj) {\n    var dimensions = [];\n    each(obj, function (value, key) {\n      dimensions.push(key);\n    });\n    return dimensions;\n  }\n}\n/**\n * [The strategy of the arrengment of data dimensions for dataset]:\n * \"value way\": all axes are non-category axes. So series one by one take\n *     several (the number is coordSysDims.length) dimensions from dataset.\n *     The result of data arrengment of data dimensions like:\n *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |\n * \"category way\": at least one axis is category axis. So the the first data\n *     dimension is always mapped to the first category axis and shared by\n *     all of the series. The other data dimensions are taken by series like\n *     \"value way\" does.\n *     The result of data arrengment of data dimensions like:\n *     | ser_shared_x | ser0_y | ser1_y | ser2_y |\n *\n * @param {Array.<Object|string>} coordDimensions [{name: <string>, type: <string>, dimsDef: <Array>}, ...]\n * @param {module:model/Series} seriesModel\n * @param {module:data/Source} source\n * @return {Object} encode Never be `null/undefined`.\n */\n\n\nfunction makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {\n  var encode = {};\n  var datasetModel = getDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.\n\n  if (!datasetModel || !coordDimensions) {\n    return encode;\n  }\n\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var ecModel = seriesModel.ecModel;\n  var datasetMap = inner(ecModel).datasetMap;\n  var key = datasetModel.uid + '_' + source.seriesLayoutBy;\n  var baseCategoryDimIndex;\n  var categoryWayValueDimStart;\n  coordDimensions = coordDimensions.slice();\n  each(coordDimensions, function (coordDimInfo, coordDimIdx) {\n    !isObject(coordDimInfo) && (coordDimensions[coordDimIdx] = {\n      name: coordDimInfo\n    });\n\n    if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {\n      baseCategoryDimIndex = coordDimIdx;\n      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimensions[coordDimIdx]);\n    }\n\n    encode[coordDimInfo.name] = [];\n  });\n  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n    categoryWayDim: categoryWayValueDimStart,\n    valueWayDim: 0\n  }); // TODO\n  // Auto detect first time axis and do arrangement.\n\n  each(coordDimensions, function (coordDimInfo, coordDimIdx) {\n    var coordDimName = coordDimInfo.name;\n    var count = getDataDimCountOnCoordDim(coordDimInfo); // In value way.\n\n    if (baseCategoryDimIndex == null) {\n      var start = datasetRecord.valueWayDim;\n      pushDim(encode[coordDimName], start, count);\n      pushDim(encodeSeriesName, start, count);\n      datasetRecord.valueWayDim += count; // ??? TODO give a better default series name rule?\n      // especially when encode x y specified.\n      // consider: when mutiple series share one dimension\n      // category axis, series name should better use\n      // the other dimsion name. On the other hand, use\n      // both dimensions name.\n    } // In category way, the first category axis.\n    else if (baseCategoryDimIndex === coordDimIdx) {\n        pushDim(encode[coordDimName], 0, count);\n        pushDim(encodeItemName, 0, count);\n      } // In category way, the other axis.\n      else {\n          var start = datasetRecord.categoryWayDim;\n          pushDim(encode[coordDimName], start, count);\n          pushDim(encodeSeriesName, start, count);\n          datasetRecord.categoryWayDim += count;\n        }\n  });\n\n  function pushDim(dimIdxArr, idxFrom, idxCount) {\n    for (var i = 0; i < idxCount; i++) {\n      dimIdxArr.push(idxFrom + i);\n    }\n  }\n\n  function getDataDimCountOnCoordDim(coordDimInfo) {\n    var dimsDef = coordDimInfo.dimsDef;\n    return dimsDef ? dimsDef.length : 1;\n  }\n\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * Work for data like [{name: ..., value: ...}, ...].\n *\n * @param {module:model/Series} seriesModel\n * @param {module:data/Source} source\n * @return {Object} encode Never be `null/undefined`.\n */\n\n\nfunction makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {\n  var encode = {};\n  var datasetModel = getDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.\n\n  if (!datasetModel) {\n    return encode;\n  }\n\n  var sourceFormat = source.sourceFormat;\n  var dimensionsDefine = source.dimensionsDefine;\n  var potentialNameDimIndex;\n\n  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    each(dimensionsDefine, function (dim, idx) {\n      if ((isObject(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  } // idxResult: {v, n}.\n\n\n  var idxResult = function () {\n    var idxRes0 = {};\n    var idxRes1 = {};\n    var guessRecords = []; // 5 is an experience value.\n\n    for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {\n      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);\n      guessRecords.push(guessResult);\n      var isPureNumber = guessResult === BE_ORDINAL.Not; // [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,\n      // and then find a name dim with the priority:\n      // \"BE_ORDINAL.Might|BE_ORDINAL.Must\" > \"other dim\" > \"the value dim itself\".\n\n      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {\n        idxRes0.v = i;\n      }\n\n      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {\n        idxRes0.n = i;\n      }\n\n      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {\n        return idxRes0;\n      } // [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),\n      // find the first BE_ORDINAL.Might as the value dim,\n      // and then find a name dim with the priority:\n      // \"other dim\" > \"the value dim itself\".\n      // That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be\n      // treated as number.\n\n\n      if (!isPureNumber) {\n        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {\n          idxRes1.v = i;\n        }\n\n        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {\n          idxRes1.n = i;\n        }\n      }\n    }\n\n    function fulfilled(idxResult) {\n      return idxResult.v != null && idxResult.n != null;\n    }\n\n    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;\n  }();\n\n  if (idxResult) {\n    encode.value = idxResult.v; // `potentialNameDimIndex` has highest priority.\n\n    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n; // By default, label use itemName in charts.\n    // So we dont set encodeLabel here.\n\n    encode.itemName = [nameDimIndex];\n    encode.seriesName = [nameDimIndex];\n  }\n\n  return encode;\n}\n/**\n * If return null/undefined, indicate that should not use datasetModel.\n */\n\n\nfunction getDatasetModel(seriesModel) {\n  var option = seriesModel.option; // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n\n  var thisData = option.data;\n\n  if (!thisData) {\n    return seriesModel.ecModel.getComponent('dataset', option.datasetIndex || 0);\n  }\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n *\n * @param {module:echars/data/Source} source\n * @param {number} dimIndex\n * @return {BE_ORDINAL} guess result.\n */\n\n\nfunction guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n} // dimIndex may be overflow source data.\n// return {BE_ORDINAL}\n\n\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result; // Experience value.\n\n  var maxLoop = 5;\n\n  if (isTypedArray(data)) {\n    return BE_ORDINAL.Not;\n  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n\n\n  var dimName;\n  var dimType;\n\n  if (dimensionsDefine) {\n    var dimDefItem = dimensionsDefine[dimIndex];\n\n    if (isObject(dimDefItem)) {\n      dimName = dimDefItem.name;\n      dimType = dimDefItem.type;\n    } else if (isString(dimDefItem)) {\n      dimName = dimDefItem;\n    }\n  }\n\n  if (dimType != null) {\n    return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not;\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n      var sample = data[dimIndex];\n\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < data.length && i < maxLoop; i++) {\n        var row = data[startIndex + i];\n\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n\n    var sample = data[dimName];\n\n    if (!sample || isTypedArray(sample)) {\n      return BE_ORDINAL.Not;\n    }\n\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n      var val = getDataItemValue(item);\n\n      if (!isArray(val)) {\n        return BE_ORDINAL.Not;\n      }\n\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n\n  function detectValue(val) {\n    var beStr = isString(val); // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n\n    if (val != null && isFinite(val) && val !== '') {\n      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;\n    } else if (beStr && val !== '-') {\n      return BE_ORDINAL.Must;\n    }\n  }\n\n  return BE_ORDINAL.Not;\n}\n\nexports.BE_ORDINAL = BE_ORDINAL;\nexports.detectSourceFormat = detectSourceFormat;\nexports.getSource = getSource;\nexports.resetSourceDefaulter = resetSourceDefaulter;\nexports.prepareSource = prepareSource;\nexports.makeSeriesEncodeForAxisCoordSys = makeSeriesEncodeForAxisCoordSys;\nexports.makeSeriesEncodeForNameBased = makeSeriesEncodeForNameBased;\nexports.guessOrdinal = guessOrdinal;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}