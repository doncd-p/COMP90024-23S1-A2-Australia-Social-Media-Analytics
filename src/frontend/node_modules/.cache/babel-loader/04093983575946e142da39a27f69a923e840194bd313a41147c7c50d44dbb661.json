{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nvar BoundingRect = require(\"../core/BoundingRect\");\nvar imageHelper = require(\"../graphic/helper/image\");\nvar _util = require(\"../core/util\");\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar trim = _util.trim;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);\n}\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);\n  var outerWidth = getWidth(text, font);\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding,\n    textLineHeight: textLineHeight\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n  return y;\n}\n/**\n * Follow same interface to `Displayable.prototype.calculateTextPosition`.\n * @public\n * @param {Obejct} [out] Prepared out object. If not input, auto created in the method.\n * @param {module:zrender/graphic/Style} style where `textPosition` and `textDistance` are visited.\n * @param {Object} rect {x, y, width, height} Rect of the host elment, according to which the text positioned.\n * @return {Object} The input `out`. Set: {x, y, textAlign, textVerticalAlign}\n */\n\nfunction calculateTextPosition(out, style, rect) {\n  var textPosition = style.textPosition;\n  var distance = style.textDistance;\n  var x = rect.x;\n  var y = rect.y;\n  distance = distance || 0;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n  out = out || {};\n  out.x = x;\n  out.y = y;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n/**\n * To be removed. But still do not remove in case that some one has imported it.\n * @deprecated\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var dummyStyle = {\n    textPosition: textPosition,\n    textDistance: distance\n  };\n  return calculateTextPosition({}, dummyStyle, rect);\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n  return textLines.join('\\n');\n}\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n  var ellipsisWidth = getWidth(ellipsis, font);\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n  if (!containerWidth) {\n    return '';\n  }\n  var lineWidth = getWidth(textLine, font);\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n  return textLine;\n}\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight, canCacheByTextString}\n *  Notice: for performance, do not calculate outerWidth util needed.\n *  `canCacheByTextString` means the result `lines` is only determined by the input `text`.\n *  Thus we can simply comparing the `input` text to determin whether the result changed,\n *  without travel the result `lines`.\n */\n\nfunction parsePlainText(text, font, padding, textLineHeight, truncate) {\n  text != null && (text += '');\n  var lineHeight = retrieve2(textLineHeight, getLineHeight(font));\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n  var canCacheByTextString = true;\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n  if (text && truncate) {\n    canCacheByTextString = false;\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight,\n    canCacheByTextString: canCacheByTextString\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n  if (!text) {\n    return contentBlock;\n  }\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2(\n      // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n  return contentBlock;\n}\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token :\n      // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n      // If there is '', insert it as a placeholder.\n      lines.push({\n        tokens: [token]\n      });\n    }\n  }\n}\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px',\n  // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ');\n  return font && trim(font) || style.textFont || style.font;\n}\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.calculateTextPosition = calculateTextPosition;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;","map":{"version":3,"names":["BoundingRect","require","imageHelper","_util","getContext","extend","retrieve2","retrieve3","trim","textWidthCache","textWidthCacheCounter","TEXT_CACHE_MAX","STYLE_REG","DEFAULT_FONT","methods","$override","name","fn","getWidth","text","font","key","textLines","split","width","i","l","length","Math","max","measureText","getBoundingRect","textAlign","textVerticalAlign","textPadding","textLineHeight","rich","truncate","getRichTextRect","getPlainTextRect","contentBlock","parsePlainText","outerWidth","outerHeight","x","adjustTextX","y","adjustTextY","rect","lineHeight","parseRichText","height","calculateTextPosition","out","style","textPosition","distance","textDistance","halfHeight","adjustTextPositionOnRect","dummyStyle","truncateText","containerWidth","ellipsis","options","prepareTruncateOptions","len","truncateSingleLine","join","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","lineWidth","j","subLength","estimateLength","floor","substr","charCode","charCodeAt","getLineHeight","ctx","padding","lines","canCacheByTextString","truncOuterHeight","truncOuterWidth","lastIndex","result","exec","matchedIndex","index","pushTokens","substring","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","line","tokens","token","tokenStyle","styleName","tokenHeight","textHeight","textWidth","tokenWidth","tokenWidthNotSpecified","charAt","percentWidth","push","textBackgroundColor","bgImg","image","findExistImage","isImageReady","paddingW","remianTruncWidth","parseInt","block","str","isEmptyStr","strs","isLineHolder","tokensLen","makeFont","fontSize","fontFamily","fontStyle","fontWeight","textFont","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/zrender/lib/contain/text.js"],"sourcesContent":["var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar trim = _util.trim;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding,\n    textLineHeight: textLineHeight\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * Follow same interface to `Displayable.prototype.calculateTextPosition`.\n * @public\n * @param {Obejct} [out] Prepared out object. If not input, auto created in the method.\n * @param {module:zrender/graphic/Style} style where `textPosition` and `textDistance` are visited.\n * @param {Object} rect {x, y, width, height} Rect of the host elment, according to which the text positioned.\n * @return {Object} The input `out`. Set: {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction calculateTextPosition(out, style, rect) {\n  var textPosition = style.textPosition;\n  var distance = style.textDistance;\n  var x = rect.x;\n  var y = rect.y;\n  distance = distance || 0;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  out = out || {};\n  out.x = x;\n  out.y = y;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n/**\n * To be removed. But still do not remove in case that some one has imported it.\n * @deprecated\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var dummyStyle = {\n    textPosition: textPosition,\n    textDistance: distance\n  };\n  return calculateTextPosition({}, dummyStyle, rect);\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis, font);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight, canCacheByTextString}\n *  Notice: for performance, do not calculate outerWidth util needed.\n *  `canCacheByTextString` means the result `lines` is only determined by the input `text`.\n *  Thus we can simply comparing the `input` text to determin whether the result changed,\n *  without travel the result `lines`.\n */\n\n\nfunction parsePlainText(text, font, padding, textLineHeight, truncate) {\n  text != null && (text += '');\n  var lineHeight = retrieve2(textLineHeight, getLineHeight(font));\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n  var canCacheByTextString = true;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    canCacheByTextString = false;\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight,\n    canCacheByTextString: canCacheByTextString\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ');\n  return font && trim(font) || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.calculateTextPosition = calculateTextPosition;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}