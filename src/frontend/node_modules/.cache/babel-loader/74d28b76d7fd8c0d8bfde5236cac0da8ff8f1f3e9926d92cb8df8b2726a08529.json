{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar _clazz = require(\"./clazz\");\nvar parseClassType = _clazz.parseClassType;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar base = 0;\n/**\n * @public\n * @param {string} type\n * @return {string}\n */\n\nfunction getUID(type) {\n  // Considering the case of crossing js context,\n  // use Math.random to make id as unique as possible.\n  return [type || '', base++, Math.random().toFixed(5)].join('_');\n}\n/**\n * @inner\n */\n\nfunction enableSubTypeDefaulter(entity) {\n  var subTypeDefaulters = {};\n  entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n    componentType = parseClassType(componentType);\n    subTypeDefaulters[componentType.main] = defaulter;\n  };\n  entity.determineSubType = function (componentType, option) {\n    var type = option.type;\n    if (!type) {\n      var componentTypeMain = parseClassType(componentType).main;\n      if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n        type = subTypeDefaulters[componentTypeMain](option);\n      }\n    }\n    return type;\n  };\n  return entity;\n}\n/**\n * Topological travel on Activity Network (Activity On Vertices).\n * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n *\n * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n *\n * If there is circle dependencey, Error will be thrown.\n *\n */\n\nfunction enableTopologicalTravel(entity, dependencyGetter) {\n  /**\n   * @public\n   * @param {Array.<string>} targetNameList Target Component type list.\n   *                                           Can be ['aa', 'bb', 'aa.xx']\n   * @param {Array.<string>} fullNameList By which we can build dependency graph.\n   * @param {Function} callback Params: componentType, dependencies.\n   * @param {Object} context Scope of callback.\n   */\n  entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n    if (!targetNameList.length) {\n      return;\n    }\n    var result = makeDepndencyGraph(fullNameList);\n    var graph = result.graph;\n    var stack = result.noEntryList;\n    var targetNameSet = {};\n    zrUtil.each(targetNameList, function (name) {\n      targetNameSet[name] = true;\n    });\n    while (stack.length) {\n      var currComponentType = stack.pop();\n      var currVertex = graph[currComponentType];\n      var isInTargetNameSet = !!targetNameSet[currComponentType];\n      if (isInTargetNameSet) {\n        callback.call(context, currComponentType, currVertex.originalDeps.slice());\n        delete targetNameSet[currComponentType];\n      }\n      zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n    }\n    zrUtil.each(targetNameSet, function () {\n      throw new Error('Circle dependency may exists');\n    });\n    function removeEdge(succComponentType) {\n      graph[succComponentType].entryCount--;\n      if (graph[succComponentType].entryCount === 0) {\n        stack.push(succComponentType);\n      }\n    } // Consider this case: legend depends on series, and we call\n    // chart.setOption({series: [...]}), where only series is in option.\n    // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n    // not be called, but only sereis.mergeOption is called. Thus legend\n    // have no chance to update its local record about series (like which\n    // name of series is available in legend).\n\n    function removeEdgeAndAdd(succComponentType) {\n      targetNameSet[succComponentType] = true;\n      removeEdge(succComponentType);\n    }\n  };\n  /**\n   * DepndencyGraph: {Object}\n   * key: conponentType,\n   * value: {\n   *     successor: [conponentTypes...],\n   *     originalDeps: [conponentTypes...],\n   *     entryCount: {number}\n   * }\n   */\n\n  function makeDepndencyGraph(fullNameList) {\n    var graph = {};\n    var noEntryList = [];\n    zrUtil.each(fullNameList, function (name) {\n      var thisItem = createDependencyGraphItem(graph, name);\n      var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n      thisItem.entryCount = availableDeps.length;\n      if (thisItem.entryCount === 0) {\n        noEntryList.push(name);\n      }\n      zrUtil.each(availableDeps, function (dependentName) {\n        if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n          thisItem.predecessor.push(dependentName);\n        }\n        var thatItem = createDependencyGraphItem(graph, dependentName);\n        if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n          thatItem.successor.push(name);\n        }\n      });\n    });\n    return {\n      graph: graph,\n      noEntryList: noEntryList\n    };\n  }\n  function createDependencyGraphItem(graph, name) {\n    if (!graph[name]) {\n      graph[name] = {\n        predecessor: [],\n        successor: []\n      };\n    }\n    return graph[name];\n  }\n  function getAvailableDependencies(originalDeps, fullNameList) {\n    var availableDeps = [];\n    zrUtil.each(originalDeps, function (dep) {\n      zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n    });\n    return availableDeps;\n  }\n}\nexports.getUID = getUID;\nexports.enableSubTypeDefaulter = enableSubTypeDefaulter;\nexports.enableTopologicalTravel = enableTopologicalTravel;","map":{"version":3,"names":["zrUtil","require","_clazz","parseClassType","base","getUID","type","Math","random","toFixed","join","enableSubTypeDefaulter","entity","subTypeDefaulters","registerSubTypeDefaulter","componentType","defaulter","main","determineSubType","option","componentTypeMain","hasSubTypes","enableTopologicalTravel","dependencyGetter","topologicalTravel","targetNameList","fullNameList","callback","context","length","result","makeDepndencyGraph","graph","stack","noEntryList","targetNameSet","each","name","currComponentType","pop","currVertex","isInTargetNameSet","call","originalDeps","slice","successor","removeEdgeAndAdd","removeEdge","Error","succComponentType","entryCount","push","thisItem","createDependencyGraphItem","availableDeps","getAvailableDependencies","dependentName","indexOf","predecessor","thatItem","dep","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/echarts/lib/util/component.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _clazz = require(\"./clazz\");\n\nvar parseClassType = _clazz.parseClassType;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar base = 0;\n/**\n * @public\n * @param {string} type\n * @return {string}\n */\n\nfunction getUID(type) {\n  // Considering the case of crossing js context,\n  // use Math.random to make id as unique as possible.\n  return [type || '', base++, Math.random().toFixed(5)].join('_');\n}\n/**\n * @inner\n */\n\n\nfunction enableSubTypeDefaulter(entity) {\n  var subTypeDefaulters = {};\n\n  entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n    componentType = parseClassType(componentType);\n    subTypeDefaulters[componentType.main] = defaulter;\n  };\n\n  entity.determineSubType = function (componentType, option) {\n    var type = option.type;\n\n    if (!type) {\n      var componentTypeMain = parseClassType(componentType).main;\n\n      if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n        type = subTypeDefaulters[componentTypeMain](option);\n      }\n    }\n\n    return type;\n  };\n\n  return entity;\n}\n/**\n * Topological travel on Activity Network (Activity On Vertices).\n * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n *\n * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n *\n * If there is circle dependencey, Error will be thrown.\n *\n */\n\n\nfunction enableTopologicalTravel(entity, dependencyGetter) {\n  /**\n   * @public\n   * @param {Array.<string>} targetNameList Target Component type list.\n   *                                           Can be ['aa', 'bb', 'aa.xx']\n   * @param {Array.<string>} fullNameList By which we can build dependency graph.\n   * @param {Function} callback Params: componentType, dependencies.\n   * @param {Object} context Scope of callback.\n   */\n  entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n    if (!targetNameList.length) {\n      return;\n    }\n\n    var result = makeDepndencyGraph(fullNameList);\n    var graph = result.graph;\n    var stack = result.noEntryList;\n    var targetNameSet = {};\n    zrUtil.each(targetNameList, function (name) {\n      targetNameSet[name] = true;\n    });\n\n    while (stack.length) {\n      var currComponentType = stack.pop();\n      var currVertex = graph[currComponentType];\n      var isInTargetNameSet = !!targetNameSet[currComponentType];\n\n      if (isInTargetNameSet) {\n        callback.call(context, currComponentType, currVertex.originalDeps.slice());\n        delete targetNameSet[currComponentType];\n      }\n\n      zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n    }\n\n    zrUtil.each(targetNameSet, function () {\n      throw new Error('Circle dependency may exists');\n    });\n\n    function removeEdge(succComponentType) {\n      graph[succComponentType].entryCount--;\n\n      if (graph[succComponentType].entryCount === 0) {\n        stack.push(succComponentType);\n      }\n    } // Consider this case: legend depends on series, and we call\n    // chart.setOption({series: [...]}), where only series is in option.\n    // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n    // not be called, but only sereis.mergeOption is called. Thus legend\n    // have no chance to update its local record about series (like which\n    // name of series is available in legend).\n\n\n    function removeEdgeAndAdd(succComponentType) {\n      targetNameSet[succComponentType] = true;\n      removeEdge(succComponentType);\n    }\n  };\n  /**\n   * DepndencyGraph: {Object}\n   * key: conponentType,\n   * value: {\n   *     successor: [conponentTypes...],\n   *     originalDeps: [conponentTypes...],\n   *     entryCount: {number}\n   * }\n   */\n\n\n  function makeDepndencyGraph(fullNameList) {\n    var graph = {};\n    var noEntryList = [];\n    zrUtil.each(fullNameList, function (name) {\n      var thisItem = createDependencyGraphItem(graph, name);\n      var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n      thisItem.entryCount = availableDeps.length;\n\n      if (thisItem.entryCount === 0) {\n        noEntryList.push(name);\n      }\n\n      zrUtil.each(availableDeps, function (dependentName) {\n        if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n          thisItem.predecessor.push(dependentName);\n        }\n\n        var thatItem = createDependencyGraphItem(graph, dependentName);\n\n        if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n          thatItem.successor.push(name);\n        }\n      });\n    });\n    return {\n      graph: graph,\n      noEntryList: noEntryList\n    };\n  }\n\n  function createDependencyGraphItem(graph, name) {\n    if (!graph[name]) {\n      graph[name] = {\n        predecessor: [],\n        successor: []\n      };\n    }\n\n    return graph[name];\n  }\n\n  function getAvailableDependencies(originalDeps, fullNameList) {\n    var availableDeps = [];\n    zrUtil.each(originalDeps, function (dep) {\n      zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n    });\n    return availableDeps;\n  }\n}\n\nexports.getUID = getUID;\nexports.enableSubTypeDefaulter = enableSubTypeDefaulter;\nexports.enableTopologicalTravel = enableTopologicalTravel;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}