{"ast":null,"code":"require(\"core-js/modules/esnext.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/esnext.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/esnext.typed-array.with.js\");\nvar curve = require(\"./curve\");\nvar vec2 = require(\"./vector\");\nvar bbox = require(\"./bbox\");\nvar BoundingRect = require(\"./BoundingRect\");\nvar _config = require(\"../config\");\nvar dpr = _config.devicePixelRatio;\n\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n// TODO getTotalLength, getPointAtLength\n\n/* global Float32Array */\nvar CMD = {\n  M: 1,\n  L: 2,\n  C: 3,\n  Q: 4,\n  A: 5,\n  Z: 6,\n  // Rect\n  R: 7\n}; // var CMD_MEM_SIZE = {\n//     M: 3,\n//     L: 3,\n//     C: 7,\n//     Q: 5,\n//     A: 9,\n//     R: 5,\n//     Z: 1\n// };\n\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathCos = Math.cos;\nvar mathSin = Math.sin;\nvar mathSqrt = Math.sqrt;\nvar mathAbs = Math.abs;\nvar hasTypedArray = typeof Float32Array !== 'undefined';\n/**\n * @alias module:zrender/core/PathProxy\n * @constructor\n */\n\nvar PathProxy = function (notSaveData) {\n  this._saveData = !(notSaveData || false);\n  if (this._saveData) {\n    /**\n     * Path data. Stored as flat array\n     * @type {Array.<Object>}\n     */\n    this.data = [];\n  }\n  this._ctx = null;\n};\n/**\n * 快速计算Path包围盒（并不是最小包围盒）\n * @return {Object}\n */\n\nPathProxy.prototype = {\n  constructor: PathProxy,\n  _xi: 0,\n  _yi: 0,\n  _x0: 0,\n  _y0: 0,\n  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n  _ux: 0,\n  _uy: 0,\n  _len: 0,\n  _lineDash: null,\n  _dashOffset: 0,\n  _dashIdx: 0,\n  _dashSum: 0,\n  /**\n   * @readOnly\n   */\n  setScale: function (sx, sy, segmentIgnoreThreshold) {\n    // Compat. Previously there is no segmentIgnoreThreshold.\n    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;\n    this._ux = mathAbs(segmentIgnoreThreshold / dpr / sx) || 0;\n    this._uy = mathAbs(segmentIgnoreThreshold / dpr / sy) || 0;\n  },\n  getContext: function () {\n    return this._ctx;\n  },\n  /**\n   * @param  {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  beginPath: function (ctx) {\n    this._ctx = ctx;\n    ctx && ctx.beginPath();\n    ctx && (this.dpr = ctx.dpr); // Reset\n\n    if (this._saveData) {\n      this._len = 0;\n    }\n    if (this._lineDash) {\n      this._lineDash = null;\n      this._dashOffset = 0;\n    }\n    return this;\n  },\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  moveTo: function (x, y) {\n    this.addData(CMD.M, x, y);\n    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\n    this._x0 = x;\n    this._y0 = y;\n    this._xi = x;\n    this._yi = y;\n    return this;\n  },\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  lineTo: function (x, y) {\n    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n    || this._len < 5;\n    this.addData(CMD.L, x, y);\n    if (this._ctx && exceedUnit) {\n      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n    }\n    if (exceedUnit) {\n      this._xi = x;\n      this._yi = y;\n    }\n    return this;\n  },\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @param  {number} x3\n   * @param  {number} y3\n   * @return {module:zrender/core/PathProxy}\n   */\n  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n    if (this._ctx) {\n      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n    }\n    this._xi = x3;\n    this._yi = y3;\n    return this;\n  },\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @return {module:zrender/core/PathProxy}\n   */\n  quadraticCurveTo: function (x1, y1, x2, y2) {\n    this.addData(CMD.Q, x1, y1, x2, y2);\n    if (this._ctx) {\n      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n    }\n    this._xi = x2;\n    this._yi = y2;\n    return this;\n  },\n  /**\n   * @param  {number} cx\n   * @param  {number} cy\n   * @param  {number} r\n   * @param  {number} startAngle\n   * @param  {number} endAngle\n   * @param  {boolean} anticlockwise\n   * @return {module:zrender/core/PathProxy}\n   */\n  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n    this._xi = mathCos(endAngle) * r + cx;\n    this._yi = mathSin(endAngle) * r + cy;\n    return this;\n  },\n  // TODO\n  arcTo: function (x1, y1, x2, y2, radius) {\n    if (this._ctx) {\n      this._ctx.arcTo(x1, y1, x2, y2, radius);\n    }\n    return this;\n  },\n  // TODO\n  rect: function (x, y, w, h) {\n    this._ctx && this._ctx.rect(x, y, w, h);\n    this.addData(CMD.R, x, y, w, h);\n    return this;\n  },\n  /**\n   * @return {module:zrender/core/PathProxy}\n   */\n  closePath: function () {\n    this.addData(CMD.Z);\n    var ctx = this._ctx;\n    var x0 = this._x0;\n    var y0 = this._y0;\n    if (ctx) {\n      this._needsDash() && this._dashedLineTo(x0, y0);\n      ctx.closePath();\n    }\n    this._xi = x0;\n    this._yi = y0;\n    return this;\n  },\n  /**\n   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n   * stroke 同样\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  fill: function (ctx) {\n    ctx && ctx.fill();\n    this.toStatic();\n  },\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  stroke: function (ctx) {\n    ctx && ctx.stroke();\n    this.toStatic();\n  },\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDash: function (lineDash) {\n    if (lineDash instanceof Array) {\n      this._lineDash = lineDash;\n      this._dashIdx = 0;\n      var lineDashSum = 0;\n      for (var i = 0; i < lineDash.length; i++) {\n        lineDashSum += lineDash[i];\n      }\n      this._dashSum = lineDashSum;\n    }\n    return this;\n  },\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDashOffset: function (offset) {\n    this._dashOffset = offset;\n    return this;\n  },\n  /**\n   *\n   * @return {boolean}\n   */\n  len: function () {\n    return this._len;\n  },\n  /**\n   * 直接设置 Path 数据\n   */\n  setData: function (data) {\n    var len = data.length;\n    if (!(this.data && this.data.length === len) && hasTypedArray) {\n      this.data = new Float32Array(len);\n    }\n    for (var i = 0; i < len; i++) {\n      this.data[i] = data[i];\n    }\n    this._len = len;\n  },\n  /**\n   * 添加子路径\n   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n   */\n  appendPath: function (path) {\n    if (!(path instanceof Array)) {\n      path = [path];\n    }\n    var len = path.length;\n    var appendSize = 0;\n    var offset = this._len;\n    for (var i = 0; i < len; i++) {\n      appendSize += path[i].len();\n    }\n    if (hasTypedArray && this.data instanceof Float32Array) {\n      this.data = new Float32Array(offset + appendSize);\n    }\n    for (var i = 0; i < len; i++) {\n      var appendPathData = path[i].data;\n      for (var k = 0; k < appendPathData.length; k++) {\n        this.data[offset++] = appendPathData[k];\n      }\n    }\n    this._len = offset;\n  },\n  /**\n   * 填充 Path 数据。\n   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n   */\n  addData: function (cmd) {\n    if (!this._saveData) {\n      return;\n    }\n    var data = this.data;\n    if (this._len + arguments.length > data.length) {\n      // 因为之前的数组已经转换成静态的 Float32Array\n      // 所以不够用时需要扩展一个新的动态数组\n      this._expandData();\n      data = this.data;\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      data[this._len++] = arguments[i];\n    }\n    this._prevCmd = cmd;\n  },\n  _expandData: function () {\n    // Only if data is Float32Array\n    if (!(this.data instanceof Array)) {\n      var newData = [];\n      for (var i = 0; i < this._len; i++) {\n        newData[i] = this.data[i];\n      }\n      this.data = newData;\n    }\n  },\n  /**\n   * If needs js implemented dashed line\n   * @return {boolean}\n   * @private\n   */\n  _needsDash: function () {\n    return this._lineDash;\n  },\n  _dashedLineTo: function (x1, y1) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dist = mathSqrt(dx * dx + dy * dy);\n    var x = x0;\n    var y = y0;\n    var dash;\n    var nDash = lineDash.length;\n    var idx;\n    dx /= dist;\n    dy /= dist;\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n    offset %= dashSum;\n    x -= offset * dx;\n    y -= offset * dy;\n    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx === 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n      idx = this._dashIdx;\n      dash = lineDash[idx];\n      x += dx * dash;\n      y += dy * dash;\n      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\n      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n        continue;\n      }\n      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n    } // Offset for next lineTo\n\n    dx = x - x1;\n    dy = y - y1;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  // Not accurate dashed line to\n  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var t;\n    var dx;\n    var dy;\n    var cubicAt = curve.cubicAt;\n    var bezierLen = 0;\n    var idx = this._dashIdx;\n    var nDash = lineDash.length;\n    var x;\n    var y;\n    var tmpLen = 0;\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n    offset %= dashSum; // Bezier approx length\n\n    for (t = 0; t < 1; t += 0.1) {\n      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n      bezierLen += mathSqrt(dx * dx + dy * dy);\n    } // Find idx after add offset\n\n    for (; idx < nDash; idx++) {\n      tmpLen += lineDash[idx];\n      if (tmpLen > offset) {\n        break;\n      }\n    }\n    t = (tmpLen - offset) / bezierLen;\n    while (t <= 1) {\n      x = cubicAt(x0, x1, x2, x3, t);\n      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n      // Bad result if dash is long\n\n      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      t += lineDash[idx] / bezierLen;\n      idx = (idx + 1) % nDash;\n    } // Finish the last segment and calculate the new offset\n\n    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n    dx = x3 - x;\n    dy = y3 - y;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n    // Convert quadratic to cubic using degree elevation\n    var x3 = x2;\n    var y3 = y2;\n    x2 = (x2 + 2 * x1) / 3;\n    y2 = (y2 + 2 * y1) / 3;\n    x1 = (this._xi + 2 * x1) / 3;\n    y1 = (this._yi + 2 * y1) / 3;\n    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n  },\n  /**\n   * 转成静态的 Float32Array 减少堆内存占用\n   * Convert dynamic array to static Float32Array\n   */\n  toStatic: function () {\n    var data = this.data;\n    if (data instanceof Array) {\n      data.length = this._len;\n      if (hasTypedArray) {\n        this.data = new Float32Array(data);\n      }\n    }\n  },\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n    var data = this.data;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n      if (i === 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n      switch (cmd) {\n        case CMD.M:\n          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n          // 在 closePath 的时候使用\n          x0 = data[i++];\n          y0 = data[i++];\n          xi = x0;\n          yi = y0;\n          min2[0] = x0;\n          min2[1] = y0;\n          max2[0] = x0;\n          max2[1] = y0;\n          break;\n        case CMD.L:\n          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n        case CMD.C:\n          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n        case CMD.Q:\n          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n        case CMD.A:\n          // TODO Arc 判断的开销比较大\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var endAngle = data[i++] + startAngle; // TODO Arc 旋转\n\n          i += 1;\n          var anticlockwise = 1 - data[i++];\n          if (i === 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n        case CMD.R:\n          x0 = xi = data[i++];\n          y0 = yi = data[i++];\n          var width = data[i++];\n          var height = data[i++]; // Use fromLine\n\n          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n          break;\n        case CMD.Z:\n          xi = x0;\n          yi = y0;\n          break;\n      } // Union\n\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n  /**\n   * Rebuild path from current data\n   * Rebuild path will not consider javascript implemented line dash.\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  rebuildPath: function (ctx) {\n    var d = this.data;\n    var x0;\n    var y0;\n    var xi;\n    var yi;\n    var x;\n    var y;\n    var ux = this._ux;\n    var uy = this._uy;\n    var len = this._len;\n    for (var i = 0; i < len;) {\n      var cmd = d[i++];\n      if (i === 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = d[i];\n        yi = d[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n      switch (cmd) {\n        case CMD.M:\n          x0 = xi = d[i++];\n          y0 = yi = d[i++];\n          ctx.moveTo(xi, yi);\n          break;\n        case CMD.L:\n          x = d[i++];\n          y = d[i++]; // Not draw too small seg between\n\n          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n            ctx.lineTo(x, y);\n            xi = x;\n            yi = y;\n          }\n          break;\n        case CMD.C:\n          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n        case CMD.Q:\n          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n        case CMD.A:\n          var cx = d[i++];\n          var cy = d[i++];\n          var rx = d[i++];\n          var ry = d[i++];\n          var theta = d[i++];\n          var dTheta = d[i++];\n          var psi = d[i++];\n          var fs = d[i++];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          var isEllipse = Math.abs(rx - ry) > 1e-3;\n          var endAngle = theta + dTheta;\n          if (isEllipse) {\n            ctx.translate(cx, cy);\n            ctx.rotate(psi);\n            ctx.scale(scaleX, scaleY);\n            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n            ctx.scale(1 / scaleX, 1 / scaleY);\n            ctx.rotate(-psi);\n            ctx.translate(-cx, -cy);\n          } else {\n            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n          }\n          if (i === 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(theta) * rx + cx;\n            y0 = mathSin(theta) * ry + cy;\n          }\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n        case CMD.R:\n          x0 = xi = d[i];\n          y0 = yi = d[i + 1];\n          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n          break;\n        case CMD.Z:\n          ctx.closePath();\n          xi = x0;\n          yi = y0;\n      }\n    }\n  }\n};\nPathProxy.CMD = CMD;\nvar _default = PathProxy;\nmodule.exports = _default;","map":{"version":3,"names":["curve","require","vec2","bbox","BoundingRect","_config","dpr","devicePixelRatio","CMD","M","L","C","Q","A","Z","R","min","max","min2","max2","mathMin","Math","mathMax","mathCos","cos","mathSin","sin","mathSqrt","sqrt","mathAbs","abs","hasTypedArray","Float32Array","PathProxy","notSaveData","_saveData","data","_ctx","prototype","constructor","_xi","_yi","_x0","_y0","_ux","_uy","_len","_lineDash","_dashOffset","_dashIdx","_dashSum","setScale","sx","sy","segmentIgnoreThreshold","getContext","beginPath","ctx","moveTo","x","y","addData","lineTo","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","x1","y1","x2","y2","x3","y3","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arc","cx","cy","r","startAngle","endAngle","anticlockwise","arcTo","radius","rect","w","h","closePath","x0","y0","fill","toStatic","stroke","setLineDash","lineDash","Array","lineDashSum","i","length","setLineDashOffset","offset","len","setData","appendPath","path","appendSize","appendPathData","k","cmd","arguments","_expandData","_prevCmd","newData","dashSum","dx","dy","dist","dash","nDash","idx","t","cubicAt","bezierLen","tmpLen","getBoundingRect","Number","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","rx","ry","fromArc","width","height","rebuildPath","d","ux","uy","theta","dTheta","psi","fs","scaleX","scaleY","isEllipse","translate","rotate","scale","_default","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/zrender/lib/core/PathProxy.js"],"sourcesContent":["var curve = require(\"./curve\");\n\nvar vec2 = require(\"./vector\");\n\nvar bbox = require(\"./bbox\");\n\nvar BoundingRect = require(\"./BoundingRect\");\n\nvar _config = require(\"../config\");\n\nvar dpr = _config.devicePixelRatio;\n\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n// TODO getTotalLength, getPointAtLength\n\n/* global Float32Array */\nvar CMD = {\n  M: 1,\n  L: 2,\n  C: 3,\n  Q: 4,\n  A: 5,\n  Z: 6,\n  // Rect\n  R: 7\n}; // var CMD_MEM_SIZE = {\n//     M: 3,\n//     L: 3,\n//     C: 7,\n//     Q: 5,\n//     A: 9,\n//     R: 5,\n//     Z: 1\n// };\n\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathCos = Math.cos;\nvar mathSin = Math.sin;\nvar mathSqrt = Math.sqrt;\nvar mathAbs = Math.abs;\nvar hasTypedArray = typeof Float32Array !== 'undefined';\n/**\n * @alias module:zrender/core/PathProxy\n * @constructor\n */\n\nvar PathProxy = function (notSaveData) {\n  this._saveData = !(notSaveData || false);\n\n  if (this._saveData) {\n    /**\n     * Path data. Stored as flat array\n     * @type {Array.<Object>}\n     */\n    this.data = [];\n  }\n\n  this._ctx = null;\n};\n/**\n * 快速计算Path包围盒（并不是最小包围盒）\n * @return {Object}\n */\n\n\nPathProxy.prototype = {\n  constructor: PathProxy,\n  _xi: 0,\n  _yi: 0,\n  _x0: 0,\n  _y0: 0,\n  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n  _ux: 0,\n  _uy: 0,\n  _len: 0,\n  _lineDash: null,\n  _dashOffset: 0,\n  _dashIdx: 0,\n  _dashSum: 0,\n\n  /**\n   * @readOnly\n   */\n  setScale: function (sx, sy, segmentIgnoreThreshold) {\n    // Compat. Previously there is no segmentIgnoreThreshold.\n    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;\n    this._ux = mathAbs(segmentIgnoreThreshold / dpr / sx) || 0;\n    this._uy = mathAbs(segmentIgnoreThreshold / dpr / sy) || 0;\n  },\n  getContext: function () {\n    return this._ctx;\n  },\n\n  /**\n   * @param  {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  beginPath: function (ctx) {\n    this._ctx = ctx;\n    ctx && ctx.beginPath();\n    ctx && (this.dpr = ctx.dpr); // Reset\n\n    if (this._saveData) {\n      this._len = 0;\n    }\n\n    if (this._lineDash) {\n      this._lineDash = null;\n      this._dashOffset = 0;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  moveTo: function (x, y) {\n    this.addData(CMD.M, x, y);\n    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\n    this._x0 = x;\n    this._y0 = y;\n    this._xi = x;\n    this._yi = y;\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  lineTo: function (x, y) {\n    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n    || this._len < 5;\n    this.addData(CMD.L, x, y);\n\n    if (this._ctx && exceedUnit) {\n      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n    }\n\n    if (exceedUnit) {\n      this._xi = x;\n      this._yi = y;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @param  {number} x3\n   * @param  {number} y3\n   * @return {module:zrender/core/PathProxy}\n   */\n  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n    }\n\n    this._xi = x3;\n    this._yi = y3;\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @return {module:zrender/core/PathProxy}\n   */\n  quadraticCurveTo: function (x1, y1, x2, y2) {\n    this.addData(CMD.Q, x1, y1, x2, y2);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n    }\n\n    this._xi = x2;\n    this._yi = y2;\n    return this;\n  },\n\n  /**\n   * @param  {number} cx\n   * @param  {number} cy\n   * @param  {number} r\n   * @param  {number} startAngle\n   * @param  {number} endAngle\n   * @param  {boolean} anticlockwise\n   * @return {module:zrender/core/PathProxy}\n   */\n  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n    this._xi = mathCos(endAngle) * r + cx;\n    this._yi = mathSin(endAngle) * r + cy;\n    return this;\n  },\n  // TODO\n  arcTo: function (x1, y1, x2, y2, radius) {\n    if (this._ctx) {\n      this._ctx.arcTo(x1, y1, x2, y2, radius);\n    }\n\n    return this;\n  },\n  // TODO\n  rect: function (x, y, w, h) {\n    this._ctx && this._ctx.rect(x, y, w, h);\n    this.addData(CMD.R, x, y, w, h);\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/PathProxy}\n   */\n  closePath: function () {\n    this.addData(CMD.Z);\n    var ctx = this._ctx;\n    var x0 = this._x0;\n    var y0 = this._y0;\n\n    if (ctx) {\n      this._needsDash() && this._dashedLineTo(x0, y0);\n      ctx.closePath();\n    }\n\n    this._xi = x0;\n    this._yi = y0;\n    return this;\n  },\n\n  /**\n   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n   * stroke 同样\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  fill: function (ctx) {\n    ctx && ctx.fill();\n    this.toStatic();\n  },\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  stroke: function (ctx) {\n    ctx && ctx.stroke();\n    this.toStatic();\n  },\n\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDash: function (lineDash) {\n    if (lineDash instanceof Array) {\n      this._lineDash = lineDash;\n      this._dashIdx = 0;\n      var lineDashSum = 0;\n\n      for (var i = 0; i < lineDash.length; i++) {\n        lineDashSum += lineDash[i];\n      }\n\n      this._dashSum = lineDashSum;\n    }\n\n    return this;\n  },\n\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDashOffset: function (offset) {\n    this._dashOffset = offset;\n    return this;\n  },\n\n  /**\n   *\n   * @return {boolean}\n   */\n  len: function () {\n    return this._len;\n  },\n\n  /**\n   * 直接设置 Path 数据\n   */\n  setData: function (data) {\n    var len = data.length;\n\n    if (!(this.data && this.data.length === len) && hasTypedArray) {\n      this.data = new Float32Array(len);\n    }\n\n    for (var i = 0; i < len; i++) {\n      this.data[i] = data[i];\n    }\n\n    this._len = len;\n  },\n\n  /**\n   * 添加子路径\n   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n   */\n  appendPath: function (path) {\n    if (!(path instanceof Array)) {\n      path = [path];\n    }\n\n    var len = path.length;\n    var appendSize = 0;\n    var offset = this._len;\n\n    for (var i = 0; i < len; i++) {\n      appendSize += path[i].len();\n    }\n\n    if (hasTypedArray && this.data instanceof Float32Array) {\n      this.data = new Float32Array(offset + appendSize);\n    }\n\n    for (var i = 0; i < len; i++) {\n      var appendPathData = path[i].data;\n\n      for (var k = 0; k < appendPathData.length; k++) {\n        this.data[offset++] = appendPathData[k];\n      }\n    }\n\n    this._len = offset;\n  },\n\n  /**\n   * 填充 Path 数据。\n   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n   */\n  addData: function (cmd) {\n    if (!this._saveData) {\n      return;\n    }\n\n    var data = this.data;\n\n    if (this._len + arguments.length > data.length) {\n      // 因为之前的数组已经转换成静态的 Float32Array\n      // 所以不够用时需要扩展一个新的动态数组\n      this._expandData();\n\n      data = this.data;\n    }\n\n    for (var i = 0; i < arguments.length; i++) {\n      data[this._len++] = arguments[i];\n    }\n\n    this._prevCmd = cmd;\n  },\n  _expandData: function () {\n    // Only if data is Float32Array\n    if (!(this.data instanceof Array)) {\n      var newData = [];\n\n      for (var i = 0; i < this._len; i++) {\n        newData[i] = this.data[i];\n      }\n\n      this.data = newData;\n    }\n  },\n\n  /**\n   * If needs js implemented dashed line\n   * @return {boolean}\n   * @private\n   */\n  _needsDash: function () {\n    return this._lineDash;\n  },\n  _dashedLineTo: function (x1, y1) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dist = mathSqrt(dx * dx + dy * dy);\n    var x = x0;\n    var y = y0;\n    var dash;\n    var nDash = lineDash.length;\n    var idx;\n    dx /= dist;\n    dy /= dist;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum;\n    x -= offset * dx;\n    y -= offset * dy;\n\n    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx === 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n      idx = this._dashIdx;\n      dash = lineDash[idx];\n      x += dx * dash;\n      y += dy * dash;\n      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\n      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n        continue;\n      }\n\n      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n    } // Offset for next lineTo\n\n\n    dx = x - x1;\n    dy = y - y1;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  // Not accurate dashed line to\n  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var t;\n    var dx;\n    var dy;\n    var cubicAt = curve.cubicAt;\n    var bezierLen = 0;\n    var idx = this._dashIdx;\n    var nDash = lineDash.length;\n    var x;\n    var y;\n    var tmpLen = 0;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum; // Bezier approx length\n\n    for (t = 0; t < 1; t += 0.1) {\n      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n      bezierLen += mathSqrt(dx * dx + dy * dy);\n    } // Find idx after add offset\n\n\n    for (; idx < nDash; idx++) {\n      tmpLen += lineDash[idx];\n\n      if (tmpLen > offset) {\n        break;\n      }\n    }\n\n    t = (tmpLen - offset) / bezierLen;\n\n    while (t <= 1) {\n      x = cubicAt(x0, x1, x2, x3, t);\n      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n      // Bad result if dash is long\n\n      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      t += lineDash[idx] / bezierLen;\n      idx = (idx + 1) % nDash;\n    } // Finish the last segment and calculate the new offset\n\n\n    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n    dx = x3 - x;\n    dy = y3 - y;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n    // Convert quadratic to cubic using degree elevation\n    var x3 = x2;\n    var y3 = y2;\n    x2 = (x2 + 2 * x1) / 3;\n    y2 = (y2 + 2 * y1) / 3;\n    x1 = (this._xi + 2 * x1) / 3;\n    y1 = (this._yi + 2 * y1) / 3;\n\n    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n  },\n\n  /**\n   * 转成静态的 Float32Array 减少堆内存占用\n   * Convert dynamic array to static Float32Array\n   */\n  toStatic: function () {\n    var data = this.data;\n\n    if (data instanceof Array) {\n      data.length = this._len;\n\n      if (hasTypedArray) {\n        this.data = new Float32Array(data);\n      }\n    }\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n    var data = this.data;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n\n      if (i === 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n          // 在 closePath 的时候使用\n          x0 = data[i++];\n          y0 = data[i++];\n          xi = x0;\n          yi = y0;\n          min2[0] = x0;\n          min2[1] = y0;\n          max2[0] = x0;\n          max2[1] = y0;\n          break;\n\n        case CMD.L:\n          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.C:\n          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.Q:\n          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.A:\n          // TODO Arc 判断的开销比较大\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var endAngle = data[i++] + startAngle; // TODO Arc 旋转\n\n          i += 1;\n          var anticlockwise = 1 - data[i++];\n\n          if (i === 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n\n          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = data[i++];\n          y0 = yi = data[i++];\n          var width = data[i++];\n          var height = data[i++]; // Use fromLine\n\n          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n          break;\n\n        case CMD.Z:\n          xi = x0;\n          yi = y0;\n          break;\n      } // Union\n\n\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\n   * Rebuild path from current data\n   * Rebuild path will not consider javascript implemented line dash.\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  rebuildPath: function (ctx) {\n    var d = this.data;\n    var x0;\n    var y0;\n    var xi;\n    var yi;\n    var x;\n    var y;\n    var ux = this._ux;\n    var uy = this._uy;\n    var len = this._len;\n\n    for (var i = 0; i < len;) {\n      var cmd = d[i++];\n\n      if (i === 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = d[i];\n        yi = d[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = xi = d[i++];\n          y0 = yi = d[i++];\n          ctx.moveTo(xi, yi);\n          break;\n\n        case CMD.L:\n          x = d[i++];\n          y = d[i++]; // Not draw too small seg between\n\n          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n            ctx.lineTo(x, y);\n            xi = x;\n            yi = y;\n          }\n\n          break;\n\n        case CMD.C:\n          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.Q:\n          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.A:\n          var cx = d[i++];\n          var cy = d[i++];\n          var rx = d[i++];\n          var ry = d[i++];\n          var theta = d[i++];\n          var dTheta = d[i++];\n          var psi = d[i++];\n          var fs = d[i++];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          var isEllipse = Math.abs(rx - ry) > 1e-3;\n          var endAngle = theta + dTheta;\n\n          if (isEllipse) {\n            ctx.translate(cx, cy);\n            ctx.rotate(psi);\n            ctx.scale(scaleX, scaleY);\n            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n            ctx.scale(1 / scaleX, 1 / scaleY);\n            ctx.rotate(-psi);\n            ctx.translate(-cx, -cy);\n          } else {\n            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n          }\n\n          if (i === 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(theta) * rx + cx;\n            y0 = mathSin(theta) * ry + cy;\n          }\n\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = d[i];\n          y0 = yi = d[i + 1];\n          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n          break;\n\n        case CMD.Z:\n          ctx.closePath();\n          xi = x0;\n          yi = y0;\n      }\n    }\n  }\n};\nPathProxy.CMD = CMD;\nvar _default = PathProxy;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}