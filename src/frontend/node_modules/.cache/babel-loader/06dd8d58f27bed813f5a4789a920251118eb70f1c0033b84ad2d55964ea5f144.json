{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar matrix = require(\"zrender/lib/core/matrix\");\nvar layoutUtil = require(\"../../util/layout\");\nvar axisHelper = require(\"../../coord/axisHelper\");\nvar ParallelAxis = require(\"./ParallelAxis\");\nvar graphic = require(\"../../util/graphic\");\nvar numberUtil = require(\"../../util/number\");\nvar sliderMove = require(\"../../component/helper/sliderMove\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Parallel Coordinates\n * <https://en.wikipedia.org/wiki/Parallel_coordinates>\n */\nvar each = zrUtil.each;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar round = numberUtil.round;\nvar PI = Math.PI;\nfunction Parallel(parallelModel, ecModel, api) {\n  /**\n   * key: dimension\n   * @type {Object.<string, module:echarts/coord/parallel/Axis>}\n   * @private\n   */\n  this._axesMap = zrUtil.createHashMap();\n  /**\n   * key: dimension\n   * value: {position: [], rotation, }\n   * @type {Object.<string, Object>}\n   * @private\n   */\n\n  this._axesLayout = {};\n  /**\n   * Always follow axis order.\n   * @type {Array.<string>}\n   * @readOnly\n   */\n\n  this.dimensions = parallelModel.dimensions;\n  /**\n   * @type {module:zrender/core/BoundingRect}\n   */\n\n  this._rect;\n  /**\n   * @type {module:echarts/coord/parallel/ParallelModel}\n   */\n\n  this._model = parallelModel;\n  this._init(parallelModel, ecModel, api);\n}\nParallel.prototype = {\n  type: 'parallel',\n  constructor: Parallel,\n  /**\n   * Initialize cartesian coordinate systems\n   * @private\n   */\n  _init: function (parallelModel, ecModel, api) {\n    var dimensions = parallelModel.dimensions;\n    var parallelAxisIndex = parallelModel.parallelAxisIndex;\n    each(dimensions, function (dim, idx) {\n      var axisIndex = parallelAxisIndex[idx];\n      var axisModel = ecModel.getComponent('parallelAxis', axisIndex);\n      var axis = this._axesMap.set(dim, new ParallelAxis(dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisIndex));\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Injection\n\n      axisModel.axis = axis;\n      axis.model = axisModel;\n      axis.coordinateSystem = axisModel.coordinateSystem = this;\n    }, this);\n  },\n  /**\n   * Update axis scale after data processed\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   */\n  update: function (ecModel, api) {\n    this._updateAxesFromSeries(this._model, ecModel);\n  },\n  /**\n   * @override\n   */\n  containPoint: function (point) {\n    var layoutInfo = this._makeLayoutInfo();\n    var axisBase = layoutInfo.axisBase;\n    var layoutBase = layoutInfo.layoutBase;\n    var pixelDimIndex = layoutInfo.pixelDimIndex;\n    var pAxis = point[1 - pixelDimIndex];\n    var pLayout = point[pixelDimIndex];\n    return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;\n  },\n  getModel: function () {\n    return this._model;\n  },\n  /**\n   * Update properties from series\n   * @private\n   */\n  _updateAxesFromSeries: function (parallelModel, ecModel) {\n    ecModel.eachSeries(function (seriesModel) {\n      if (!parallelModel.contains(seriesModel, ecModel)) {\n        return;\n      }\n      var data = seriesModel.getData();\n      each(this.dimensions, function (dim) {\n        var axis = this._axesMap.get(dim);\n        axis.scale.unionExtentFromData(data, data.mapDimension(dim));\n        axisHelper.niceScaleExtent(axis.scale, axis.model);\n      }, this);\n    }, this);\n  },\n  /**\n   * Resize the parallel coordinate system.\n   * @param {module:echarts/coord/parallel/ParallelModel} parallelModel\n   * @param {module:echarts/ExtensionAPI} api\n   */\n  resize: function (parallelModel, api) {\n    this._rect = layoutUtil.getLayoutRect(parallelModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    this._layoutAxes();\n  },\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getRect: function () {\n    return this._rect;\n  },\n  /**\n   * @private\n   */\n  _makeLayoutInfo: function () {\n    var parallelModel = this._model;\n    var rect = this._rect;\n    var xy = ['x', 'y'];\n    var wh = ['width', 'height'];\n    var layout = parallelModel.get('layout');\n    var pixelDimIndex = layout === 'horizontal' ? 0 : 1;\n    var layoutLength = rect[wh[pixelDimIndex]];\n    var layoutExtent = [0, layoutLength];\n    var axisCount = this.dimensions.length;\n    var axisExpandWidth = restrict(parallelModel.get('axisExpandWidth'), layoutExtent);\n    var axisExpandCount = restrict(parallelModel.get('axisExpandCount') || 0, [0, axisCount]);\n    var axisExpandable = parallelModel.get('axisExpandable') && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0; // `axisExpandWindow` is According to the coordinates of [0, axisExpandLength],\n    // for sake of consider the case that axisCollapseWidth is 0 (when screen is narrow),\n    // where collapsed axes should be overlapped.\n\n    var axisExpandWindow = parallelModel.get('axisExpandWindow');\n    var winSize;\n    if (!axisExpandWindow) {\n      winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);\n      var axisExpandCenter = parallelModel.get('axisExpandCenter') || mathFloor(axisCount / 2);\n      axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];\n      axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n    } else {\n      winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);\n      axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n    }\n    var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount); // Avoid axisCollapseWidth is too small.\n\n    axisCollapseWidth < 3 && (axisCollapseWidth = 0); // Find the first and last indices > ewin[0] and < ewin[1].\n\n    var winInnerIndices = [mathFloor(round(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round(axisExpandWindow[1] / axisExpandWidth, 1)) - 1]; // Pos in ec coordinates.\n\n    var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];\n    return {\n      layout: layout,\n      pixelDimIndex: pixelDimIndex,\n      layoutBase: rect[xy[pixelDimIndex]],\n      layoutLength: layoutLength,\n      axisBase: rect[xy[1 - pixelDimIndex]],\n      axisLength: rect[wh[1 - pixelDimIndex]],\n      axisExpandable: axisExpandable,\n      axisExpandWidth: axisExpandWidth,\n      axisCollapseWidth: axisCollapseWidth,\n      axisExpandWindow: axisExpandWindow,\n      axisCount: axisCount,\n      winInnerIndices: winInnerIndices,\n      axisExpandWindow0Pos: axisExpandWindow0Pos\n    };\n  },\n  /**\n   * @private\n   */\n  _layoutAxes: function () {\n    var rect = this._rect;\n    var axes = this._axesMap;\n    var dimensions = this.dimensions;\n    var layoutInfo = this._makeLayoutInfo();\n    var layout = layoutInfo.layout;\n    axes.each(function (axis) {\n      var axisExtent = [0, layoutInfo.axisLength];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);\n    });\n    each(dimensions, function (dim, idx) {\n      var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);\n      var positionTable = {\n        horizontal: {\n          x: posInfo.position,\n          y: layoutInfo.axisLength\n        },\n        vertical: {\n          x: 0,\n          y: posInfo.position\n        }\n      };\n      var rotationTable = {\n        horizontal: PI / 2,\n        vertical: 0\n      };\n      var position = [positionTable[layout].x + rect.x, positionTable[layout].y + rect.y];\n      var rotation = rotationTable[layout];\n      var transform = matrix.create();\n      matrix.rotate(transform, transform, rotation);\n      matrix.translate(transform, transform, position); // TODO\n      // tick等排布信息。\n      // TODO\n      // 根据axis order 更新 dimensions顺序。\n\n      this._axesLayout[dim] = {\n        position: position,\n        rotation: rotation,\n        transform: transform,\n        axisNameAvailableWidth: posInfo.axisNameAvailableWidth,\n        axisLabelShow: posInfo.axisLabelShow,\n        nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,\n        tickDirection: 1,\n        labelDirection: 1\n      };\n    }, this);\n  },\n  /**\n   * Get axis by dim.\n   * @param {string} dim\n   * @return {module:echarts/coord/parallel/ParallelAxis} [description]\n   */\n  getAxis: function (dim) {\n    return this._axesMap.get(dim);\n  },\n  /**\n   * Convert a dim value of a single item of series data to Point.\n   * @param {*} value\n   * @param {string} dim\n   * @return {Array}\n   */\n  dataToPoint: function (value, dim) {\n    return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);\n  },\n  /**\n   * Travel data for one time, get activeState of each data item.\n   * @param {module:echarts/data/List} data\n   * @param {Functio} cb param: {string} activeState 'active' or 'inactive' or 'normal'\n   *                            {number} dataIndex\n   * @param {number} [start=0] the start dataIndex that travel from.\n   * @param {number} [end=data.count()] the next dataIndex of the last dataIndex will be travel.\n   */\n  eachActiveState: function (data, callback, start, end) {\n    start == null && (start = 0);\n    end == null && (end = data.count());\n    var axesMap = this._axesMap;\n    var dimensions = this.dimensions;\n    var dataDimensions = [];\n    var axisModels = [];\n    zrUtil.each(dimensions, function (axisDim) {\n      dataDimensions.push(data.mapDimension(axisDim));\n      axisModels.push(axesMap.get(axisDim).model);\n    });\n    var hasActiveSet = this.hasAxisBrushed();\n    for (var dataIndex = start; dataIndex < end; dataIndex++) {\n      var activeState;\n      if (!hasActiveSet) {\n        activeState = 'normal';\n      } else {\n        activeState = 'active';\n        var values = data.getValues(dataDimensions, dataIndex);\n        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n          var state = axisModels[j].getActiveState(values[j]);\n          if (state === 'inactive') {\n            activeState = 'inactive';\n            break;\n          }\n        }\n      }\n      callback(activeState, dataIndex);\n    }\n  },\n  /**\n   * Whether has any activeSet.\n   * @return {boolean}\n   */\n  hasAxisBrushed: function () {\n    var dimensions = this.dimensions;\n    var axesMap = this._axesMap;\n    var hasActiveSet = false;\n    for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n      if (axesMap.get(dimensions[j]).model.getActiveState() !== 'normal') {\n        hasActiveSet = true;\n      }\n    }\n    return hasActiveSet;\n  },\n  /**\n   * Convert coords of each axis to Point.\n   *  Return point. For example: [10, 20]\n   * @param {Array.<number>} coords\n   * @param {string} dim\n   * @return {Array.<number>}\n   */\n  axisCoordToPoint: function (coord, dim) {\n    var axisLayout = this._axesLayout[dim];\n    return graphic.applyTransform([coord, 0], axisLayout.transform);\n  },\n  /**\n   * Get axis layout.\n   */\n  getAxisLayout: function (dim) {\n    return zrUtil.clone(this._axesLayout[dim]);\n  },\n  /**\n   * @param {Array.<number>} point\n   * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.\n   */\n  getSlidedAxisExpandWindow: function (point) {\n    var layoutInfo = this._makeLayoutInfo();\n    var pixelDimIndex = layoutInfo.pixelDimIndex;\n    var axisExpandWindow = layoutInfo.axisExpandWindow.slice();\n    var winSize = axisExpandWindow[1] - axisExpandWindow[0];\n    var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)]; // Out of the area of coordinate system.\n\n    if (!this.containPoint(point)) {\n      return {\n        behavior: 'none',\n        axisExpandWindow: axisExpandWindow\n      };\n    } // Conver the point from global to expand coordinates.\n\n    var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos; // For dragging operation convenience, the window should not be\n    // slided when mouse is the center area of the window.\n\n    var delta;\n    var behavior = 'slide';\n    var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n    var triggerArea = this._model.get('axisExpandSlideTriggerArea'); // But consider touch device, jump is necessary.\n\n    var useJump = triggerArea[0] != null;\n    if (axisCollapseWidth) {\n      if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {\n        behavior = 'jump';\n        delta = pointCoord - winSize * triggerArea[2];\n      } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {\n        behavior = 'jump';\n        delta = pointCoord - winSize * (1 - triggerArea[2]);\n      } else {\n        (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);\n      }\n      delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;\n      delta ? sliderMove(delta, axisExpandWindow, extent, 'all') // Avoid nonsense triger on mousemove.\n      : behavior = 'none';\n    } // When screen is too narrow, make it visible and slidable, although it is hard to interact.\n    else {\n      var winSize = axisExpandWindow[1] - axisExpandWindow[0];\n      var pos = extent[1] * pointCoord / winSize;\n      axisExpandWindow = [mathMax(0, pos - winSize / 2)];\n      axisExpandWindow[1] = mathMin(extent[1], axisExpandWindow[0] + winSize);\n      axisExpandWindow[0] = axisExpandWindow[1] - winSize;\n    }\n    return {\n      axisExpandWindow: axisExpandWindow,\n      behavior: behavior\n    };\n  }\n};\nfunction restrict(len, extent) {\n  return mathMin(mathMax(len, extent[0]), extent[1]);\n}\nfunction layoutAxisWithoutExpand(axisIndex, layoutInfo) {\n  var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);\n  return {\n    position: step * axisIndex,\n    axisNameAvailableWidth: step,\n    axisLabelShow: true\n  };\n}\nfunction layoutAxisWithExpand(axisIndex, layoutInfo) {\n  var layoutLength = layoutInfo.layoutLength;\n  var axisExpandWidth = layoutInfo.axisExpandWidth;\n  var axisCount = layoutInfo.axisCount;\n  var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n  var winInnerIndices = layoutInfo.winInnerIndices;\n  var position;\n  var axisNameAvailableWidth = axisCollapseWidth;\n  var axisLabelShow = false;\n  var nameTruncateMaxWidth;\n  if (axisIndex < winInnerIndices[0]) {\n    position = axisIndex * axisCollapseWidth;\n    nameTruncateMaxWidth = axisCollapseWidth;\n  } else if (axisIndex <= winInnerIndices[1]) {\n    position = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];\n    axisNameAvailableWidth = axisExpandWidth;\n    axisLabelShow = true;\n  } else {\n    position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;\n    nameTruncateMaxWidth = axisCollapseWidth;\n  }\n  return {\n    position: position,\n    axisNameAvailableWidth: axisNameAvailableWidth,\n    axisLabelShow: axisLabelShow,\n    nameTruncateMaxWidth: nameTruncateMaxWidth\n  };\n}\nvar _default = Parallel;\nmodule.exports = _default;","map":{"version":3,"names":["zrUtil","require","matrix","layoutUtil","axisHelper","ParallelAxis","graphic","numberUtil","sliderMove","each","mathMin","Math","min","mathMax","max","mathFloor","floor","mathCeil","ceil","round","PI","Parallel","parallelModel","ecModel","api","_axesMap","createHashMap","_axesLayout","dimensions","_rect","_model","_init","prototype","type","constructor","parallelAxisIndex","dim","idx","axisIndex","axisModel","getComponent","axis","set","createScaleByModel","get","isCategory","onBand","inverse","model","coordinateSystem","update","_updateAxesFromSeries","containPoint","point","layoutInfo","_makeLayoutInfo","axisBase","layoutBase","pixelDimIndex","pAxis","pLayout","axisLength","layoutLength","getModel","eachSeries","seriesModel","contains","data","getData","scale","unionExtentFromData","mapDimension","niceScaleExtent","resize","getLayoutRect","getBoxLayoutParams","width","getWidth","height","getHeight","_layoutAxes","getRect","rect","xy","wh","layout","layoutExtent","axisCount","length","axisExpandWidth","restrict","axisExpandCount","axisExpandable","axisExpandWindow","winSize","axisExpandCenter","axisCollapseWidth","winInnerIndices","axisExpandWindow0Pos","axes","axisExtent","setExtent","posInfo","layoutAxisWithExpand","layoutAxisWithoutExpand","positionTable","horizontal","x","position","y","vertical","rotationTable","rotation","transform","create","rotate","translate","axisNameAvailableWidth","axisLabelShow","nameTruncateMaxWidth","tickDirection","labelDirection","getAxis","dataToPoint","value","axisCoordToPoint","dataToCoord","eachActiveState","callback","start","end","count","axesMap","dataDimensions","axisModels","axisDim","push","hasActiveSet","hasAxisBrushed","dataIndex","activeState","values","getValues","j","lenj","state","getActiveState","coord","axisLayout","applyTransform","getAxisLayout","clone","getSlidedAxisExpandWindow","slice","extent","behavior","pointCoord","delta","triggerArea","useJump","pos","len","step","_default","module","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/echarts/lib/coord/parallel/Parallel.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar matrix = require(\"zrender/lib/core/matrix\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar ParallelAxis = require(\"./ParallelAxis\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar sliderMove = require(\"../../component/helper/sliderMove\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Parallel Coordinates\n * <https://en.wikipedia.org/wiki/Parallel_coordinates>\n */\nvar each = zrUtil.each;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar round = numberUtil.round;\nvar PI = Math.PI;\n\nfunction Parallel(parallelModel, ecModel, api) {\n  /**\n   * key: dimension\n   * @type {Object.<string, module:echarts/coord/parallel/Axis>}\n   * @private\n   */\n  this._axesMap = zrUtil.createHashMap();\n  /**\n   * key: dimension\n   * value: {position: [], rotation, }\n   * @type {Object.<string, Object>}\n   * @private\n   */\n\n  this._axesLayout = {};\n  /**\n   * Always follow axis order.\n   * @type {Array.<string>}\n   * @readOnly\n   */\n\n  this.dimensions = parallelModel.dimensions;\n  /**\n   * @type {module:zrender/core/BoundingRect}\n   */\n\n  this._rect;\n  /**\n   * @type {module:echarts/coord/parallel/ParallelModel}\n   */\n\n  this._model = parallelModel;\n\n  this._init(parallelModel, ecModel, api);\n}\n\nParallel.prototype = {\n  type: 'parallel',\n  constructor: Parallel,\n\n  /**\n   * Initialize cartesian coordinate systems\n   * @private\n   */\n  _init: function (parallelModel, ecModel, api) {\n    var dimensions = parallelModel.dimensions;\n    var parallelAxisIndex = parallelModel.parallelAxisIndex;\n    each(dimensions, function (dim, idx) {\n      var axisIndex = parallelAxisIndex[idx];\n      var axisModel = ecModel.getComponent('parallelAxis', axisIndex);\n\n      var axis = this._axesMap.set(dim, new ParallelAxis(dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisIndex));\n\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Injection\n\n      axisModel.axis = axis;\n      axis.model = axisModel;\n      axis.coordinateSystem = axisModel.coordinateSystem = this;\n    }, this);\n  },\n\n  /**\n   * Update axis scale after data processed\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   */\n  update: function (ecModel, api) {\n    this._updateAxesFromSeries(this._model, ecModel);\n  },\n\n  /**\n   * @override\n   */\n  containPoint: function (point) {\n    var layoutInfo = this._makeLayoutInfo();\n\n    var axisBase = layoutInfo.axisBase;\n    var layoutBase = layoutInfo.layoutBase;\n    var pixelDimIndex = layoutInfo.pixelDimIndex;\n    var pAxis = point[1 - pixelDimIndex];\n    var pLayout = point[pixelDimIndex];\n    return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;\n  },\n  getModel: function () {\n    return this._model;\n  },\n\n  /**\n   * Update properties from series\n   * @private\n   */\n  _updateAxesFromSeries: function (parallelModel, ecModel) {\n    ecModel.eachSeries(function (seriesModel) {\n      if (!parallelModel.contains(seriesModel, ecModel)) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      each(this.dimensions, function (dim) {\n        var axis = this._axesMap.get(dim);\n\n        axis.scale.unionExtentFromData(data, data.mapDimension(dim));\n        axisHelper.niceScaleExtent(axis.scale, axis.model);\n      }, this);\n    }, this);\n  },\n\n  /**\n   * Resize the parallel coordinate system.\n   * @param {module:echarts/coord/parallel/ParallelModel} parallelModel\n   * @param {module:echarts/ExtensionAPI} api\n   */\n  resize: function (parallelModel, api) {\n    this._rect = layoutUtil.getLayoutRect(parallelModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n\n    this._layoutAxes();\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getRect: function () {\n    return this._rect;\n  },\n\n  /**\n   * @private\n   */\n  _makeLayoutInfo: function () {\n    var parallelModel = this._model;\n    var rect = this._rect;\n    var xy = ['x', 'y'];\n    var wh = ['width', 'height'];\n    var layout = parallelModel.get('layout');\n    var pixelDimIndex = layout === 'horizontal' ? 0 : 1;\n    var layoutLength = rect[wh[pixelDimIndex]];\n    var layoutExtent = [0, layoutLength];\n    var axisCount = this.dimensions.length;\n    var axisExpandWidth = restrict(parallelModel.get('axisExpandWidth'), layoutExtent);\n    var axisExpandCount = restrict(parallelModel.get('axisExpandCount') || 0, [0, axisCount]);\n    var axisExpandable = parallelModel.get('axisExpandable') && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0; // `axisExpandWindow` is According to the coordinates of [0, axisExpandLength],\n    // for sake of consider the case that axisCollapseWidth is 0 (when screen is narrow),\n    // where collapsed axes should be overlapped.\n\n    var axisExpandWindow = parallelModel.get('axisExpandWindow');\n    var winSize;\n\n    if (!axisExpandWindow) {\n      winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);\n      var axisExpandCenter = parallelModel.get('axisExpandCenter') || mathFloor(axisCount / 2);\n      axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];\n      axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n    } else {\n      winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);\n      axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n    }\n\n    var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount); // Avoid axisCollapseWidth is too small.\n\n    axisCollapseWidth < 3 && (axisCollapseWidth = 0); // Find the first and last indices > ewin[0] and < ewin[1].\n\n    var winInnerIndices = [mathFloor(round(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round(axisExpandWindow[1] / axisExpandWidth, 1)) - 1]; // Pos in ec coordinates.\n\n    var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];\n    return {\n      layout: layout,\n      pixelDimIndex: pixelDimIndex,\n      layoutBase: rect[xy[pixelDimIndex]],\n      layoutLength: layoutLength,\n      axisBase: rect[xy[1 - pixelDimIndex]],\n      axisLength: rect[wh[1 - pixelDimIndex]],\n      axisExpandable: axisExpandable,\n      axisExpandWidth: axisExpandWidth,\n      axisCollapseWidth: axisCollapseWidth,\n      axisExpandWindow: axisExpandWindow,\n      axisCount: axisCount,\n      winInnerIndices: winInnerIndices,\n      axisExpandWindow0Pos: axisExpandWindow0Pos\n    };\n  },\n\n  /**\n   * @private\n   */\n  _layoutAxes: function () {\n    var rect = this._rect;\n    var axes = this._axesMap;\n    var dimensions = this.dimensions;\n\n    var layoutInfo = this._makeLayoutInfo();\n\n    var layout = layoutInfo.layout;\n    axes.each(function (axis) {\n      var axisExtent = [0, layoutInfo.axisLength];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);\n    });\n    each(dimensions, function (dim, idx) {\n      var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);\n      var positionTable = {\n        horizontal: {\n          x: posInfo.position,\n          y: layoutInfo.axisLength\n        },\n        vertical: {\n          x: 0,\n          y: posInfo.position\n        }\n      };\n      var rotationTable = {\n        horizontal: PI / 2,\n        vertical: 0\n      };\n      var position = [positionTable[layout].x + rect.x, positionTable[layout].y + rect.y];\n      var rotation = rotationTable[layout];\n      var transform = matrix.create();\n      matrix.rotate(transform, transform, rotation);\n      matrix.translate(transform, transform, position); // TODO\n      // tick等排布信息。\n      // TODO\n      // 根据axis order 更新 dimensions顺序。\n\n      this._axesLayout[dim] = {\n        position: position,\n        rotation: rotation,\n        transform: transform,\n        axisNameAvailableWidth: posInfo.axisNameAvailableWidth,\n        axisLabelShow: posInfo.axisLabelShow,\n        nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,\n        tickDirection: 1,\n        labelDirection: 1\n      };\n    }, this);\n  },\n\n  /**\n   * Get axis by dim.\n   * @param {string} dim\n   * @return {module:echarts/coord/parallel/ParallelAxis} [description]\n   */\n  getAxis: function (dim) {\n    return this._axesMap.get(dim);\n  },\n\n  /**\n   * Convert a dim value of a single item of series data to Point.\n   * @param {*} value\n   * @param {string} dim\n   * @return {Array}\n   */\n  dataToPoint: function (value, dim) {\n    return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);\n  },\n\n  /**\n   * Travel data for one time, get activeState of each data item.\n   * @param {module:echarts/data/List} data\n   * @param {Functio} cb param: {string} activeState 'active' or 'inactive' or 'normal'\n   *                            {number} dataIndex\n   * @param {number} [start=0] the start dataIndex that travel from.\n   * @param {number} [end=data.count()] the next dataIndex of the last dataIndex will be travel.\n   */\n  eachActiveState: function (data, callback, start, end) {\n    start == null && (start = 0);\n    end == null && (end = data.count());\n    var axesMap = this._axesMap;\n    var dimensions = this.dimensions;\n    var dataDimensions = [];\n    var axisModels = [];\n    zrUtil.each(dimensions, function (axisDim) {\n      dataDimensions.push(data.mapDimension(axisDim));\n      axisModels.push(axesMap.get(axisDim).model);\n    });\n    var hasActiveSet = this.hasAxisBrushed();\n\n    for (var dataIndex = start; dataIndex < end; dataIndex++) {\n      var activeState;\n\n      if (!hasActiveSet) {\n        activeState = 'normal';\n      } else {\n        activeState = 'active';\n        var values = data.getValues(dataDimensions, dataIndex);\n\n        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n          var state = axisModels[j].getActiveState(values[j]);\n\n          if (state === 'inactive') {\n            activeState = 'inactive';\n            break;\n          }\n        }\n      }\n\n      callback(activeState, dataIndex);\n    }\n  },\n\n  /**\n   * Whether has any activeSet.\n   * @return {boolean}\n   */\n  hasAxisBrushed: function () {\n    var dimensions = this.dimensions;\n    var axesMap = this._axesMap;\n    var hasActiveSet = false;\n\n    for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n      if (axesMap.get(dimensions[j]).model.getActiveState() !== 'normal') {\n        hasActiveSet = true;\n      }\n    }\n\n    return hasActiveSet;\n  },\n\n  /**\n   * Convert coords of each axis to Point.\n   *  Return point. For example: [10, 20]\n   * @param {Array.<number>} coords\n   * @param {string} dim\n   * @return {Array.<number>}\n   */\n  axisCoordToPoint: function (coord, dim) {\n    var axisLayout = this._axesLayout[dim];\n    return graphic.applyTransform([coord, 0], axisLayout.transform);\n  },\n\n  /**\n   * Get axis layout.\n   */\n  getAxisLayout: function (dim) {\n    return zrUtil.clone(this._axesLayout[dim]);\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.\n   */\n  getSlidedAxisExpandWindow: function (point) {\n    var layoutInfo = this._makeLayoutInfo();\n\n    var pixelDimIndex = layoutInfo.pixelDimIndex;\n    var axisExpandWindow = layoutInfo.axisExpandWindow.slice();\n    var winSize = axisExpandWindow[1] - axisExpandWindow[0];\n    var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)]; // Out of the area of coordinate system.\n\n    if (!this.containPoint(point)) {\n      return {\n        behavior: 'none',\n        axisExpandWindow: axisExpandWindow\n      };\n    } // Conver the point from global to expand coordinates.\n\n\n    var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos; // For dragging operation convenience, the window should not be\n    // slided when mouse is the center area of the window.\n\n    var delta;\n    var behavior = 'slide';\n    var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n\n    var triggerArea = this._model.get('axisExpandSlideTriggerArea'); // But consider touch device, jump is necessary.\n\n\n    var useJump = triggerArea[0] != null;\n\n    if (axisCollapseWidth) {\n      if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {\n        behavior = 'jump';\n        delta = pointCoord - winSize * triggerArea[2];\n      } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {\n        behavior = 'jump';\n        delta = pointCoord - winSize * (1 - triggerArea[2]);\n      } else {\n        (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);\n      }\n\n      delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;\n      delta ? sliderMove(delta, axisExpandWindow, extent, 'all') // Avoid nonsense triger on mousemove.\n      : behavior = 'none';\n    } // When screen is too narrow, make it visible and slidable, although it is hard to interact.\n    else {\n        var winSize = axisExpandWindow[1] - axisExpandWindow[0];\n        var pos = extent[1] * pointCoord / winSize;\n        axisExpandWindow = [mathMax(0, pos - winSize / 2)];\n        axisExpandWindow[1] = mathMin(extent[1], axisExpandWindow[0] + winSize);\n        axisExpandWindow[0] = axisExpandWindow[1] - winSize;\n      }\n\n    return {\n      axisExpandWindow: axisExpandWindow,\n      behavior: behavior\n    };\n  }\n};\n\nfunction restrict(len, extent) {\n  return mathMin(mathMax(len, extent[0]), extent[1]);\n}\n\nfunction layoutAxisWithoutExpand(axisIndex, layoutInfo) {\n  var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);\n  return {\n    position: step * axisIndex,\n    axisNameAvailableWidth: step,\n    axisLabelShow: true\n  };\n}\n\nfunction layoutAxisWithExpand(axisIndex, layoutInfo) {\n  var layoutLength = layoutInfo.layoutLength;\n  var axisExpandWidth = layoutInfo.axisExpandWidth;\n  var axisCount = layoutInfo.axisCount;\n  var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n  var winInnerIndices = layoutInfo.winInnerIndices;\n  var position;\n  var axisNameAvailableWidth = axisCollapseWidth;\n  var axisLabelShow = false;\n  var nameTruncateMaxWidth;\n\n  if (axisIndex < winInnerIndices[0]) {\n    position = axisIndex * axisCollapseWidth;\n    nameTruncateMaxWidth = axisCollapseWidth;\n  } else if (axisIndex <= winInnerIndices[1]) {\n    position = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];\n    axisNameAvailableWidth = axisExpandWidth;\n    axisLabelShow = true;\n  } else {\n    position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;\n    nameTruncateMaxWidth = axisCollapseWidth;\n  }\n\n  return {\n    position: position,\n    axisNameAvailableWidth: axisNameAvailableWidth,\n    axisLabelShow: axisLabelShow,\n    nameTruncateMaxWidth: nameTruncateMaxWidth\n  };\n}\n\nvar _default = Parallel;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}