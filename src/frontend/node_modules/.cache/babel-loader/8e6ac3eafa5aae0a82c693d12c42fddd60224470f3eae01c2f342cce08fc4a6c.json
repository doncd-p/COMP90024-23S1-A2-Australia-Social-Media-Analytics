{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\nvar _number = require(\"./number\");\nvar parsePercent = _number.parsePercent;\nvar formatUtil = require(\"./format\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Layout helpers for each component positioning\nvar each = zrUtil.each;\n/**\n * @public\n */\n\nvar LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n/**\n * @public\n */\n\nvar HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];\nfunction boxLayout(orient, group, gap, maxWidth, maxHeight) {\n  var x = 0;\n  var y = 0;\n  if (maxWidth == null) {\n    maxWidth = Infinity;\n  }\n  if (maxHeight == null) {\n    maxHeight = Infinity;\n  }\n  var currentLineMaxSize = 0;\n  group.eachChild(function (child, idx) {\n    var position = child.position;\n    var rect = child.getBoundingRect();\n    var nextChild = group.childAt(idx + 1);\n    var nextChildRect = nextChild && nextChild.getBoundingRect();\n    var nextX;\n    var nextY;\n    if (orient === 'horizontal') {\n      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n      nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group\n      // FIXME compare before adding gap?\n\n      if (nextX > maxWidth || child.newline) {\n        x = 0;\n        nextX = moveX;\n        y += currentLineMaxSize + gap;\n        currentLineMaxSize = rect.height;\n      } else {\n        // FIXME: consider rect.y is not `0`?\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n      }\n    } else {\n      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n      nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group\n\n      if (nextY > maxHeight || child.newline) {\n        x += currentLineMaxSize + gap;\n        y = 0;\n        nextY = moveY;\n        currentLineMaxSize = rect.width;\n      } else {\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n      }\n    }\n    if (child.newline) {\n      return;\n    }\n    position[0] = x;\n    position[1] = y;\n    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n  });\n}\n/**\n * VBox or HBox layouting\n * @param {string} orient\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nvar box = boxLayout;\n/**\n * VBox layouting\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nvar vbox = zrUtil.curry(boxLayout, 'vertical');\n/**\n * HBox layouting\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nvar hbox = zrUtil.curry(boxLayout, 'horizontal');\n/**\n * If x or x2 is not specified or 'center' 'left' 'right',\n * the width would be as long as possible.\n * If y or y2 is not specified or 'middle' 'top' 'bottom',\n * the height would be as long as possible.\n *\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.x]\n * @param {number|string} [positionInfo.y]\n * @param {number|string} [positionInfo.x2]\n * @param {number|string} [positionInfo.y2]\n * @param {Object} containerRect {width, height}\n * @param {string|number} margin\n * @return {Object} {width, height}\n */\n\nfunction getAvailableSize(positionInfo, containerRect, margin) {\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var x = parsePercent(positionInfo.x, containerWidth);\n  var y = parsePercent(positionInfo.y, containerHeight);\n  var x2 = parsePercent(positionInfo.x2, containerWidth);\n  var y2 = parsePercent(positionInfo.y2, containerHeight);\n  (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n  (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n  (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n  (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  return {\n    width: Math.max(x2 - x - margin[1] - margin[3], 0),\n    height: Math.max(y2 - y - margin[0] - margin[2], 0)\n  };\n}\n/**\n * Parse position info.\n *\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.left]\n * @param {number|string} [positionInfo.top]\n * @param {number|string} [positionInfo.right]\n * @param {number|string} [positionInfo.bottom]\n * @param {number|string} [positionInfo.width]\n * @param {number|string} [positionInfo.height]\n * @param {number|string} [positionInfo.aspect] Aspect is width / height\n * @param {Object} containerRect\n * @param {string|number} [margin]\n *\n * @return {module:zrender/core/BoundingRect}\n */\n\nfunction getLayoutRect(positionInfo, containerRect, margin) {\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var left = parsePercent(positionInfo.left, containerWidth);\n  var top = parsePercent(positionInfo.top, containerHeight);\n  var right = parsePercent(positionInfo.right, containerWidth);\n  var bottom = parsePercent(positionInfo.bottom, containerHeight);\n  var width = parsePercent(positionInfo.width, containerWidth);\n  var height = parsePercent(positionInfo.height, containerHeight);\n  var verticalMargin = margin[2] + margin[0];\n  var horizontalMargin = margin[1] + margin[3];\n  var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right\n\n  if (isNaN(width)) {\n    width = containerWidth - right - horizontalMargin - left;\n  }\n  if (isNaN(height)) {\n    height = containerHeight - bottom - verticalMargin - top;\n  }\n  if (aspect != null) {\n    // If width and height are not given\n    // 1. Graph should not exceeds the container\n    // 2. Aspect must be keeped\n    // 3. Graph should take the space as more as possible\n    // FIXME\n    // Margin is not considered, because there is no case that both\n    // using margin and aspect so far.\n    if (isNaN(width) && isNaN(height)) {\n      if (aspect > containerWidth / containerHeight) {\n        width = containerWidth * 0.8;\n      } else {\n        height = containerHeight * 0.8;\n      }\n    } // Calculate width or height with given aspect\n\n    if (isNaN(width)) {\n      width = aspect * height;\n    }\n    if (isNaN(height)) {\n      height = width / aspect;\n    }\n  } // If left is not specified, calculate left from right and width\n\n  if (isNaN(left)) {\n    left = containerWidth - right - width - horizontalMargin;\n  }\n  if (isNaN(top)) {\n    top = containerHeight - bottom - height - verticalMargin;\n  } // Align left and top\n\n  switch (positionInfo.left || positionInfo.right) {\n    case 'center':\n      left = containerWidth / 2 - width / 2 - margin[3];\n      break;\n    case 'right':\n      left = containerWidth - width - horizontalMargin;\n      break;\n  }\n  switch (positionInfo.top || positionInfo.bottom) {\n    case 'middle':\n    case 'center':\n      top = containerHeight / 2 - height / 2 - margin[0];\n      break;\n    case 'bottom':\n      top = containerHeight - height - verticalMargin;\n      break;\n  } // If something is wrong and left, top, width, height are calculated as NaN\n\n  left = left || 0;\n  top = top || 0;\n  if (isNaN(width)) {\n    // Width may be NaN if only one value is given except width\n    width = containerWidth - horizontalMargin - left - (right || 0);\n  }\n  if (isNaN(height)) {\n    // Height may be NaN if only one value is given except height\n    height = containerHeight - verticalMargin - top - (bottom || 0);\n  }\n  var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n  rect.margin = margin;\n  return rect;\n}\n/**\n * Position a zr element in viewport\n *  Group position is specified by either\n *  {left, top}, {right, bottom}\n *  If all properties exists, right and bottom will be igonred.\n *\n * Logic:\n *     1. Scale (against origin point in parent coord)\n *     2. Rotate (against origin point in parent coord)\n *     3. Traslate (with el.position by this method)\n * So this method only fixes the last step 'Traslate', which does not affect\n * scaling and rotating.\n *\n * If be called repeatly with the same input el, the same result will be gotten.\n *\n * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.left]\n * @param {number|string} [positionInfo.top]\n * @param {number|string} [positionInfo.right]\n * @param {number|string} [positionInfo.bottom]\n * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'\n * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'\n * @param {Object} containerRect\n * @param {string|number} margin\n * @param {Object} [opt]\n * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n * @param {Array.<number>} [opt.boundingMode='all']\n *        Specify how to calculate boundingRect when locating.\n *        'all': Position the boundingRect that is transformed and uioned\n *               both itself and its descendants.\n *               This mode simplies confine the elements in the bounding\n *               of their container (e.g., using 'right: 0').\n *        'raw': Position the boundingRect that is not transformed and only itself.\n *               This mode is useful when you want a element can overflow its\n *               container. (Consider a rotated circle needs to be located in a corner.)\n *               In this mode positionInfo.width/height can only be number.\n */\n\nfunction positionElement(el, positionInfo, containerRect, margin, opt) {\n  var h = !opt || !opt.hv || opt.hv[0];\n  var v = !opt || !opt.hv || opt.hv[1];\n  var boundingMode = opt && opt.boundingMode || 'all';\n  if (!h && !v) {\n    return;\n  }\n  var rect;\n  if (boundingMode === 'raw') {\n    rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();\n  } else {\n    rect = el.getBoundingRect();\n    if (el.needLocalTransform()) {\n      var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,\n      // which should not be modified.\n\n      rect = rect.clone();\n      rect.applyTransform(transform);\n    }\n  } // The real width and height can not be specified but calculated by the given el.\n\n  positionInfo = getLayoutRect(zrUtil.defaults({\n    width: rect.width,\n    height: rect.height\n  }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform\n  // (see zrender/core/Transformable#getLocalTransform),\n  // we can just only modify el.position to get final result.\n\n  var elPos = el.position;\n  var dx = h ? positionInfo.x - rect.x : 0;\n  var dy = v ? positionInfo.y - rect.y : 0;\n  el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n}\n/**\n * @param {Object} option Contains some of the properties in HV_NAMES.\n * @param {number} hvIdx 0: horizontal; 1: vertical.\n */\n\nfunction sizeCalculable(option, hvIdx) {\n  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;\n}\n/**\n * Consider Case:\n * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n * through setOption or media query, using normal zrUtil.merge will cause\n * {right: 0} does not take effect.\n *\n * @example\n * ComponentModel.extend({\n *     init: function () {\n *         ...\n *         var inputPositionParams = layout.getLayoutParams(option);\n *         this.mergeOption(inputPositionParams);\n *     },\n *     mergeOption: function (newOption) {\n *         newOption && zrUtil.merge(thisOption, newOption, true);\n *         layout.mergeLayoutParam(thisOption, newOption);\n *     }\n * });\n *\n * @param {Object} targetOption\n * @param {Object} newOption\n * @param {Object|string} [opt]\n * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components\n *  that width (or height) should not be calculated by left and right (or top and bottom).\n */\n\nfunction mergeLayoutParam(targetOption, newOption, opt) {\n  !zrUtil.isObject(opt) && (opt = {});\n  var ignoreSize = opt.ignoreSize;\n  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n  var hResult = merge(HV_NAMES[0], 0);\n  var vResult = merge(HV_NAMES[1], 1);\n  copy(HV_NAMES[0], targetOption, hResult);\n  copy(HV_NAMES[1], targetOption, vResult);\n  function merge(names, hvIdx) {\n    var newParams = {};\n    var newValueCount = 0;\n    var merged = {};\n    var mergedValueCount = 0;\n    var enoughParamNumber = 2;\n    each(names, function (name) {\n      merged[name] = targetOption[name];\n    });\n    each(names, function (name) {\n      // Consider case: newOption.width is null, which is\n      // set by user for removing width setting.\n      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n      hasValue(newParams, name) && newValueCount++;\n      hasValue(merged, name) && mergedValueCount++;\n    });\n    if (ignoreSize[hvIdx]) {\n      // Only one of left/right is premitted to exist.\n      if (hasValue(newOption, names[1])) {\n        merged[names[2]] = null;\n      } else if (hasValue(newOption, names[2])) {\n        merged[names[1]] = null;\n      }\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // or targetOption: {right: ...} and newOption: {width: ...},\n    // There is no conflict when merged only has params count\n    // little than enoughParamNumber.\n\n    if (mergedValueCount === enoughParamNumber || !newValueCount) {\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // Than we can make sure user only want those two, and ignore\n    // all origin params in targetOption.\n    else if (newValueCount >= enoughParamNumber) {\n      return newParams;\n    } else {\n      // Chose another param from targetOption by priority.\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n          newParams[name] = targetOption[name];\n          break;\n        }\n      }\n      return newParams;\n    }\n  }\n  function hasProp(obj, name) {\n    return obj.hasOwnProperty(name);\n  }\n  function hasValue(obj, name) {\n    return obj[name] != null && obj[name] !== 'auto';\n  }\n  function copy(names, target, source) {\n    each(names, function (name) {\n      target[name] = source[name];\n    });\n  }\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\nfunction getLayoutParams(source) {\n  return copyLayoutParams({}, source);\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\nfunction copyLayoutParams(target, source) {\n  source && target && each(LOCATION_PARAMS, function (name) {\n    source.hasOwnProperty(name) && (target[name] = source[name]);\n  });\n  return target;\n}\nexports.LOCATION_PARAMS = LOCATION_PARAMS;\nexports.HV_NAMES = HV_NAMES;\nexports.box = box;\nexports.vbox = vbox;\nexports.hbox = hbox;\nexports.getAvailableSize = getAvailableSize;\nexports.getLayoutRect = getLayoutRect;\nexports.positionElement = positionElement;\nexports.sizeCalculable = sizeCalculable;\nexports.mergeLayoutParam = mergeLayoutParam;\nexports.getLayoutParams = getLayoutParams;\nexports.copyLayoutParams = copyLayoutParams;","map":{"version":3,"names":["zrUtil","require","BoundingRect","_number","parsePercent","formatUtil","each","LOCATION_PARAMS","HV_NAMES","boxLayout","orient","group","gap","maxWidth","maxHeight","x","y","Infinity","currentLineMaxSize","eachChild","child","idx","position","rect","getBoundingRect","nextChild","childAt","nextChildRect","nextX","nextY","moveX","width","newline","height","Math","max","moveY","box","vbox","curry","hbox","getAvailableSize","positionInfo","containerRect","margin","containerWidth","containerHeight","x2","y2","isNaN","parseFloat","normalizeCssArray","getLayoutRect","left","top","right","bottom","verticalMargin","horizontalMargin","aspect","positionElement","el","opt","h","hv","v","boundingMode","type","needLocalTransform","transform","getLocalTransform","clone","applyTransform","defaults","elPos","dx","dy","attr","sizeCalculable","option","hvIdx","mergeLayoutParam","targetOption","newOption","isObject","ignoreSize","isArray","hResult","merge","vResult","copy","names","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","name","hasProp","hasValue","i","length","obj","hasOwnProperty","target","source","getLayoutParams","copyLayoutParams","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/echarts/lib/util/layout.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _number = require(\"./number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar formatUtil = require(\"./format\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Layout helpers for each component positioning\nvar each = zrUtil.each;\n/**\n * @public\n */\n\nvar LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n/**\n * @public\n */\n\nvar HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];\n\nfunction boxLayout(orient, group, gap, maxWidth, maxHeight) {\n  var x = 0;\n  var y = 0;\n\n  if (maxWidth == null) {\n    maxWidth = Infinity;\n  }\n\n  if (maxHeight == null) {\n    maxHeight = Infinity;\n  }\n\n  var currentLineMaxSize = 0;\n  group.eachChild(function (child, idx) {\n    var position = child.position;\n    var rect = child.getBoundingRect();\n    var nextChild = group.childAt(idx + 1);\n    var nextChildRect = nextChild && nextChild.getBoundingRect();\n    var nextX;\n    var nextY;\n\n    if (orient === 'horizontal') {\n      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n      nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group\n      // FIXME compare before adding gap?\n\n      if (nextX > maxWidth || child.newline) {\n        x = 0;\n        nextX = moveX;\n        y += currentLineMaxSize + gap;\n        currentLineMaxSize = rect.height;\n      } else {\n        // FIXME: consider rect.y is not `0`?\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n      }\n    } else {\n      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n      nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group\n\n      if (nextY > maxHeight || child.newline) {\n        x += currentLineMaxSize + gap;\n        y = 0;\n        nextY = moveY;\n        currentLineMaxSize = rect.width;\n      } else {\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n      }\n    }\n\n    if (child.newline) {\n      return;\n    }\n\n    position[0] = x;\n    position[1] = y;\n    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n  });\n}\n/**\n * VBox or HBox layouting\n * @param {string} orient\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\n\nvar box = boxLayout;\n/**\n * VBox layouting\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nvar vbox = zrUtil.curry(boxLayout, 'vertical');\n/**\n * HBox layouting\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nvar hbox = zrUtil.curry(boxLayout, 'horizontal');\n/**\n * If x or x2 is not specified or 'center' 'left' 'right',\n * the width would be as long as possible.\n * If y or y2 is not specified or 'middle' 'top' 'bottom',\n * the height would be as long as possible.\n *\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.x]\n * @param {number|string} [positionInfo.y]\n * @param {number|string} [positionInfo.x2]\n * @param {number|string} [positionInfo.y2]\n * @param {Object} containerRect {width, height}\n * @param {string|number} margin\n * @return {Object} {width, height}\n */\n\nfunction getAvailableSize(positionInfo, containerRect, margin) {\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var x = parsePercent(positionInfo.x, containerWidth);\n  var y = parsePercent(positionInfo.y, containerHeight);\n  var x2 = parsePercent(positionInfo.x2, containerWidth);\n  var y2 = parsePercent(positionInfo.y2, containerHeight);\n  (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n  (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n  (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n  (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  return {\n    width: Math.max(x2 - x - margin[1] - margin[3], 0),\n    height: Math.max(y2 - y - margin[0] - margin[2], 0)\n  };\n}\n/**\n * Parse position info.\n *\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.left]\n * @param {number|string} [positionInfo.top]\n * @param {number|string} [positionInfo.right]\n * @param {number|string} [positionInfo.bottom]\n * @param {number|string} [positionInfo.width]\n * @param {number|string} [positionInfo.height]\n * @param {number|string} [positionInfo.aspect] Aspect is width / height\n * @param {Object} containerRect\n * @param {string|number} [margin]\n *\n * @return {module:zrender/core/BoundingRect}\n */\n\n\nfunction getLayoutRect(positionInfo, containerRect, margin) {\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var left = parsePercent(positionInfo.left, containerWidth);\n  var top = parsePercent(positionInfo.top, containerHeight);\n  var right = parsePercent(positionInfo.right, containerWidth);\n  var bottom = parsePercent(positionInfo.bottom, containerHeight);\n  var width = parsePercent(positionInfo.width, containerWidth);\n  var height = parsePercent(positionInfo.height, containerHeight);\n  var verticalMargin = margin[2] + margin[0];\n  var horizontalMargin = margin[1] + margin[3];\n  var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right\n\n  if (isNaN(width)) {\n    width = containerWidth - right - horizontalMargin - left;\n  }\n\n  if (isNaN(height)) {\n    height = containerHeight - bottom - verticalMargin - top;\n  }\n\n  if (aspect != null) {\n    // If width and height are not given\n    // 1. Graph should not exceeds the container\n    // 2. Aspect must be keeped\n    // 3. Graph should take the space as more as possible\n    // FIXME\n    // Margin is not considered, because there is no case that both\n    // using margin and aspect so far.\n    if (isNaN(width) && isNaN(height)) {\n      if (aspect > containerWidth / containerHeight) {\n        width = containerWidth * 0.8;\n      } else {\n        height = containerHeight * 0.8;\n      }\n    } // Calculate width or height with given aspect\n\n\n    if (isNaN(width)) {\n      width = aspect * height;\n    }\n\n    if (isNaN(height)) {\n      height = width / aspect;\n    }\n  } // If left is not specified, calculate left from right and width\n\n\n  if (isNaN(left)) {\n    left = containerWidth - right - width - horizontalMargin;\n  }\n\n  if (isNaN(top)) {\n    top = containerHeight - bottom - height - verticalMargin;\n  } // Align left and top\n\n\n  switch (positionInfo.left || positionInfo.right) {\n    case 'center':\n      left = containerWidth / 2 - width / 2 - margin[3];\n      break;\n\n    case 'right':\n      left = containerWidth - width - horizontalMargin;\n      break;\n  }\n\n  switch (positionInfo.top || positionInfo.bottom) {\n    case 'middle':\n    case 'center':\n      top = containerHeight / 2 - height / 2 - margin[0];\n      break;\n\n    case 'bottom':\n      top = containerHeight - height - verticalMargin;\n      break;\n  } // If something is wrong and left, top, width, height are calculated as NaN\n\n\n  left = left || 0;\n  top = top || 0;\n\n  if (isNaN(width)) {\n    // Width may be NaN if only one value is given except width\n    width = containerWidth - horizontalMargin - left - (right || 0);\n  }\n\n  if (isNaN(height)) {\n    // Height may be NaN if only one value is given except height\n    height = containerHeight - verticalMargin - top - (bottom || 0);\n  }\n\n  var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n  rect.margin = margin;\n  return rect;\n}\n/**\n * Position a zr element in viewport\n *  Group position is specified by either\n *  {left, top}, {right, bottom}\n *  If all properties exists, right and bottom will be igonred.\n *\n * Logic:\n *     1. Scale (against origin point in parent coord)\n *     2. Rotate (against origin point in parent coord)\n *     3. Traslate (with el.position by this method)\n * So this method only fixes the last step 'Traslate', which does not affect\n * scaling and rotating.\n *\n * If be called repeatly with the same input el, the same result will be gotten.\n *\n * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.left]\n * @param {number|string} [positionInfo.top]\n * @param {number|string} [positionInfo.right]\n * @param {number|string} [positionInfo.bottom]\n * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'\n * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'\n * @param {Object} containerRect\n * @param {string|number} margin\n * @param {Object} [opt]\n * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n * @param {Array.<number>} [opt.boundingMode='all']\n *        Specify how to calculate boundingRect when locating.\n *        'all': Position the boundingRect that is transformed and uioned\n *               both itself and its descendants.\n *               This mode simplies confine the elements in the bounding\n *               of their container (e.g., using 'right: 0').\n *        'raw': Position the boundingRect that is not transformed and only itself.\n *               This mode is useful when you want a element can overflow its\n *               container. (Consider a rotated circle needs to be located in a corner.)\n *               In this mode positionInfo.width/height can only be number.\n */\n\n\nfunction positionElement(el, positionInfo, containerRect, margin, opt) {\n  var h = !opt || !opt.hv || opt.hv[0];\n  var v = !opt || !opt.hv || opt.hv[1];\n  var boundingMode = opt && opt.boundingMode || 'all';\n\n  if (!h && !v) {\n    return;\n  }\n\n  var rect;\n\n  if (boundingMode === 'raw') {\n    rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();\n  } else {\n    rect = el.getBoundingRect();\n\n    if (el.needLocalTransform()) {\n      var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,\n      // which should not be modified.\n\n      rect = rect.clone();\n      rect.applyTransform(transform);\n    }\n  } // The real width and height can not be specified but calculated by the given el.\n\n\n  positionInfo = getLayoutRect(zrUtil.defaults({\n    width: rect.width,\n    height: rect.height\n  }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform\n  // (see zrender/core/Transformable#getLocalTransform),\n  // we can just only modify el.position to get final result.\n\n  var elPos = el.position;\n  var dx = h ? positionInfo.x - rect.x : 0;\n  var dy = v ? positionInfo.y - rect.y : 0;\n  el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n}\n/**\n * @param {Object} option Contains some of the properties in HV_NAMES.\n * @param {number} hvIdx 0: horizontal; 1: vertical.\n */\n\n\nfunction sizeCalculable(option, hvIdx) {\n  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;\n}\n/**\n * Consider Case:\n * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n * through setOption or media query, using normal zrUtil.merge will cause\n * {right: 0} does not take effect.\n *\n * @example\n * ComponentModel.extend({\n *     init: function () {\n *         ...\n *         var inputPositionParams = layout.getLayoutParams(option);\n *         this.mergeOption(inputPositionParams);\n *     },\n *     mergeOption: function (newOption) {\n *         newOption && zrUtil.merge(thisOption, newOption, true);\n *         layout.mergeLayoutParam(thisOption, newOption);\n *     }\n * });\n *\n * @param {Object} targetOption\n * @param {Object} newOption\n * @param {Object|string} [opt]\n * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components\n *  that width (or height) should not be calculated by left and right (or top and bottom).\n */\n\n\nfunction mergeLayoutParam(targetOption, newOption, opt) {\n  !zrUtil.isObject(opt) && (opt = {});\n  var ignoreSize = opt.ignoreSize;\n  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n  var hResult = merge(HV_NAMES[0], 0);\n  var vResult = merge(HV_NAMES[1], 1);\n  copy(HV_NAMES[0], targetOption, hResult);\n  copy(HV_NAMES[1], targetOption, vResult);\n\n  function merge(names, hvIdx) {\n    var newParams = {};\n    var newValueCount = 0;\n    var merged = {};\n    var mergedValueCount = 0;\n    var enoughParamNumber = 2;\n    each(names, function (name) {\n      merged[name] = targetOption[name];\n    });\n    each(names, function (name) {\n      // Consider case: newOption.width is null, which is\n      // set by user for removing width setting.\n      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n      hasValue(newParams, name) && newValueCount++;\n      hasValue(merged, name) && mergedValueCount++;\n    });\n\n    if (ignoreSize[hvIdx]) {\n      // Only one of left/right is premitted to exist.\n      if (hasValue(newOption, names[1])) {\n        merged[names[2]] = null;\n      } else if (hasValue(newOption, names[2])) {\n        merged[names[1]] = null;\n      }\n\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // or targetOption: {right: ...} and newOption: {width: ...},\n    // There is no conflict when merged only has params count\n    // little than enoughParamNumber.\n\n\n    if (mergedValueCount === enoughParamNumber || !newValueCount) {\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // Than we can make sure user only want those two, and ignore\n    // all origin params in targetOption.\n    else if (newValueCount >= enoughParamNumber) {\n        return newParams;\n      } else {\n        // Chose another param from targetOption by priority.\n        for (var i = 0; i < names.length; i++) {\n          var name = names[i];\n\n          if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n            newParams[name] = targetOption[name];\n            break;\n          }\n        }\n\n        return newParams;\n      }\n  }\n\n  function hasProp(obj, name) {\n    return obj.hasOwnProperty(name);\n  }\n\n  function hasValue(obj, name) {\n    return obj[name] != null && obj[name] !== 'auto';\n  }\n\n  function copy(names, target, source) {\n    each(names, function (name) {\n      target[name] = source[name];\n    });\n  }\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\n\nfunction getLayoutParams(source) {\n  return copyLayoutParams({}, source);\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\n\nfunction copyLayoutParams(target, source) {\n  source && target && each(LOCATION_PARAMS, function (name) {\n    source.hasOwnProperty(name) && (target[name] = source[name]);\n  });\n  return target;\n}\n\nexports.LOCATION_PARAMS = LOCATION_PARAMS;\nexports.HV_NAMES = HV_NAMES;\nexports.box = box;\nexports.vbox = vbox;\nexports.hbox = hbox;\nexports.getAvailableSize = getAvailableSize;\nexports.getLayoutRect = getLayoutRect;\nexports.positionElement = positionElement;\nexports.sizeCalculable = sizeCalculable;\nexports.mergeLayoutParam = mergeLayoutParam;\nexports.getLayoutParams = getLayoutParams;\nexports.copyLayoutParams = copyLayoutParams;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}