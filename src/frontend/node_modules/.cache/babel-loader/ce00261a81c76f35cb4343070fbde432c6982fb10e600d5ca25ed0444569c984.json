{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar textContain = require(\"zrender/lib/contain/text\");\nvar _model = require(\"../util/model\");\nvar makeInner = _model.makeInner;\nvar _axisHelper = require(\"./axisHelper\");\nvar makeLabelFormatter = _axisHelper.makeLabelFormatter;\nvar getOptionCategoryInterval = _axisHelper.getOptionCategoryInterval;\nvar shouldShowAllLabels = _axisHelper.shouldShowAllLabels;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\n/**\n * @param {module:echats/coord/Axis} axis\n * @return {Object} {\n *     labels: [{\n *         formattedLabel: string,\n *         rawLabel: string,\n *         tickValue: number\n *     }, ...],\n *     labelCategoryInterval: number\n * }\n */\n\nfunction createAxisLabels(axis) {\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);\n}\n/**\n * @param {module:echats/coord/Axis} axis\n * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.\n * @return {Object} {\n *     ticks: Array.<number>\n *     tickCategoryInterval: number\n * }\n */\n\nfunction createAxisTicks(axis, tickModel) {\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {\n    ticks: axis.scale.getTicks()\n  };\n}\nfunction makeCategoryLabels(axis) {\n  var labelModel = axis.getLabelModel();\n  var result = makeCategoryLabelsActually(axis, labelModel);\n  return !labelModel.get('show') || axis.scale.isBlank() ? {\n    labels: [],\n    labelCategoryInterval: result.labelCategoryInterval\n  } : result;\n}\nfunction makeCategoryLabelsActually(axis, labelModel) {\n  var labelsCache = getListCache(axis, 'labels');\n  var optionLabelInterval = getOptionCategoryInterval(labelModel);\n  var result = listCacheGet(labelsCache, optionLabelInterval);\n  if (result) {\n    return result;\n  }\n  var labels;\n  var numericLabelInterval;\n  if (zrUtil.isFunction(optionLabelInterval)) {\n    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\n  } else {\n    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;\n    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\n  } // Cache to avoid calling interval function repeatly.\n\n  return listCacheSet(labelsCache, optionLabelInterval, {\n    labels: labels,\n    labelCategoryInterval: numericLabelInterval\n  });\n}\nfunction makeCategoryTicks(axis, tickModel) {\n  var ticksCache = getListCache(axis, 'ticks');\n  var optionTickInterval = getOptionCategoryInterval(tickModel);\n  var result = listCacheGet(ticksCache, optionTickInterval);\n  if (result) {\n    return result;\n  }\n  var ticks;\n  var tickCategoryInterval; // Optimize for the case that large category data and no label displayed,\n  // we should not return all ticks.\n\n  if (!tickModel.get('show') || axis.scale.isBlank()) {\n    ticks = [];\n  }\n  if (zrUtil.isFunction(optionTickInterval)) {\n    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\n  } // Always use label interval by default despite label show. Consider this\n  // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows\n  // labels. `splitLine` and `axisTick` should be consistent in this case.\n  else if (optionTickInterval === 'auto') {\n    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());\n    tickCategoryInterval = labelsResult.labelCategoryInterval;\n    ticks = zrUtil.map(labelsResult.labels, function (labelItem) {\n      return labelItem.tickValue;\n    });\n  } else {\n    tickCategoryInterval = optionTickInterval;\n    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\n  } // Cache to avoid calling interval function repeatly.\n\n  return listCacheSet(ticksCache, optionTickInterval, {\n    ticks: ticks,\n    tickCategoryInterval: tickCategoryInterval\n  });\n}\nfunction makeRealNumberLabels(axis) {\n  var ticks = axis.scale.getTicks();\n  var labelFormatter = makeLabelFormatter(axis);\n  return {\n    labels: zrUtil.map(ticks, function (tickValue, idx) {\n      return {\n        formattedLabel: labelFormatter(tickValue, idx),\n        rawLabel: axis.scale.getLabel(tickValue),\n        tickValue: tickValue\n      };\n    })\n  };\n} // Large category data calculation is performence sensitive, and ticks and label\n// probably be fetched by multiple times. So we cache the result.\n// axis is created each time during a ec process, so we do not need to clear cache.\n\nfunction getListCache(axis, prop) {\n  // Because key can be funciton, and cache size always be small, we use array cache.\n  return inner(axis)[prop] || (inner(axis)[prop] = []);\n}\nfunction listCacheGet(cache, key) {\n  for (var i = 0; i < cache.length; i++) {\n    if (cache[i].key === key) {\n      return cache[i].value;\n    }\n  }\n}\nfunction listCacheSet(cache, key, value) {\n  cache.push({\n    key: key,\n    value: value\n  });\n  return value;\n}\nfunction makeAutoCategoryInterval(axis) {\n  var result = inner(axis).autoInterval;\n  return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();\n}\n/**\n * Calculate interval for category axis ticks and labels.\n * To get precise result, at least one of `getRotate` and `isHorizontal`\n * should be implemented in axis.\n */\n\nfunction calculateCategoryInterval(axis) {\n  var params = fetchAutoCategoryIntervalCalculationParams(axis);\n  var labelFormatter = makeLabelFormatter(axis);\n  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:\n  // avoid generating a long array by `getTicks`\n  // in large category data case.\n\n  var tickCount = ordinalScale.count();\n  if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n    return 0;\n  }\n  var step = 1; // Simple optimization. Empirical value: tick count should less than 40.\n\n  if (tickCount > 40) {\n    step = Math.max(1, Math.floor(tickCount / 40));\n  }\n  var tickValue = ordinalExtent[0];\n  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n  var unitW = Math.abs(unitSpan * Math.cos(rotation));\n  var unitH = Math.abs(unitSpan * Math.sin(rotation));\n  var maxW = 0;\n  var maxH = 0; // Caution: Performance sensitive for large category data.\n  // Consider dataZoom, we should make appropriate step to avoid O(n) loop.\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    var width = 0;\n    var height = 0; // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n\n    var rect = textContain.getBoundingRect(labelFormatter(tickValue), params.font, 'center', 'top'); // Magic number\n\n    width = rect.width * 1.3;\n    height = rect.height * 1.3; // Min size, void long loop.\n\n    maxW = Math.max(maxW, width, 7);\n    maxH = Math.max(maxH, height, 7);\n  }\n  var dw = maxW / unitW;\n  var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.\n\n  isNaN(dw) && (dw = Infinity);\n  isNaN(dh) && (dh = Infinity);\n  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\n  var cache = inner(axis.model);\n  var axisExtent = axis.getExtent();\n  var lastAutoInterval = cache.lastAutoInterval;\n  var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,\n  // otherwise the calculated interval might jitter when the zoom\n  // window size is close to the interval-changing size.\n  // For example, if all of the axis labels are `a, b, c, d, e, f, g`.\n  // The jitter will cause that sometimes the displayed labels are\n  // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).\n\n  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical\n  // point is not the same when zooming in or zooming out.\n  && lastAutoInterval > interval // If the axis change is caused by chart resize, the cache should not\n  // be used. Otherwise some hiden labels might not be shown again.\n  && cache.axisExtend0 === axisExtent[0] && cache.axisExtend1 === axisExtent[1]) {\n    interval = lastAutoInterval;\n  } // Only update cache if cache not used, otherwise the\n  // changing of interval is too insensitive.\n  else {\n    cache.lastTickCount = tickCount;\n    cache.lastAutoInterval = interval;\n    cache.axisExtend0 = axisExtent[0];\n    cache.axisExtend1 = axisExtent[1];\n  }\n  return interval;\n}\nfunction fetchAutoCategoryIntervalCalculationParams(axis) {\n  var labelModel = axis.getLabelModel();\n  return {\n    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\n    labelRotate: labelModel.get('rotate') || 0,\n    font: labelModel.getFont()\n  };\n}\nfunction makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\n  var labelFormatter = makeLabelFormatter(axis);\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var labelModel = axis.getLabelModel();\n  var result = []; // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...\n\n  var step = Math.max((categoryInterval || 0) + 1, 1);\n  var startTick = ordinalExtent[0];\n  var tickCount = ordinalScale.count(); // Calculate start tick based on zero if possible to keep label consistent\n  // while zooming and moving while interval > 0. Otherwise the selection\n  // of displayable ticks and symbols probably keep changing.\n  // 3 is empirical value.\n\n  if (startTick !== 0 && step > 1 && tickCount / step > 2) {\n    startTick = Math.round(Math.ceil(startTick / step) * step);\n  } // (1) Only add min max label here but leave overlap checking\n  // to render stage, which also ensure the returned list\n  // suitable for splitLine and splitArea rendering.\n  // (2) Scales except category always contain min max label so\n  // do not need to perform this process.\n\n  var showAllLabel = shouldShowAllLabels(axis);\n  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;\n  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;\n  if (includeMinLabel && startTick !== ordinalExtent[0]) {\n    addItem(ordinalExtent[0]);\n  } // Optimize: avoid generating large array by `ordinalScale.getTicks()`.\n\n  var tickValue = startTick;\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    addItem(tickValue);\n  }\n  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\n    addItem(ordinalExtent[1]);\n  }\n  function addItem(tVal) {\n    result.push(onlyTick ? tVal : {\n      formattedLabel: labelFormatter(tVal),\n      rawLabel: ordinalScale.getLabel(tVal),\n      tickValue: tVal\n    });\n  }\n  return result;\n} // When interval is function, the result `false` means ignore the tick.\n// It is time consuming for large category data.\n\nfunction makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\n  var ordinalScale = axis.scale;\n  var labelFormatter = makeLabelFormatter(axis);\n  var result = [];\n  zrUtil.each(ordinalScale.getTicks(), function (tickValue) {\n    var rawLabel = ordinalScale.getLabel(tickValue);\n    if (categoryInterval(tickValue, rawLabel)) {\n      result.push(onlyTick ? tickValue : {\n        formattedLabel: labelFormatter(tickValue),\n        rawLabel: rawLabel,\n        tickValue: tickValue\n      });\n    }\n  });\n  return result;\n}\nexports.createAxisLabels = createAxisLabels;\nexports.createAxisTicks = createAxisTicks;\nexports.calculateCategoryInterval = calculateCategoryInterval;","map":{"version":3,"names":["zrUtil","require","textContain","_model","makeInner","_axisHelper","makeLabelFormatter","getOptionCategoryInterval","shouldShowAllLabels","inner","createAxisLabels","axis","type","makeCategoryLabels","makeRealNumberLabels","createAxisTicks","tickModel","makeCategoryTicks","ticks","scale","getTicks","labelModel","getLabelModel","result","makeCategoryLabelsActually","get","isBlank","labels","labelCategoryInterval","labelsCache","getListCache","optionLabelInterval","listCacheGet","numericLabelInterval","isFunction","makeLabelsByCustomizedCategoryInterval","makeAutoCategoryInterval","makeLabelsByNumericCategoryInterval","listCacheSet","ticksCache","optionTickInterval","tickCategoryInterval","labelsResult","map","labelItem","tickValue","labelFormatter","idx","formattedLabel","rawLabel","getLabel","prop","cache","key","i","length","value","push","autoInterval","calculateCategoryInterval","params","fetchAutoCategoryIntervalCalculationParams","rotation","axisRotate","labelRotate","Math","PI","ordinalScale","ordinalExtent","getExtent","tickCount","count","step","max","floor","unitSpan","dataToCoord","unitW","abs","cos","unitH","sin","maxW","maxH","width","height","rect","getBoundingRect","font","dw","dh","isNaN","Infinity","interval","min","model","axisExtent","lastAutoInterval","lastTickCount","axisExtend0","axisExtend1","getRotate","isHorizontal","getFont","categoryInterval","onlyTick","startTick","round","ceil","showAllLabel","includeMinLabel","includeMaxLabel","addItem","tVal","each","exports"],"sources":["/Users/zoyazhou/workspace/vscodeProjects/ccc_assign2/node_modules/echarts/lib/coord/axisTickLabelBuilder.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar _model = require(\"../util/model\");\n\nvar makeInner = _model.makeInner;\n\nvar _axisHelper = require(\"./axisHelper\");\n\nvar makeLabelFormatter = _axisHelper.makeLabelFormatter;\nvar getOptionCategoryInterval = _axisHelper.getOptionCategoryInterval;\nvar shouldShowAllLabels = _axisHelper.shouldShowAllLabels;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\n/**\n * @param {module:echats/coord/Axis} axis\n * @return {Object} {\n *     labels: [{\n *         formattedLabel: string,\n *         rawLabel: string,\n *         tickValue: number\n *     }, ...],\n *     labelCategoryInterval: number\n * }\n */\n\nfunction createAxisLabels(axis) {\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);\n}\n/**\n * @param {module:echats/coord/Axis} axis\n * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.\n * @return {Object} {\n *     ticks: Array.<number>\n *     tickCategoryInterval: number\n * }\n */\n\n\nfunction createAxisTicks(axis, tickModel) {\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {\n    ticks: axis.scale.getTicks()\n  };\n}\n\nfunction makeCategoryLabels(axis) {\n  var labelModel = axis.getLabelModel();\n  var result = makeCategoryLabelsActually(axis, labelModel);\n  return !labelModel.get('show') || axis.scale.isBlank() ? {\n    labels: [],\n    labelCategoryInterval: result.labelCategoryInterval\n  } : result;\n}\n\nfunction makeCategoryLabelsActually(axis, labelModel) {\n  var labelsCache = getListCache(axis, 'labels');\n  var optionLabelInterval = getOptionCategoryInterval(labelModel);\n  var result = listCacheGet(labelsCache, optionLabelInterval);\n\n  if (result) {\n    return result;\n  }\n\n  var labels;\n  var numericLabelInterval;\n\n  if (zrUtil.isFunction(optionLabelInterval)) {\n    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\n  } else {\n    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;\n    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\n  } // Cache to avoid calling interval function repeatly.\n\n\n  return listCacheSet(labelsCache, optionLabelInterval, {\n    labels: labels,\n    labelCategoryInterval: numericLabelInterval\n  });\n}\n\nfunction makeCategoryTicks(axis, tickModel) {\n  var ticksCache = getListCache(axis, 'ticks');\n  var optionTickInterval = getOptionCategoryInterval(tickModel);\n  var result = listCacheGet(ticksCache, optionTickInterval);\n\n  if (result) {\n    return result;\n  }\n\n  var ticks;\n  var tickCategoryInterval; // Optimize for the case that large category data and no label displayed,\n  // we should not return all ticks.\n\n  if (!tickModel.get('show') || axis.scale.isBlank()) {\n    ticks = [];\n  }\n\n  if (zrUtil.isFunction(optionTickInterval)) {\n    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\n  } // Always use label interval by default despite label show. Consider this\n  // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows\n  // labels. `splitLine` and `axisTick` should be consistent in this case.\n  else if (optionTickInterval === 'auto') {\n      var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());\n      tickCategoryInterval = labelsResult.labelCategoryInterval;\n      ticks = zrUtil.map(labelsResult.labels, function (labelItem) {\n        return labelItem.tickValue;\n      });\n    } else {\n      tickCategoryInterval = optionTickInterval;\n      ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\n    } // Cache to avoid calling interval function repeatly.\n\n\n  return listCacheSet(ticksCache, optionTickInterval, {\n    ticks: ticks,\n    tickCategoryInterval: tickCategoryInterval\n  });\n}\n\nfunction makeRealNumberLabels(axis) {\n  var ticks = axis.scale.getTicks();\n  var labelFormatter = makeLabelFormatter(axis);\n  return {\n    labels: zrUtil.map(ticks, function (tickValue, idx) {\n      return {\n        formattedLabel: labelFormatter(tickValue, idx),\n        rawLabel: axis.scale.getLabel(tickValue),\n        tickValue: tickValue\n      };\n    })\n  };\n} // Large category data calculation is performence sensitive, and ticks and label\n// probably be fetched by multiple times. So we cache the result.\n// axis is created each time during a ec process, so we do not need to clear cache.\n\n\nfunction getListCache(axis, prop) {\n  // Because key can be funciton, and cache size always be small, we use array cache.\n  return inner(axis)[prop] || (inner(axis)[prop] = []);\n}\n\nfunction listCacheGet(cache, key) {\n  for (var i = 0; i < cache.length; i++) {\n    if (cache[i].key === key) {\n      return cache[i].value;\n    }\n  }\n}\n\nfunction listCacheSet(cache, key, value) {\n  cache.push({\n    key: key,\n    value: value\n  });\n  return value;\n}\n\nfunction makeAutoCategoryInterval(axis) {\n  var result = inner(axis).autoInterval;\n  return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();\n}\n/**\n * Calculate interval for category axis ticks and labels.\n * To get precise result, at least one of `getRotate` and `isHorizontal`\n * should be implemented in axis.\n */\n\n\nfunction calculateCategoryInterval(axis) {\n  var params = fetchAutoCategoryIntervalCalculationParams(axis);\n  var labelFormatter = makeLabelFormatter(axis);\n  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:\n  // avoid generating a long array by `getTicks`\n  // in large category data case.\n\n  var tickCount = ordinalScale.count();\n\n  if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n    return 0;\n  }\n\n  var step = 1; // Simple optimization. Empirical value: tick count should less than 40.\n\n  if (tickCount > 40) {\n    step = Math.max(1, Math.floor(tickCount / 40));\n  }\n\n  var tickValue = ordinalExtent[0];\n  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n  var unitW = Math.abs(unitSpan * Math.cos(rotation));\n  var unitH = Math.abs(unitSpan * Math.sin(rotation));\n  var maxW = 0;\n  var maxH = 0; // Caution: Performance sensitive for large category data.\n  // Consider dataZoom, we should make appropriate step to avoid O(n) loop.\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    var width = 0;\n    var height = 0; // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n\n    var rect = textContain.getBoundingRect(labelFormatter(tickValue), params.font, 'center', 'top'); // Magic number\n\n    width = rect.width * 1.3;\n    height = rect.height * 1.3; // Min size, void long loop.\n\n    maxW = Math.max(maxW, width, 7);\n    maxH = Math.max(maxH, height, 7);\n  }\n\n  var dw = maxW / unitW;\n  var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.\n\n  isNaN(dw) && (dw = Infinity);\n  isNaN(dh) && (dh = Infinity);\n  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\n  var cache = inner(axis.model);\n  var axisExtent = axis.getExtent();\n  var lastAutoInterval = cache.lastAutoInterval;\n  var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,\n  // otherwise the calculated interval might jitter when the zoom\n  // window size is close to the interval-changing size.\n  // For example, if all of the axis labels are `a, b, c, d, e, f, g`.\n  // The jitter will cause that sometimes the displayed labels are\n  // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).\n\n  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical\n  // point is not the same when zooming in or zooming out.\n  && lastAutoInterval > interval // If the axis change is caused by chart resize, the cache should not\n  // be used. Otherwise some hiden labels might not be shown again.\n  && cache.axisExtend0 === axisExtent[0] && cache.axisExtend1 === axisExtent[1]) {\n    interval = lastAutoInterval;\n  } // Only update cache if cache not used, otherwise the\n  // changing of interval is too insensitive.\n  else {\n      cache.lastTickCount = tickCount;\n      cache.lastAutoInterval = interval;\n      cache.axisExtend0 = axisExtent[0];\n      cache.axisExtend1 = axisExtent[1];\n    }\n\n  return interval;\n}\n\nfunction fetchAutoCategoryIntervalCalculationParams(axis) {\n  var labelModel = axis.getLabelModel();\n  return {\n    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\n    labelRotate: labelModel.get('rotate') || 0,\n    font: labelModel.getFont()\n  };\n}\n\nfunction makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\n  var labelFormatter = makeLabelFormatter(axis);\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var labelModel = axis.getLabelModel();\n  var result = []; // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...\n\n  var step = Math.max((categoryInterval || 0) + 1, 1);\n  var startTick = ordinalExtent[0];\n  var tickCount = ordinalScale.count(); // Calculate start tick based on zero if possible to keep label consistent\n  // while zooming and moving while interval > 0. Otherwise the selection\n  // of displayable ticks and symbols probably keep changing.\n  // 3 is empirical value.\n\n  if (startTick !== 0 && step > 1 && tickCount / step > 2) {\n    startTick = Math.round(Math.ceil(startTick / step) * step);\n  } // (1) Only add min max label here but leave overlap checking\n  // to render stage, which also ensure the returned list\n  // suitable for splitLine and splitArea rendering.\n  // (2) Scales except category always contain min max label so\n  // do not need to perform this process.\n\n\n  var showAllLabel = shouldShowAllLabels(axis);\n  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;\n  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;\n\n  if (includeMinLabel && startTick !== ordinalExtent[0]) {\n    addItem(ordinalExtent[0]);\n  } // Optimize: avoid generating large array by `ordinalScale.getTicks()`.\n\n\n  var tickValue = startTick;\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    addItem(tickValue);\n  }\n\n  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\n    addItem(ordinalExtent[1]);\n  }\n\n  function addItem(tVal) {\n    result.push(onlyTick ? tVal : {\n      formattedLabel: labelFormatter(tVal),\n      rawLabel: ordinalScale.getLabel(tVal),\n      tickValue: tVal\n    });\n  }\n\n  return result;\n} // When interval is function, the result `false` means ignore the tick.\n// It is time consuming for large category data.\n\n\nfunction makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\n  var ordinalScale = axis.scale;\n  var labelFormatter = makeLabelFormatter(axis);\n  var result = [];\n  zrUtil.each(ordinalScale.getTicks(), function (tickValue) {\n    var rawLabel = ordinalScale.getLabel(tickValue);\n\n    if (categoryInterval(tickValue, rawLabel)) {\n      result.push(onlyTick ? tickValue : {\n        formattedLabel: labelFormatter(tickValue),\n        rawLabel: rawLabel,\n        tickValue: tickValue\n      });\n    }\n  });\n  return result;\n}\n\nexports.createAxisLabels = createAxisLabels;\nexports.createAxisTicks = createAxisTicks;\nexports.calculateCategoryInterval = calculateCategoryInterval;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}